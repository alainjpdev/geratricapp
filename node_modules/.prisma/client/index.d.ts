
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model BugReport
 * 
 */
export type BugReport = $Result.DefaultSelection<Prisma.$BugReportPayload>
/**
 * Model Resident
 * 
 */
export type Resident = $Result.DefaultSelection<Prisma.$ResidentPayload>
/**
 * Model MedicationOrder
 * 
 */
export type MedicationOrder = $Result.DefaultSelection<Prisma.$MedicationOrderPayload>
/**
 * Model MedicationLog
 * 
 */
export type MedicationLog = $Result.DefaultSelection<Prisma.$MedicationLogPayload>
/**
 * Model VitalSign
 * 
 */
export type VitalSign = $Result.DefaultSelection<Prisma.$VitalSignPayload>
/**
 * Model NursingNote
 * 
 */
export type NursingNote = $Result.DefaultSelection<Prisma.$NursingNotePayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model ClassMember
 * 
 */
export type ClassMember = $Result.DefaultSelection<Prisma.$ClassMemberPayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model StreamItem
 * 
 */
export type StreamItem = $Result.DefaultSelection<Prisma.$StreamItemPayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model AssignmentStudent
 * 
 */
export type AssignmentStudent = $Result.DefaultSelection<Prisma.$AssignmentStudentPayload>
/**
 * Model AssignmentSubmission
 * 
 */
export type AssignmentSubmission = $Result.DefaultSelection<Prisma.$AssignmentSubmissionPayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = $Result.DefaultSelection<Prisma.$QuizQuestionPayload>
/**
 * Model QuizStudent
 * 
 */
export type QuizStudent = $Result.DefaultSelection<Prisma.$QuizStudentPayload>
/**
 * Model QuizSubmission
 * 
 */
export type QuizSubmission = $Result.DefaultSelection<Prisma.$QuizSubmissionPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model MaterialStudent
 * 
 */
export type MaterialStudent = $Result.DefaultSelection<Prisma.$MaterialStudentPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model Grade
 * 
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model StudentParent
 * 
 */
export type StudentParent = $Result.DefaultSelection<Prisma.$StudentParentPayload>
/**
 * Model AnnouncementStudent
 * 
 */
export type AnnouncementStudent = $Result.DefaultSelection<Prisma.$AnnouncementStudentPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Evento
 * 
 */
export type Evento = $Result.DefaultSelection<Prisma.$EventoPayload>
/**
 * Model Orden
 * 
 */
export type Orden = $Result.DefaultSelection<Prisma.$OrdenPayload>
/**
 * Model OrdenItem
 * 
 */
export type OrdenItem = $Result.DefaultSelection<Prisma.$OrdenItemPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bugReport`: Exposes CRUD operations for the **BugReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BugReports
    * const bugReports = await prisma.bugReport.findMany()
    * ```
    */
  get bugReport(): Prisma.BugReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resident`: Exposes CRUD operations for the **Resident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Residents
    * const residents = await prisma.resident.findMany()
    * ```
    */
  get resident(): Prisma.ResidentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicationOrder`: Exposes CRUD operations for the **MedicationOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicationOrders
    * const medicationOrders = await prisma.medicationOrder.findMany()
    * ```
    */
  get medicationOrder(): Prisma.MedicationOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicationLog`: Exposes CRUD operations for the **MedicationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicationLogs
    * const medicationLogs = await prisma.medicationLog.findMany()
    * ```
    */
  get medicationLog(): Prisma.MedicationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vitalSign`: Exposes CRUD operations for the **VitalSign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitalSigns
    * const vitalSigns = await prisma.vitalSign.findMany()
    * ```
    */
  get vitalSign(): Prisma.VitalSignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nursingNote`: Exposes CRUD operations for the **NursingNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NursingNotes
    * const nursingNotes = await prisma.nursingNote.findMany()
    * ```
    */
  get nursingNote(): Prisma.NursingNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classMember`: Exposes CRUD operations for the **ClassMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassMembers
    * const classMembers = await prisma.classMember.findMany()
    * ```
    */
  get classMember(): Prisma.ClassMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.streamItem`: Exposes CRUD operations for the **StreamItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StreamItems
    * const streamItems = await prisma.streamItem.findMany()
    * ```
    */
  get streamItem(): Prisma.StreamItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignmentStudent`: Exposes CRUD operations for the **AssignmentStudent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssignmentStudents
    * const assignmentStudents = await prisma.assignmentStudent.findMany()
    * ```
    */
  get assignmentStudent(): Prisma.AssignmentStudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignmentSubmission`: Exposes CRUD operations for the **AssignmentSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssignmentSubmissions
    * const assignmentSubmissions = await prisma.assignmentSubmission.findMany()
    * ```
    */
  get assignmentSubmission(): Prisma.AssignmentSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizStudent`: Exposes CRUD operations for the **QuizStudent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizStudents
    * const quizStudents = await prisma.quizStudent.findMany()
    * ```
    */
  get quizStudent(): Prisma.QuizStudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizSubmission`: Exposes CRUD operations for the **QuizSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizSubmissions
    * const quizSubmissions = await prisma.quizSubmission.findMany()
    * ```
    */
  get quizSubmission(): Prisma.QuizSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materialStudent`: Exposes CRUD operations for the **MaterialStudent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialStudents
    * const materialStudents = await prisma.materialStudent.findMany()
    * ```
    */
  get materialStudent(): Prisma.MaterialStudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentParent`: Exposes CRUD operations for the **StudentParent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentParents
    * const studentParents = await prisma.studentParent.findMany()
    * ```
    */
  get studentParent(): Prisma.StudentParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcementStudent`: Exposes CRUD operations for the **AnnouncementStudent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnnouncementStudents
    * const announcementStudents = await prisma.announcementStudent.findMany()
    * ```
    */
  get announcementStudent(): Prisma.AnnouncementStudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evento`: Exposes CRUD operations for the **Evento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eventos
    * const eventos = await prisma.evento.findMany()
    * ```
    */
  get evento(): Prisma.EventoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orden`: Exposes CRUD operations for the **Orden** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ordens
    * const ordens = await prisma.orden.findMany()
    * ```
    */
  get orden(): Prisma.OrdenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ordenItem`: Exposes CRUD operations for the **OrdenItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrdenItems
    * const ordenItems = await prisma.ordenItem.findMany()
    * ```
    */
  get ordenItem(): Prisma.OrdenItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    BugReport: 'BugReport',
    Resident: 'Resident',
    MedicationOrder: 'MedicationOrder',
    MedicationLog: 'MedicationLog',
    VitalSign: 'VitalSign',
    NursingNote: 'NursingNote',
    Class: 'Class',
    ClassMember: 'ClassMember',
    Topic: 'Topic',
    StreamItem: 'StreamItem',
    Assignment: 'Assignment',
    AssignmentStudent: 'AssignmentStudent',
    AssignmentSubmission: 'AssignmentSubmission',
    Quiz: 'Quiz',
    QuizQuestion: 'QuizQuestion',
    QuizStudent: 'QuizStudent',
    QuizSubmission: 'QuizSubmission',
    Material: 'Material',
    MaterialStudent: 'MaterialStudent',
    Attachment: 'Attachment',
    Grade: 'Grade',
    Module: 'Module',
    StudentParent: 'StudentParent',
    AnnouncementStudent: 'AnnouncementStudent',
    Client: 'Client',
    Evento: 'Evento',
    Orden: 'Orden',
    OrdenItem: 'OrdenItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "bugReport" | "resident" | "medicationOrder" | "medicationLog" | "vitalSign" | "nursingNote" | "class" | "classMember" | "topic" | "streamItem" | "assignment" | "assignmentStudent" | "assignmentSubmission" | "quiz" | "quizQuestion" | "quizStudent" | "quizSubmission" | "material" | "materialStudent" | "attachment" | "grade" | "module" | "studentParent" | "announcementStudent" | "client" | "evento" | "orden" | "ordenItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      BugReport: {
        payload: Prisma.$BugReportPayload<ExtArgs>
        fields: Prisma.BugReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BugReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BugReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          findFirst: {
            args: Prisma.BugReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BugReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          findMany: {
            args: Prisma.BugReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>[]
          }
          create: {
            args: Prisma.BugReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          createMany: {
            args: Prisma.BugReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BugReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>[]
          }
          delete: {
            args: Prisma.BugReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          update: {
            args: Prisma.BugReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          deleteMany: {
            args: Prisma.BugReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BugReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BugReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>[]
          }
          upsert: {
            args: Prisma.BugReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          aggregate: {
            args: Prisma.BugReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBugReport>
          }
          groupBy: {
            args: Prisma.BugReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<BugReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.BugReportCountArgs<ExtArgs>
            result: $Utils.Optional<BugReportCountAggregateOutputType> | number
          }
        }
      }
      Resident: {
        payload: Prisma.$ResidentPayload<ExtArgs>
        fields: Prisma.ResidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload>
          }
          findFirst: {
            args: Prisma.ResidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload>
          }
          findMany: {
            args: Prisma.ResidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload>[]
          }
          create: {
            args: Prisma.ResidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload>
          }
          createMany: {
            args: Prisma.ResidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResidentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload>[]
          }
          delete: {
            args: Prisma.ResidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload>
          }
          update: {
            args: Prisma.ResidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload>
          }
          deleteMany: {
            args: Prisma.ResidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResidentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload>[]
          }
          upsert: {
            args: Prisma.ResidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentPayload>
          }
          aggregate: {
            args: Prisma.ResidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResident>
          }
          groupBy: {
            args: Prisma.ResidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResidentCountArgs<ExtArgs>
            result: $Utils.Optional<ResidentCountAggregateOutputType> | number
          }
        }
      }
      MedicationOrder: {
        payload: Prisma.$MedicationOrderPayload<ExtArgs>
        fields: Prisma.MedicationOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload>
          }
          findFirst: {
            args: Prisma.MedicationOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload>
          }
          findMany: {
            args: Prisma.MedicationOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload>[]
          }
          create: {
            args: Prisma.MedicationOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload>
          }
          createMany: {
            args: Prisma.MedicationOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload>[]
          }
          delete: {
            args: Prisma.MedicationOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload>
          }
          update: {
            args: Prisma.MedicationOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload>
          }
          deleteMany: {
            args: Prisma.MedicationOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicationOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload>[]
          }
          upsert: {
            args: Prisma.MedicationOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationOrderPayload>
          }
          aggregate: {
            args: Prisma.MedicationOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicationOrder>
          }
          groupBy: {
            args: Prisma.MedicationOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationOrderCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationOrderCountAggregateOutputType> | number
          }
        }
      }
      MedicationLog: {
        payload: Prisma.$MedicationLogPayload<ExtArgs>
        fields: Prisma.MedicationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          findFirst: {
            args: Prisma.MedicationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          findMany: {
            args: Prisma.MedicationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>[]
          }
          create: {
            args: Prisma.MedicationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          createMany: {
            args: Prisma.MedicationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>[]
          }
          delete: {
            args: Prisma.MedicationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          update: {
            args: Prisma.MedicationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          deleteMany: {
            args: Prisma.MedicationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>[]
          }
          upsert: {
            args: Prisma.MedicationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          aggregate: {
            args: Prisma.MedicationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicationLog>
          }
          groupBy: {
            args: Prisma.MedicationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationLogCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationLogCountAggregateOutputType> | number
          }
        }
      }
      VitalSign: {
        payload: Prisma.$VitalSignPayload<ExtArgs>
        fields: Prisma.VitalSignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VitalSignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VitalSignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          findFirst: {
            args: Prisma.VitalSignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VitalSignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          findMany: {
            args: Prisma.VitalSignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>[]
          }
          create: {
            args: Prisma.VitalSignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          createMany: {
            args: Prisma.VitalSignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VitalSignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>[]
          }
          delete: {
            args: Prisma.VitalSignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          update: {
            args: Prisma.VitalSignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          deleteMany: {
            args: Prisma.VitalSignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VitalSignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VitalSignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>[]
          }
          upsert: {
            args: Prisma.VitalSignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          aggregate: {
            args: Prisma.VitalSignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVitalSign>
          }
          groupBy: {
            args: Prisma.VitalSignGroupByArgs<ExtArgs>
            result: $Utils.Optional<VitalSignGroupByOutputType>[]
          }
          count: {
            args: Prisma.VitalSignCountArgs<ExtArgs>
            result: $Utils.Optional<VitalSignCountAggregateOutputType> | number
          }
        }
      }
      NursingNote: {
        payload: Prisma.$NursingNotePayload<ExtArgs>
        fields: Prisma.NursingNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NursingNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NursingNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload>
          }
          findFirst: {
            args: Prisma.NursingNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NursingNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload>
          }
          findMany: {
            args: Prisma.NursingNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload>[]
          }
          create: {
            args: Prisma.NursingNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload>
          }
          createMany: {
            args: Prisma.NursingNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NursingNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload>[]
          }
          delete: {
            args: Prisma.NursingNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload>
          }
          update: {
            args: Prisma.NursingNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload>
          }
          deleteMany: {
            args: Prisma.NursingNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NursingNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NursingNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload>[]
          }
          upsert: {
            args: Prisma.NursingNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NursingNotePayload>
          }
          aggregate: {
            args: Prisma.NursingNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNursingNote>
          }
          groupBy: {
            args: Prisma.NursingNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NursingNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NursingNoteCountArgs<ExtArgs>
            result: $Utils.Optional<NursingNoteCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      ClassMember: {
        payload: Prisma.$ClassMemberPayload<ExtArgs>
        fields: Prisma.ClassMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload>
          }
          findFirst: {
            args: Prisma.ClassMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload>
          }
          findMany: {
            args: Prisma.ClassMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload>[]
          }
          create: {
            args: Prisma.ClassMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload>
          }
          createMany: {
            args: Prisma.ClassMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload>[]
          }
          delete: {
            args: Prisma.ClassMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload>
          }
          update: {
            args: Prisma.ClassMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload>
          }
          deleteMany: {
            args: Prisma.ClassMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload>[]
          }
          upsert: {
            args: Prisma.ClassMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassMemberPayload>
          }
          aggregate: {
            args: Prisma.ClassMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassMember>
          }
          groupBy: {
            args: Prisma.ClassMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ClassMemberCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      StreamItem: {
        payload: Prisma.$StreamItemPayload<ExtArgs>
        fields: Prisma.StreamItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StreamItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StreamItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload>
          }
          findFirst: {
            args: Prisma.StreamItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StreamItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload>
          }
          findMany: {
            args: Prisma.StreamItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload>[]
          }
          create: {
            args: Prisma.StreamItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload>
          }
          createMany: {
            args: Prisma.StreamItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StreamItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload>[]
          }
          delete: {
            args: Prisma.StreamItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload>
          }
          update: {
            args: Prisma.StreamItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload>
          }
          deleteMany: {
            args: Prisma.StreamItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StreamItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StreamItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload>[]
          }
          upsert: {
            args: Prisma.StreamItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamItemPayload>
          }
          aggregate: {
            args: Prisma.StreamItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStreamItem>
          }
          groupBy: {
            args: Prisma.StreamItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<StreamItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StreamItemCountArgs<ExtArgs>
            result: $Utils.Optional<StreamItemCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      AssignmentStudent: {
        payload: Prisma.$AssignmentStudentPayload<ExtArgs>
        fields: Prisma.AssignmentStudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentStudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentStudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentStudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentStudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload>
          }
          findMany: {
            args: Prisma.AssignmentStudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload>[]
          }
          create: {
            args: Prisma.AssignmentStudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload>
          }
          createMany: {
            args: Prisma.AssignmentStudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentStudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentStudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload>
          }
          update: {
            args: Prisma.AssignmentStudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentStudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentStudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssignmentStudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload>[]
          }
          upsert: {
            args: Prisma.AssignmentStudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentStudentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentStudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignmentStudent>
          }
          groupBy: {
            args: Prisma.AssignmentStudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentStudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentStudentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentStudentCountAggregateOutputType> | number
          }
        }
      }
      AssignmentSubmission: {
        payload: Prisma.$AssignmentSubmissionPayload<ExtArgs>
        fields: Prisma.AssignmentSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          findFirst: {
            args: Prisma.AssignmentSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          findMany: {
            args: Prisma.AssignmentSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          create: {
            args: Prisma.AssignmentSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          createMany: {
            args: Prisma.AssignmentSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          delete: {
            args: Prisma.AssignmentSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          update: {
            args: Prisma.AssignmentSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssignmentSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.AssignmentSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          aggregate: {
            args: Prisma.AssignmentSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignmentSubmission>
          }
          groupBy: {
            args: Prisma.AssignmentSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestion: {
        payload: Prisma.$QuizQuestionPayload<ExtArgs>
        fields: Prisma.QuizQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          update: {
            args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestion>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionCountAggregateOutputType> | number
          }
        }
      }
      QuizStudent: {
        payload: Prisma.$QuizStudentPayload<ExtArgs>
        fields: Prisma.QuizStudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizStudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizStudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload>
          }
          findFirst: {
            args: Prisma.QuizStudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizStudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload>
          }
          findMany: {
            args: Prisma.QuizStudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload>[]
          }
          create: {
            args: Prisma.QuizStudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload>
          }
          createMany: {
            args: Prisma.QuizStudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizStudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload>[]
          }
          delete: {
            args: Prisma.QuizStudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload>
          }
          update: {
            args: Prisma.QuizStudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload>
          }
          deleteMany: {
            args: Prisma.QuizStudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizStudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizStudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload>[]
          }
          upsert: {
            args: Prisma.QuizStudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizStudentPayload>
          }
          aggregate: {
            args: Prisma.QuizStudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizStudent>
          }
          groupBy: {
            args: Prisma.QuizStudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizStudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizStudentCountArgs<ExtArgs>
            result: $Utils.Optional<QuizStudentCountAggregateOutputType> | number
          }
        }
      }
      QuizSubmission: {
        payload: Prisma.$QuizSubmissionPayload<ExtArgs>
        fields: Prisma.QuizSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload>
          }
          findFirst: {
            args: Prisma.QuizSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload>
          }
          findMany: {
            args: Prisma.QuizSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload>[]
          }
          create: {
            args: Prisma.QuizSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload>
          }
          createMany: {
            args: Prisma.QuizSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload>[]
          }
          delete: {
            args: Prisma.QuizSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload>
          }
          update: {
            args: Prisma.QuizSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.QuizSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.QuizSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSubmissionPayload>
          }
          aggregate: {
            args: Prisma.QuizSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizSubmission>
          }
          groupBy: {
            args: Prisma.QuizSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      MaterialStudent: {
        payload: Prisma.$MaterialStudentPayload<ExtArgs>
        fields: Prisma.MaterialStudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialStudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialStudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload>
          }
          findFirst: {
            args: Prisma.MaterialStudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialStudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload>
          }
          findMany: {
            args: Prisma.MaterialStudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload>[]
          }
          create: {
            args: Prisma.MaterialStudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload>
          }
          createMany: {
            args: Prisma.MaterialStudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialStudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload>[]
          }
          delete: {
            args: Prisma.MaterialStudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload>
          }
          update: {
            args: Prisma.MaterialStudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload>
          }
          deleteMany: {
            args: Prisma.MaterialStudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialStudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialStudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload>[]
          }
          upsert: {
            args: Prisma.MaterialStudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialStudentPayload>
          }
          aggregate: {
            args: Prisma.MaterialStudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialStudent>
          }
          groupBy: {
            args: Prisma.MaterialStudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialStudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialStudentCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialStudentCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      StudentParent: {
        payload: Prisma.$StudentParentPayload<ExtArgs>
        fields: Prisma.StudentParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          findFirst: {
            args: Prisma.StudentParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          findMany: {
            args: Prisma.StudentParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>[]
          }
          create: {
            args: Prisma.StudentParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          createMany: {
            args: Prisma.StudentParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>[]
          }
          delete: {
            args: Prisma.StudentParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          update: {
            args: Prisma.StudentParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          deleteMany: {
            args: Prisma.StudentParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentParentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>[]
          }
          upsert: {
            args: Prisma.StudentParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          aggregate: {
            args: Prisma.StudentParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentParent>
          }
          groupBy: {
            args: Prisma.StudentParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentParentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentParentCountAggregateOutputType> | number
          }
        }
      }
      AnnouncementStudent: {
        payload: Prisma.$AnnouncementStudentPayload<ExtArgs>
        fields: Prisma.AnnouncementStudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementStudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementStudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementStudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementStudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload>
          }
          findMany: {
            args: Prisma.AnnouncementStudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload>[]
          }
          create: {
            args: Prisma.AnnouncementStudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload>
          }
          createMany: {
            args: Prisma.AnnouncementStudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementStudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementStudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload>
          }
          update: {
            args: Prisma.AnnouncementStudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementStudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementStudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementStudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementStudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementStudentPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementStudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncementStudent>
          }
          groupBy: {
            args: Prisma.AnnouncementStudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementStudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementStudentCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementStudentCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Evento: {
        payload: Prisma.$EventoPayload<ExtArgs>
        fields: Prisma.EventoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          findFirst: {
            args: Prisma.EventoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          findMany: {
            args: Prisma.EventoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>[]
          }
          create: {
            args: Prisma.EventoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          createMany: {
            args: Prisma.EventoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>[]
          }
          delete: {
            args: Prisma.EventoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          update: {
            args: Prisma.EventoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          deleteMany: {
            args: Prisma.EventoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>[]
          }
          upsert: {
            args: Prisma.EventoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          aggregate: {
            args: Prisma.EventoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvento>
          }
          groupBy: {
            args: Prisma.EventoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventoCountArgs<ExtArgs>
            result: $Utils.Optional<EventoCountAggregateOutputType> | number
          }
        }
      }
      Orden: {
        payload: Prisma.$OrdenPayload<ExtArgs>
        fields: Prisma.OrdenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>
          }
          findFirst: {
            args: Prisma.OrdenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>
          }
          findMany: {
            args: Prisma.OrdenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>[]
          }
          create: {
            args: Prisma.OrdenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>
          }
          createMany: {
            args: Prisma.OrdenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrdenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>[]
          }
          delete: {
            args: Prisma.OrdenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>
          }
          update: {
            args: Prisma.OrdenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>
          }
          deleteMany: {
            args: Prisma.OrdenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrdenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>[]
          }
          upsert: {
            args: Prisma.OrdenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenPayload>
          }
          aggregate: {
            args: Prisma.OrdenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrden>
          }
          groupBy: {
            args: Prisma.OrdenGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdenGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdenCountArgs<ExtArgs>
            result: $Utils.Optional<OrdenCountAggregateOutputType> | number
          }
        }
      }
      OrdenItem: {
        payload: Prisma.$OrdenItemPayload<ExtArgs>
        fields: Prisma.OrdenItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdenItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdenItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload>
          }
          findFirst: {
            args: Prisma.OrdenItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdenItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload>
          }
          findMany: {
            args: Prisma.OrdenItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload>[]
          }
          create: {
            args: Prisma.OrdenItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload>
          }
          createMany: {
            args: Prisma.OrdenItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrdenItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload>[]
          }
          delete: {
            args: Prisma.OrdenItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload>
          }
          update: {
            args: Prisma.OrdenItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload>
          }
          deleteMany: {
            args: Prisma.OrdenItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdenItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrdenItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload>[]
          }
          upsert: {
            args: Prisma.OrdenItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdenItemPayload>
          }
          aggregate: {
            args: Prisma.OrdenItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrdenItem>
          }
          groupBy: {
            args: Prisma.OrdenItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdenItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdenItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrdenItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    bugReport?: BugReportOmit
    resident?: ResidentOmit
    medicationOrder?: MedicationOrderOmit
    medicationLog?: MedicationLogOmit
    vitalSign?: VitalSignOmit
    nursingNote?: NursingNoteOmit
    class?: ClassOmit
    classMember?: ClassMemberOmit
    topic?: TopicOmit
    streamItem?: StreamItemOmit
    assignment?: AssignmentOmit
    assignmentStudent?: AssignmentStudentOmit
    assignmentSubmission?: AssignmentSubmissionOmit
    quiz?: QuizOmit
    quizQuestion?: QuizQuestionOmit
    quizStudent?: QuizStudentOmit
    quizSubmission?: QuizSubmissionOmit
    material?: MaterialOmit
    materialStudent?: MaterialStudentOmit
    attachment?: AttachmentOmit
    grade?: GradeOmit
    module?: ModuleOmit
    studentParent?: StudentParentOmit
    announcementStudent?: AnnouncementStudentOmit
    client?: ClientOmit
    evento?: EventoOmit
    orden?: OrdenOmit
    ordenItem?: OrdenItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    announcementStudents: number
    assignmentStudents: number
    assignmentSubmissions: number
    classMemberships: number
    classesAsTeacher: number
    gradesAsGrader: number
    gradesAsStudent: number
    materialStudents: number
    modulesCreated: number
    ordersCreated: number
    quizStudents: number
    quizSubmissions: number
    streamItems: number
    parentRelations: number
    studentParents: number
    bugReports: number
    medicationLogs: number
    recordedVitals: number
    authoredNotes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcementStudents?: boolean | UserCountOutputTypeCountAnnouncementStudentsArgs
    assignmentStudents?: boolean | UserCountOutputTypeCountAssignmentStudentsArgs
    assignmentSubmissions?: boolean | UserCountOutputTypeCountAssignmentSubmissionsArgs
    classMemberships?: boolean | UserCountOutputTypeCountClassMembershipsArgs
    classesAsTeacher?: boolean | UserCountOutputTypeCountClassesAsTeacherArgs
    gradesAsGrader?: boolean | UserCountOutputTypeCountGradesAsGraderArgs
    gradesAsStudent?: boolean | UserCountOutputTypeCountGradesAsStudentArgs
    materialStudents?: boolean | UserCountOutputTypeCountMaterialStudentsArgs
    modulesCreated?: boolean | UserCountOutputTypeCountModulesCreatedArgs
    ordersCreated?: boolean | UserCountOutputTypeCountOrdersCreatedArgs
    quizStudents?: boolean | UserCountOutputTypeCountQuizStudentsArgs
    quizSubmissions?: boolean | UserCountOutputTypeCountQuizSubmissionsArgs
    streamItems?: boolean | UserCountOutputTypeCountStreamItemsArgs
    parentRelations?: boolean | UserCountOutputTypeCountParentRelationsArgs
    studentParents?: boolean | UserCountOutputTypeCountStudentParentsArgs
    bugReports?: boolean | UserCountOutputTypeCountBugReportsArgs
    medicationLogs?: boolean | UserCountOutputTypeCountMedicationLogsArgs
    recordedVitals?: boolean | UserCountOutputTypeCountRecordedVitalsArgs
    authoredNotes?: boolean | UserCountOutputTypeCountAuthoredNotesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementStudentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignmentStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentStudentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignmentSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassesAsTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGradesAsGraderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGradesAsStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMaterialStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialStudentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModulesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizStudentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStreamItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreamItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParentRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudentParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBugReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BugReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMedicationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecordedVitalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthoredNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NursingNoteWhereInput
  }


  /**
   * Count Type ResidentCountOutputType
   */

  export type ResidentCountOutputType = {
    medications: number
    vitalSigns: number
    nursingNotes: number
  }

  export type ResidentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medications?: boolean | ResidentCountOutputTypeCountMedicationsArgs
    vitalSigns?: boolean | ResidentCountOutputTypeCountVitalSignsArgs
    nursingNotes?: boolean | ResidentCountOutputTypeCountNursingNotesArgs
  }

  // Custom InputTypes
  /**
   * ResidentCountOutputType without action
   */
  export type ResidentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentCountOutputType
     */
    select?: ResidentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResidentCountOutputType without action
   */
  export type ResidentCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationOrderWhereInput
  }

  /**
   * ResidentCountOutputType without action
   */
  export type ResidentCountOutputTypeCountVitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignWhereInput
  }

  /**
   * ResidentCountOutputType without action
   */
  export type ResidentCountOutputTypeCountNursingNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NursingNoteWhereInput
  }


  /**
   * Count Type MedicationOrderCountOutputType
   */

  export type MedicationOrderCountOutputType = {
    logs: number
  }

  export type MedicationOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | MedicationOrderCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * MedicationOrderCountOutputType without action
   */
  export type MedicationOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrderCountOutputType
     */
    select?: MedicationOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicationOrderCountOutputType without action
   */
  export type MedicationOrderCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationLogWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    members: number
    grades: number
    streamItems: number
    topics: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ClassCountOutputTypeCountMembersArgs
    grades?: boolean | ClassCountOutputTypeCountGradesArgs
    streamItems?: boolean | ClassCountOutputTypeCountStreamItemsArgs
    topics?: boolean | ClassCountOutputTypeCountTopicsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassMemberWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStreamItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreamItemWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    streamItems: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItems?: boolean | TopicCountOutputTypeCountStreamItemsArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountStreamItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreamItemWhereInput
  }


  /**
   * Count Type StreamItemCountOutputType
   */

  export type StreamItemCountOutputType = {
    announcementStudents: number
    attachments: number
  }

  export type StreamItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcementStudents?: boolean | StreamItemCountOutputTypeCountAnnouncementStudentsArgs
    attachments?: boolean | StreamItemCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * StreamItemCountOutputType without action
   */
  export type StreamItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItemCountOutputType
     */
    select?: StreamItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StreamItemCountOutputType without action
   */
  export type StreamItemCountOutputTypeCountAnnouncementStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementStudentWhereInput
  }

  /**
   * StreamItemCountOutputType without action
   */
  export type StreamItemCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Count Type AssignmentCountOutputType
   */

  export type AssignmentCountOutputType = {
    assignmentStudents: number
    assignmentSubmissions: number
    grades: number
  }

  export type AssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignmentStudents?: boolean | AssignmentCountOutputTypeCountAssignmentStudentsArgs
    assignmentSubmissions?: boolean | AssignmentCountOutputTypeCountAssignmentSubmissionsArgs
    grades?: boolean | AssignmentCountOutputTypeCountGradesArgs
  }

  // Custom InputTypes
  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentCountOutputType
     */
    select?: AssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountAssignmentStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentStudentWhereInput
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountAssignmentSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    grades: number
    questions: number
    quizStudents: number
    quizSubmissions: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grades?: boolean | QuizCountOutputTypeCountGradesArgs
    questions?: boolean | QuizCountOutputTypeCountQuestionsArgs
    quizStudents?: boolean | QuizCountOutputTypeCountQuizStudentsArgs
    quizSubmissions?: boolean | QuizCountOutputTypeCountQuizSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuizStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizStudentWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuizSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSubmissionWhereInput
  }


  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    materialStudents: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materialStudents?: boolean | MaterialCountOutputTypeCountMaterialStudentsArgs
  }

  // Custom InputTypes
  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountMaterialStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialStudentWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    classes: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | ModuleCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    eventos: number
    ordenes: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventos?: boolean | ClientCountOutputTypeCountEventosArgs
    ordenes?: boolean | ClientCountOutputTypeCountOrdenesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountEventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountOrdenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdenWhereInput
  }


  /**
   * Count Type OrdenCountOutputType
   */

  export type OrdenCountOutputType = {
    ordenItems: number
  }

  export type OrdenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordenItems?: boolean | OrdenCountOutputTypeCountOrdenItemsArgs
  }

  // Custom InputTypes
  /**
   * OrdenCountOutputType without action
   */
  export type OrdenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenCountOutputType
     */
    select?: OrdenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdenCountOutputType without action
   */
  export type OrdenCountOutputTypeCountOrdenItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdenItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    avatar: string | null
    passwordHash: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    grupoAsignado: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    avatar: string | null
    passwordHash: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    grupoAsignado: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    role: number
    avatar: number
    passwordHash: number
    isActive: number
    createdAt: number
    updatedAt: number
    grupoAsignado: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    avatar?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    grupoAsignado?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    avatar?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    grupoAsignado?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    avatar?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    grupoAsignado?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    firstName: string
    lastName: string
    role: string
    avatar: string | null
    passwordHash: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    grupoAsignado: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    avatar?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grupoAsignado?: boolean
    announcementStudents?: boolean | User$announcementStudentsArgs<ExtArgs>
    assignmentStudents?: boolean | User$assignmentStudentsArgs<ExtArgs>
    assignmentSubmissions?: boolean | User$assignmentSubmissionsArgs<ExtArgs>
    classMemberships?: boolean | User$classMembershipsArgs<ExtArgs>
    classesAsTeacher?: boolean | User$classesAsTeacherArgs<ExtArgs>
    gradesAsGrader?: boolean | User$gradesAsGraderArgs<ExtArgs>
    gradesAsStudent?: boolean | User$gradesAsStudentArgs<ExtArgs>
    materialStudents?: boolean | User$materialStudentsArgs<ExtArgs>
    modulesCreated?: boolean | User$modulesCreatedArgs<ExtArgs>
    ordersCreated?: boolean | User$ordersCreatedArgs<ExtArgs>
    quizStudents?: boolean | User$quizStudentsArgs<ExtArgs>
    quizSubmissions?: boolean | User$quizSubmissionsArgs<ExtArgs>
    streamItems?: boolean | User$streamItemsArgs<ExtArgs>
    parentRelations?: boolean | User$parentRelationsArgs<ExtArgs>
    studentParents?: boolean | User$studentParentsArgs<ExtArgs>
    bugReports?: boolean | User$bugReportsArgs<ExtArgs>
    resident?: boolean | User$residentArgs<ExtArgs>
    medicationLogs?: boolean | User$medicationLogsArgs<ExtArgs>
    recordedVitals?: boolean | User$recordedVitalsArgs<ExtArgs>
    authoredNotes?: boolean | User$authoredNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    avatar?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grupoAsignado?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    avatar?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grupoAsignado?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    avatar?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grupoAsignado?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "firstName" | "lastName" | "role" | "avatar" | "passwordHash" | "isActive" | "createdAt" | "updatedAt" | "grupoAsignado", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcementStudents?: boolean | User$announcementStudentsArgs<ExtArgs>
    assignmentStudents?: boolean | User$assignmentStudentsArgs<ExtArgs>
    assignmentSubmissions?: boolean | User$assignmentSubmissionsArgs<ExtArgs>
    classMemberships?: boolean | User$classMembershipsArgs<ExtArgs>
    classesAsTeacher?: boolean | User$classesAsTeacherArgs<ExtArgs>
    gradesAsGrader?: boolean | User$gradesAsGraderArgs<ExtArgs>
    gradesAsStudent?: boolean | User$gradesAsStudentArgs<ExtArgs>
    materialStudents?: boolean | User$materialStudentsArgs<ExtArgs>
    modulesCreated?: boolean | User$modulesCreatedArgs<ExtArgs>
    ordersCreated?: boolean | User$ordersCreatedArgs<ExtArgs>
    quizStudents?: boolean | User$quizStudentsArgs<ExtArgs>
    quizSubmissions?: boolean | User$quizSubmissionsArgs<ExtArgs>
    streamItems?: boolean | User$streamItemsArgs<ExtArgs>
    parentRelations?: boolean | User$parentRelationsArgs<ExtArgs>
    studentParents?: boolean | User$studentParentsArgs<ExtArgs>
    bugReports?: boolean | User$bugReportsArgs<ExtArgs>
    resident?: boolean | User$residentArgs<ExtArgs>
    medicationLogs?: boolean | User$medicationLogsArgs<ExtArgs>
    recordedVitals?: boolean | User$recordedVitalsArgs<ExtArgs>
    authoredNotes?: boolean | User$authoredNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      announcementStudents: Prisma.$AnnouncementStudentPayload<ExtArgs>[]
      assignmentStudents: Prisma.$AssignmentStudentPayload<ExtArgs>[]
      assignmentSubmissions: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
      classMemberships: Prisma.$ClassMemberPayload<ExtArgs>[]
      classesAsTeacher: Prisma.$ClassPayload<ExtArgs>[]
      gradesAsGrader: Prisma.$GradePayload<ExtArgs>[]
      gradesAsStudent: Prisma.$GradePayload<ExtArgs>[]
      materialStudents: Prisma.$MaterialStudentPayload<ExtArgs>[]
      modulesCreated: Prisma.$ModulePayload<ExtArgs>[]
      ordersCreated: Prisma.$OrdenPayload<ExtArgs>[]
      quizStudents: Prisma.$QuizStudentPayload<ExtArgs>[]
      quizSubmissions: Prisma.$QuizSubmissionPayload<ExtArgs>[]
      streamItems: Prisma.$StreamItemPayload<ExtArgs>[]
      parentRelations: Prisma.$StudentParentPayload<ExtArgs>[]
      studentParents: Prisma.$StudentParentPayload<ExtArgs>[]
      bugReports: Prisma.$BugReportPayload<ExtArgs>[]
      resident: Prisma.$ResidentPayload<ExtArgs> | null
      medicationLogs: Prisma.$MedicationLogPayload<ExtArgs>[]
      recordedVitals: Prisma.$VitalSignPayload<ExtArgs>[]
      authoredNotes: Prisma.$NursingNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      firstName: string
      lastName: string
      role: string
      avatar: string | null
      passwordHash: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      grupoAsignado: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    announcementStudents<T extends User$announcementStudentsArgs<ExtArgs> = {}>(args?: Subset<T, User$announcementStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignmentStudents<T extends User$assignmentStudentsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignmentStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignmentSubmissions<T extends User$assignmentSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignmentSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classMemberships<T extends User$classMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$classMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classesAsTeacher<T extends User$classesAsTeacherArgs<ExtArgs> = {}>(args?: Subset<T, User$classesAsTeacherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradesAsGrader<T extends User$gradesAsGraderArgs<ExtArgs> = {}>(args?: Subset<T, User$gradesAsGraderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradesAsStudent<T extends User$gradesAsStudentArgs<ExtArgs> = {}>(args?: Subset<T, User$gradesAsStudentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materialStudents<T extends User$materialStudentsArgs<ExtArgs> = {}>(args?: Subset<T, User$materialStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modulesCreated<T extends User$modulesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$modulesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordersCreated<T extends User$ordersCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizStudents<T extends User$quizStudentsArgs<ExtArgs> = {}>(args?: Subset<T, User$quizStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizSubmissions<T extends User$quizSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$quizSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    streamItems<T extends User$streamItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$streamItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parentRelations<T extends User$parentRelationsArgs<ExtArgs> = {}>(args?: Subset<T, User$parentRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentParents<T extends User$studentParentsArgs<ExtArgs> = {}>(args?: Subset<T, User$studentParentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bugReports<T extends User$bugReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$bugReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resident<T extends User$residentArgs<ExtArgs> = {}>(args?: Subset<T, User$residentArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    medicationLogs<T extends User$medicationLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$medicationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recordedVitals<T extends User$recordedVitalsArgs<ExtArgs> = {}>(args?: Subset<T, User$recordedVitalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authoredNotes<T extends User$authoredNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$authoredNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly grupoAsignado: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.announcementStudents
   */
  export type User$announcementStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    where?: AnnouncementStudentWhereInput
    orderBy?: AnnouncementStudentOrderByWithRelationInput | AnnouncementStudentOrderByWithRelationInput[]
    cursor?: AnnouncementStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementStudentScalarFieldEnum | AnnouncementStudentScalarFieldEnum[]
  }

  /**
   * User.assignmentStudents
   */
  export type User$assignmentStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    where?: AssignmentStudentWhereInput
    orderBy?: AssignmentStudentOrderByWithRelationInput | AssignmentStudentOrderByWithRelationInput[]
    cursor?: AssignmentStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentStudentScalarFieldEnum | AssignmentStudentScalarFieldEnum[]
  }

  /**
   * User.assignmentSubmissions
   */
  export type User$assignmentSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * User.classMemberships
   */
  export type User$classMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    where?: ClassMemberWhereInput
    orderBy?: ClassMemberOrderByWithRelationInput | ClassMemberOrderByWithRelationInput[]
    cursor?: ClassMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassMemberScalarFieldEnum | ClassMemberScalarFieldEnum[]
  }

  /**
   * User.classesAsTeacher
   */
  export type User$classesAsTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * User.gradesAsGrader
   */
  export type User$gradesAsGraderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * User.gradesAsStudent
   */
  export type User$gradesAsStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * User.materialStudents
   */
  export type User$materialStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    where?: MaterialStudentWhereInput
    orderBy?: MaterialStudentOrderByWithRelationInput | MaterialStudentOrderByWithRelationInput[]
    cursor?: MaterialStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialStudentScalarFieldEnum | MaterialStudentScalarFieldEnum[]
  }

  /**
   * User.modulesCreated
   */
  export type User$modulesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * User.ordersCreated
   */
  export type User$ordersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    where?: OrdenWhereInput
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[]
    cursor?: OrdenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[]
  }

  /**
   * User.quizStudents
   */
  export type User$quizStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    where?: QuizStudentWhereInput
    orderBy?: QuizStudentOrderByWithRelationInput | QuizStudentOrderByWithRelationInput[]
    cursor?: QuizStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizStudentScalarFieldEnum | QuizStudentScalarFieldEnum[]
  }

  /**
   * User.quizSubmissions
   */
  export type User$quizSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    where?: QuizSubmissionWhereInput
    orderBy?: QuizSubmissionOrderByWithRelationInput | QuizSubmissionOrderByWithRelationInput[]
    cursor?: QuizSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizSubmissionScalarFieldEnum | QuizSubmissionScalarFieldEnum[]
  }

  /**
   * User.streamItems
   */
  export type User$streamItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    where?: StreamItemWhereInput
    orderBy?: StreamItemOrderByWithRelationInput | StreamItemOrderByWithRelationInput[]
    cursor?: StreamItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StreamItemScalarFieldEnum | StreamItemScalarFieldEnum[]
  }

  /**
   * User.parentRelations
   */
  export type User$parentRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    cursor?: StudentParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * User.studentParents
   */
  export type User$studentParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    cursor?: StudentParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * User.bugReports
   */
  export type User$bugReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    where?: BugReportWhereInput
    orderBy?: BugReportOrderByWithRelationInput | BugReportOrderByWithRelationInput[]
    cursor?: BugReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BugReportScalarFieldEnum | BugReportScalarFieldEnum[]
  }

  /**
   * User.resident
   */
  export type User$residentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
    where?: ResidentWhereInput
  }

  /**
   * User.medicationLogs
   */
  export type User$medicationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    where?: MedicationLogWhereInput
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    cursor?: MedicationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationLogScalarFieldEnum | MedicationLogScalarFieldEnum[]
  }

  /**
   * User.recordedVitals
   */
  export type User$recordedVitalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    where?: VitalSignWhereInput
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    cursor?: VitalSignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * User.authoredNotes
   */
  export type User$authoredNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    where?: NursingNoteWhereInput
    orderBy?: NursingNoteOrderByWithRelationInput | NursingNoteOrderByWithRelationInput[]
    cursor?: NursingNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NursingNoteScalarFieldEnum | NursingNoteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model BugReport
   */

  export type AggregateBugReport = {
    _count: BugReportCountAggregateOutputType | null
    _min: BugReportMinAggregateOutputType | null
    _max: BugReportMaxAggregateOutputType | null
  }

  export type BugReportMinAggregateOutputType = {
    id: string | null
    description: string | null
    userId: string | null
    status: string | null
    type: string | null
    errorHash: string | null
    createdAt: Date | null
  }

  export type BugReportMaxAggregateOutputType = {
    id: string | null
    description: string | null
    userId: string | null
    status: string | null
    type: string | null
    errorHash: string | null
    createdAt: Date | null
  }

  export type BugReportCountAggregateOutputType = {
    id: number
    description: number
    userId: number
    status: number
    type: number
    errorHash: number
    createdAt: number
    _all: number
  }


  export type BugReportMinAggregateInputType = {
    id?: true
    description?: true
    userId?: true
    status?: true
    type?: true
    errorHash?: true
    createdAt?: true
  }

  export type BugReportMaxAggregateInputType = {
    id?: true
    description?: true
    userId?: true
    status?: true
    type?: true
    errorHash?: true
    createdAt?: true
  }

  export type BugReportCountAggregateInputType = {
    id?: true
    description?: true
    userId?: true
    status?: true
    type?: true
    errorHash?: true
    createdAt?: true
    _all?: true
  }

  export type BugReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BugReport to aggregate.
     */
    where?: BugReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportOrderByWithRelationInput | BugReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BugReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BugReports
    **/
    _count?: true | BugReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BugReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BugReportMaxAggregateInputType
  }

  export type GetBugReportAggregateType<T extends BugReportAggregateArgs> = {
        [P in keyof T & keyof AggregateBugReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBugReport[P]>
      : GetScalarType<T[P], AggregateBugReport[P]>
  }




  export type BugReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BugReportWhereInput
    orderBy?: BugReportOrderByWithAggregationInput | BugReportOrderByWithAggregationInput[]
    by: BugReportScalarFieldEnum[] | BugReportScalarFieldEnum
    having?: BugReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BugReportCountAggregateInputType | true
    _min?: BugReportMinAggregateInputType
    _max?: BugReportMaxAggregateInputType
  }

  export type BugReportGroupByOutputType = {
    id: string
    description: string
    userId: string | null
    status: string
    type: string
    errorHash: string | null
    createdAt: Date
    _count: BugReportCountAggregateOutputType | null
    _min: BugReportMinAggregateOutputType | null
    _max: BugReportMaxAggregateOutputType | null
  }

  type GetBugReportGroupByPayload<T extends BugReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BugReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BugReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BugReportGroupByOutputType[P]>
            : GetScalarType<T[P], BugReportGroupByOutputType[P]>
        }
      >
    >


  export type BugReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    userId?: boolean
    status?: boolean
    type?: boolean
    errorHash?: boolean
    createdAt?: boolean
    user?: boolean | BugReport$userArgs<ExtArgs>
  }, ExtArgs["result"]["bugReport"]>

  export type BugReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    userId?: boolean
    status?: boolean
    type?: boolean
    errorHash?: boolean
    createdAt?: boolean
    user?: boolean | BugReport$userArgs<ExtArgs>
  }, ExtArgs["result"]["bugReport"]>

  export type BugReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    userId?: boolean
    status?: boolean
    type?: boolean
    errorHash?: boolean
    createdAt?: boolean
    user?: boolean | BugReport$userArgs<ExtArgs>
  }, ExtArgs["result"]["bugReport"]>

  export type BugReportSelectScalar = {
    id?: boolean
    description?: boolean
    userId?: boolean
    status?: boolean
    type?: boolean
    errorHash?: boolean
    createdAt?: boolean
  }

  export type BugReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "userId" | "status" | "type" | "errorHash" | "createdAt", ExtArgs["result"]["bugReport"]>
  export type BugReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BugReport$userArgs<ExtArgs>
  }
  export type BugReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BugReport$userArgs<ExtArgs>
  }
  export type BugReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BugReport$userArgs<ExtArgs>
  }

  export type $BugReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BugReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      userId: string | null
      status: string
      type: string
      errorHash: string | null
      createdAt: Date
    }, ExtArgs["result"]["bugReport"]>
    composites: {}
  }

  type BugReportGetPayload<S extends boolean | null | undefined | BugReportDefaultArgs> = $Result.GetResult<Prisma.$BugReportPayload, S>

  type BugReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BugReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BugReportCountAggregateInputType | true
    }

  export interface BugReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BugReport'], meta: { name: 'BugReport' } }
    /**
     * Find zero or one BugReport that matches the filter.
     * @param {BugReportFindUniqueArgs} args - Arguments to find a BugReport
     * @example
     * // Get one BugReport
     * const bugReport = await prisma.bugReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BugReportFindUniqueArgs>(args: SelectSubset<T, BugReportFindUniqueArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BugReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BugReportFindUniqueOrThrowArgs} args - Arguments to find a BugReport
     * @example
     * // Get one BugReport
     * const bugReport = await prisma.bugReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BugReportFindUniqueOrThrowArgs>(args: SelectSubset<T, BugReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BugReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportFindFirstArgs} args - Arguments to find a BugReport
     * @example
     * // Get one BugReport
     * const bugReport = await prisma.bugReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BugReportFindFirstArgs>(args?: SelectSubset<T, BugReportFindFirstArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BugReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportFindFirstOrThrowArgs} args - Arguments to find a BugReport
     * @example
     * // Get one BugReport
     * const bugReport = await prisma.bugReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BugReportFindFirstOrThrowArgs>(args?: SelectSubset<T, BugReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BugReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BugReports
     * const bugReports = await prisma.bugReport.findMany()
     * 
     * // Get first 10 BugReports
     * const bugReports = await prisma.bugReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bugReportWithIdOnly = await prisma.bugReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BugReportFindManyArgs>(args?: SelectSubset<T, BugReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BugReport.
     * @param {BugReportCreateArgs} args - Arguments to create a BugReport.
     * @example
     * // Create one BugReport
     * const BugReport = await prisma.bugReport.create({
     *   data: {
     *     // ... data to create a BugReport
     *   }
     * })
     * 
     */
    create<T extends BugReportCreateArgs>(args: SelectSubset<T, BugReportCreateArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BugReports.
     * @param {BugReportCreateManyArgs} args - Arguments to create many BugReports.
     * @example
     * // Create many BugReports
     * const bugReport = await prisma.bugReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BugReportCreateManyArgs>(args?: SelectSubset<T, BugReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BugReports and returns the data saved in the database.
     * @param {BugReportCreateManyAndReturnArgs} args - Arguments to create many BugReports.
     * @example
     * // Create many BugReports
     * const bugReport = await prisma.bugReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BugReports and only return the `id`
     * const bugReportWithIdOnly = await prisma.bugReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BugReportCreateManyAndReturnArgs>(args?: SelectSubset<T, BugReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BugReport.
     * @param {BugReportDeleteArgs} args - Arguments to delete one BugReport.
     * @example
     * // Delete one BugReport
     * const BugReport = await prisma.bugReport.delete({
     *   where: {
     *     // ... filter to delete one BugReport
     *   }
     * })
     * 
     */
    delete<T extends BugReportDeleteArgs>(args: SelectSubset<T, BugReportDeleteArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BugReport.
     * @param {BugReportUpdateArgs} args - Arguments to update one BugReport.
     * @example
     * // Update one BugReport
     * const bugReport = await prisma.bugReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BugReportUpdateArgs>(args: SelectSubset<T, BugReportUpdateArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BugReports.
     * @param {BugReportDeleteManyArgs} args - Arguments to filter BugReports to delete.
     * @example
     * // Delete a few BugReports
     * const { count } = await prisma.bugReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BugReportDeleteManyArgs>(args?: SelectSubset<T, BugReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BugReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BugReports
     * const bugReport = await prisma.bugReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BugReportUpdateManyArgs>(args: SelectSubset<T, BugReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BugReports and returns the data updated in the database.
     * @param {BugReportUpdateManyAndReturnArgs} args - Arguments to update many BugReports.
     * @example
     * // Update many BugReports
     * const bugReport = await prisma.bugReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BugReports and only return the `id`
     * const bugReportWithIdOnly = await prisma.bugReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BugReportUpdateManyAndReturnArgs>(args: SelectSubset<T, BugReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BugReport.
     * @param {BugReportUpsertArgs} args - Arguments to update or create a BugReport.
     * @example
     * // Update or create a BugReport
     * const bugReport = await prisma.bugReport.upsert({
     *   create: {
     *     // ... data to create a BugReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BugReport we want to update
     *   }
     * })
     */
    upsert<T extends BugReportUpsertArgs>(args: SelectSubset<T, BugReportUpsertArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BugReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportCountArgs} args - Arguments to filter BugReports to count.
     * @example
     * // Count the number of BugReports
     * const count = await prisma.bugReport.count({
     *   where: {
     *     // ... the filter for the BugReports we want to count
     *   }
     * })
    **/
    count<T extends BugReportCountArgs>(
      args?: Subset<T, BugReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BugReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BugReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BugReportAggregateArgs>(args: Subset<T, BugReportAggregateArgs>): Prisma.PrismaPromise<GetBugReportAggregateType<T>>

    /**
     * Group by BugReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BugReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BugReportGroupByArgs['orderBy'] }
        : { orderBy?: BugReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BugReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBugReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BugReport model
   */
  readonly fields: BugReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BugReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BugReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends BugReport$userArgs<ExtArgs> = {}>(args?: Subset<T, BugReport$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BugReport model
   */
  interface BugReportFieldRefs {
    readonly id: FieldRef<"BugReport", 'String'>
    readonly description: FieldRef<"BugReport", 'String'>
    readonly userId: FieldRef<"BugReport", 'String'>
    readonly status: FieldRef<"BugReport", 'String'>
    readonly type: FieldRef<"BugReport", 'String'>
    readonly errorHash: FieldRef<"BugReport", 'String'>
    readonly createdAt: FieldRef<"BugReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BugReport findUnique
   */
  export type BugReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter, which BugReport to fetch.
     */
    where: BugReportWhereUniqueInput
  }

  /**
   * BugReport findUniqueOrThrow
   */
  export type BugReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter, which BugReport to fetch.
     */
    where: BugReportWhereUniqueInput
  }

  /**
   * BugReport findFirst
   */
  export type BugReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter, which BugReport to fetch.
     */
    where?: BugReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportOrderByWithRelationInput | BugReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BugReports.
     */
    cursor?: BugReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BugReports.
     */
    distinct?: BugReportScalarFieldEnum | BugReportScalarFieldEnum[]
  }

  /**
   * BugReport findFirstOrThrow
   */
  export type BugReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter, which BugReport to fetch.
     */
    where?: BugReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportOrderByWithRelationInput | BugReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BugReports.
     */
    cursor?: BugReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BugReports.
     */
    distinct?: BugReportScalarFieldEnum | BugReportScalarFieldEnum[]
  }

  /**
   * BugReport findMany
   */
  export type BugReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter, which BugReports to fetch.
     */
    where?: BugReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportOrderByWithRelationInput | BugReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BugReports.
     */
    cursor?: BugReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    distinct?: BugReportScalarFieldEnum | BugReportScalarFieldEnum[]
  }

  /**
   * BugReport create
   */
  export type BugReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * The data needed to create a BugReport.
     */
    data: XOR<BugReportCreateInput, BugReportUncheckedCreateInput>
  }

  /**
   * BugReport createMany
   */
  export type BugReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BugReports.
     */
    data: BugReportCreateManyInput | BugReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BugReport createManyAndReturn
   */
  export type BugReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * The data used to create many BugReports.
     */
    data: BugReportCreateManyInput | BugReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BugReport update
   */
  export type BugReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * The data needed to update a BugReport.
     */
    data: XOR<BugReportUpdateInput, BugReportUncheckedUpdateInput>
    /**
     * Choose, which BugReport to update.
     */
    where: BugReportWhereUniqueInput
  }

  /**
   * BugReport updateMany
   */
  export type BugReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BugReports.
     */
    data: XOR<BugReportUpdateManyMutationInput, BugReportUncheckedUpdateManyInput>
    /**
     * Filter which BugReports to update
     */
    where?: BugReportWhereInput
    /**
     * Limit how many BugReports to update.
     */
    limit?: number
  }

  /**
   * BugReport updateManyAndReturn
   */
  export type BugReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * The data used to update BugReports.
     */
    data: XOR<BugReportUpdateManyMutationInput, BugReportUncheckedUpdateManyInput>
    /**
     * Filter which BugReports to update
     */
    where?: BugReportWhereInput
    /**
     * Limit how many BugReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BugReport upsert
   */
  export type BugReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * The filter to search for the BugReport to update in case it exists.
     */
    where: BugReportWhereUniqueInput
    /**
     * In case the BugReport found by the `where` argument doesn't exist, create a new BugReport with this data.
     */
    create: XOR<BugReportCreateInput, BugReportUncheckedCreateInput>
    /**
     * In case the BugReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BugReportUpdateInput, BugReportUncheckedUpdateInput>
  }

  /**
   * BugReport delete
   */
  export type BugReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter which BugReport to delete.
     */
    where: BugReportWhereUniqueInput
  }

  /**
   * BugReport deleteMany
   */
  export type BugReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BugReports to delete
     */
    where?: BugReportWhereInput
    /**
     * Limit how many BugReports to delete.
     */
    limit?: number
  }

  /**
   * BugReport.user
   */
  export type BugReport$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BugReport without action
   */
  export type BugReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
  }


  /**
   * Model Resident
   */

  export type AggregateResident = {
    _count: ResidentCountAggregateOutputType | null
    _min: ResidentMinAggregateOutputType | null
    _max: ResidentMaxAggregateOutputType | null
  }

  export type ResidentMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    roomNumber: string | null
    status: string | null
    allergies: string | null
    conditions: string | null
    carePlanSummary: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResidentMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    roomNumber: string | null
    status: string | null
    allergies: string | null
    conditions: string | null
    carePlanSummary: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResidentCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    dateOfBirth: number
    roomNumber: number
    status: number
    emergencyContact: number
    allergies: number
    conditions: number
    carePlanSummary: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResidentMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    roomNumber?: true
    status?: true
    allergies?: true
    conditions?: true
    carePlanSummary?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResidentMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    roomNumber?: true
    status?: true
    allergies?: true
    conditions?: true
    carePlanSummary?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResidentCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    roomNumber?: true
    status?: true
    emergencyContact?: true
    allergies?: true
    conditions?: true
    carePlanSummary?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resident to aggregate.
     */
    where?: ResidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residents to fetch.
     */
    orderBy?: ResidentOrderByWithRelationInput | ResidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Residents
    **/
    _count?: true | ResidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResidentMaxAggregateInputType
  }

  export type GetResidentAggregateType<T extends ResidentAggregateArgs> = {
        [P in keyof T & keyof AggregateResident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResident[P]>
      : GetScalarType<T[P], AggregateResident[P]>
  }




  export type ResidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResidentWhereInput
    orderBy?: ResidentOrderByWithAggregationInput | ResidentOrderByWithAggregationInput[]
    by: ResidentScalarFieldEnum[] | ResidentScalarFieldEnum
    having?: ResidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResidentCountAggregateInputType | true
    _min?: ResidentMinAggregateInputType
    _max?: ResidentMaxAggregateInputType
  }

  export type ResidentGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    dateOfBirth: Date
    roomNumber: string | null
    status: string
    emergencyContact: JsonValue | null
    allergies: string | null
    conditions: string | null
    carePlanSummary: string | null
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ResidentCountAggregateOutputType | null
    _min: ResidentMinAggregateOutputType | null
    _max: ResidentMaxAggregateOutputType | null
  }

  type GetResidentGroupByPayload<T extends ResidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResidentGroupByOutputType[P]>
            : GetScalarType<T[P], ResidentGroupByOutputType[P]>
        }
      >
    >


  export type ResidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    roomNumber?: boolean
    status?: boolean
    emergencyContact?: boolean
    allergies?: boolean
    conditions?: boolean
    carePlanSummary?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Resident$userArgs<ExtArgs>
    medications?: boolean | Resident$medicationsArgs<ExtArgs>
    vitalSigns?: boolean | Resident$vitalSignsArgs<ExtArgs>
    nursingNotes?: boolean | Resident$nursingNotesArgs<ExtArgs>
    _count?: boolean | ResidentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resident"]>

  export type ResidentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    roomNumber?: boolean
    status?: boolean
    emergencyContact?: boolean
    allergies?: boolean
    conditions?: boolean
    carePlanSummary?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Resident$userArgs<ExtArgs>
  }, ExtArgs["result"]["resident"]>

  export type ResidentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    roomNumber?: boolean
    status?: boolean
    emergencyContact?: boolean
    allergies?: boolean
    conditions?: boolean
    carePlanSummary?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Resident$userArgs<ExtArgs>
  }, ExtArgs["result"]["resident"]>

  export type ResidentSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    roomNumber?: boolean
    status?: boolean
    emergencyContact?: boolean
    allergies?: boolean
    conditions?: boolean
    carePlanSummary?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResidentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "dateOfBirth" | "roomNumber" | "status" | "emergencyContact" | "allergies" | "conditions" | "carePlanSummary" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["resident"]>
  export type ResidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Resident$userArgs<ExtArgs>
    medications?: boolean | Resident$medicationsArgs<ExtArgs>
    vitalSigns?: boolean | Resident$vitalSignsArgs<ExtArgs>
    nursingNotes?: boolean | Resident$nursingNotesArgs<ExtArgs>
    _count?: boolean | ResidentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResidentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Resident$userArgs<ExtArgs>
  }
  export type ResidentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Resident$userArgs<ExtArgs>
  }

  export type $ResidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resident"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      medications: Prisma.$MedicationOrderPayload<ExtArgs>[]
      vitalSigns: Prisma.$VitalSignPayload<ExtArgs>[]
      nursingNotes: Prisma.$NursingNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      dateOfBirth: Date
      roomNumber: string | null
      status: string
      emergencyContact: Prisma.JsonValue | null
      allergies: string | null
      conditions: string | null
      carePlanSummary: string | null
      userId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resident"]>
    composites: {}
  }

  type ResidentGetPayload<S extends boolean | null | undefined | ResidentDefaultArgs> = $Result.GetResult<Prisma.$ResidentPayload, S>

  type ResidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResidentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResidentCountAggregateInputType | true
    }

  export interface ResidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resident'], meta: { name: 'Resident' } }
    /**
     * Find zero or one Resident that matches the filter.
     * @param {ResidentFindUniqueArgs} args - Arguments to find a Resident
     * @example
     * // Get one Resident
     * const resident = await prisma.resident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResidentFindUniqueArgs>(args: SelectSubset<T, ResidentFindUniqueArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resident that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResidentFindUniqueOrThrowArgs} args - Arguments to find a Resident
     * @example
     * // Get one Resident
     * const resident = await prisma.resident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResidentFindUniqueOrThrowArgs>(args: SelectSubset<T, ResidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentFindFirstArgs} args - Arguments to find a Resident
     * @example
     * // Get one Resident
     * const resident = await prisma.resident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResidentFindFirstArgs>(args?: SelectSubset<T, ResidentFindFirstArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentFindFirstOrThrowArgs} args - Arguments to find a Resident
     * @example
     * // Get one Resident
     * const resident = await prisma.resident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResidentFindFirstOrThrowArgs>(args?: SelectSubset<T, ResidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Residents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Residents
     * const residents = await prisma.resident.findMany()
     * 
     * // Get first 10 Residents
     * const residents = await prisma.resident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const residentWithIdOnly = await prisma.resident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResidentFindManyArgs>(args?: SelectSubset<T, ResidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resident.
     * @param {ResidentCreateArgs} args - Arguments to create a Resident.
     * @example
     * // Create one Resident
     * const Resident = await prisma.resident.create({
     *   data: {
     *     // ... data to create a Resident
     *   }
     * })
     * 
     */
    create<T extends ResidentCreateArgs>(args: SelectSubset<T, ResidentCreateArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Residents.
     * @param {ResidentCreateManyArgs} args - Arguments to create many Residents.
     * @example
     * // Create many Residents
     * const resident = await prisma.resident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResidentCreateManyArgs>(args?: SelectSubset<T, ResidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Residents and returns the data saved in the database.
     * @param {ResidentCreateManyAndReturnArgs} args - Arguments to create many Residents.
     * @example
     * // Create many Residents
     * const resident = await prisma.resident.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Residents and only return the `id`
     * const residentWithIdOnly = await prisma.resident.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResidentCreateManyAndReturnArgs>(args?: SelectSubset<T, ResidentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resident.
     * @param {ResidentDeleteArgs} args - Arguments to delete one Resident.
     * @example
     * // Delete one Resident
     * const Resident = await prisma.resident.delete({
     *   where: {
     *     // ... filter to delete one Resident
     *   }
     * })
     * 
     */
    delete<T extends ResidentDeleteArgs>(args: SelectSubset<T, ResidentDeleteArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resident.
     * @param {ResidentUpdateArgs} args - Arguments to update one Resident.
     * @example
     * // Update one Resident
     * const resident = await prisma.resident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResidentUpdateArgs>(args: SelectSubset<T, ResidentUpdateArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Residents.
     * @param {ResidentDeleteManyArgs} args - Arguments to filter Residents to delete.
     * @example
     * // Delete a few Residents
     * const { count } = await prisma.resident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResidentDeleteManyArgs>(args?: SelectSubset<T, ResidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Residents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Residents
     * const resident = await prisma.resident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResidentUpdateManyArgs>(args: SelectSubset<T, ResidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Residents and returns the data updated in the database.
     * @param {ResidentUpdateManyAndReturnArgs} args - Arguments to update many Residents.
     * @example
     * // Update many Residents
     * const resident = await prisma.resident.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Residents and only return the `id`
     * const residentWithIdOnly = await prisma.resident.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResidentUpdateManyAndReturnArgs>(args: SelectSubset<T, ResidentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resident.
     * @param {ResidentUpsertArgs} args - Arguments to update or create a Resident.
     * @example
     * // Update or create a Resident
     * const resident = await prisma.resident.upsert({
     *   create: {
     *     // ... data to create a Resident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resident we want to update
     *   }
     * })
     */
    upsert<T extends ResidentUpsertArgs>(args: SelectSubset<T, ResidentUpsertArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Residents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentCountArgs} args - Arguments to filter Residents to count.
     * @example
     * // Count the number of Residents
     * const count = await prisma.resident.count({
     *   where: {
     *     // ... the filter for the Residents we want to count
     *   }
     * })
    **/
    count<T extends ResidentCountArgs>(
      args?: Subset<T, ResidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResidentAggregateArgs>(args: Subset<T, ResidentAggregateArgs>): Prisma.PrismaPromise<GetResidentAggregateType<T>>

    /**
     * Group by Resident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResidentGroupByArgs['orderBy'] }
        : { orderBy?: ResidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resident model
   */
  readonly fields: ResidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Resident$userArgs<ExtArgs> = {}>(args?: Subset<T, Resident$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    medications<T extends Resident$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, Resident$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vitalSigns<T extends Resident$vitalSignsArgs<ExtArgs> = {}>(args?: Subset<T, Resident$vitalSignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nursingNotes<T extends Resident$nursingNotesArgs<ExtArgs> = {}>(args?: Subset<T, Resident$nursingNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resident model
   */
  interface ResidentFieldRefs {
    readonly id: FieldRef<"Resident", 'String'>
    readonly firstName: FieldRef<"Resident", 'String'>
    readonly lastName: FieldRef<"Resident", 'String'>
    readonly dateOfBirth: FieldRef<"Resident", 'DateTime'>
    readonly roomNumber: FieldRef<"Resident", 'String'>
    readonly status: FieldRef<"Resident", 'String'>
    readonly emergencyContact: FieldRef<"Resident", 'Json'>
    readonly allergies: FieldRef<"Resident", 'String'>
    readonly conditions: FieldRef<"Resident", 'String'>
    readonly carePlanSummary: FieldRef<"Resident", 'String'>
    readonly userId: FieldRef<"Resident", 'String'>
    readonly createdAt: FieldRef<"Resident", 'DateTime'>
    readonly updatedAt: FieldRef<"Resident", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resident findUnique
   */
  export type ResidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
    /**
     * Filter, which Resident to fetch.
     */
    where: ResidentWhereUniqueInput
  }

  /**
   * Resident findUniqueOrThrow
   */
  export type ResidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
    /**
     * Filter, which Resident to fetch.
     */
    where: ResidentWhereUniqueInput
  }

  /**
   * Resident findFirst
   */
  export type ResidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
    /**
     * Filter, which Resident to fetch.
     */
    where?: ResidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residents to fetch.
     */
    orderBy?: ResidentOrderByWithRelationInput | ResidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Residents.
     */
    cursor?: ResidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Residents.
     */
    distinct?: ResidentScalarFieldEnum | ResidentScalarFieldEnum[]
  }

  /**
   * Resident findFirstOrThrow
   */
  export type ResidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
    /**
     * Filter, which Resident to fetch.
     */
    where?: ResidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residents to fetch.
     */
    orderBy?: ResidentOrderByWithRelationInput | ResidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Residents.
     */
    cursor?: ResidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Residents.
     */
    distinct?: ResidentScalarFieldEnum | ResidentScalarFieldEnum[]
  }

  /**
   * Resident findMany
   */
  export type ResidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
    /**
     * Filter, which Residents to fetch.
     */
    where?: ResidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residents to fetch.
     */
    orderBy?: ResidentOrderByWithRelationInput | ResidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Residents.
     */
    cursor?: ResidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residents.
     */
    skip?: number
    distinct?: ResidentScalarFieldEnum | ResidentScalarFieldEnum[]
  }

  /**
   * Resident create
   */
  export type ResidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Resident.
     */
    data: XOR<ResidentCreateInput, ResidentUncheckedCreateInput>
  }

  /**
   * Resident createMany
   */
  export type ResidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Residents.
     */
    data: ResidentCreateManyInput | ResidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resident createManyAndReturn
   */
  export type ResidentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * The data used to create many Residents.
     */
    data: ResidentCreateManyInput | ResidentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resident update
   */
  export type ResidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Resident.
     */
    data: XOR<ResidentUpdateInput, ResidentUncheckedUpdateInput>
    /**
     * Choose, which Resident to update.
     */
    where: ResidentWhereUniqueInput
  }

  /**
   * Resident updateMany
   */
  export type ResidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Residents.
     */
    data: XOR<ResidentUpdateManyMutationInput, ResidentUncheckedUpdateManyInput>
    /**
     * Filter which Residents to update
     */
    where?: ResidentWhereInput
    /**
     * Limit how many Residents to update.
     */
    limit?: number
  }

  /**
   * Resident updateManyAndReturn
   */
  export type ResidentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * The data used to update Residents.
     */
    data: XOR<ResidentUpdateManyMutationInput, ResidentUncheckedUpdateManyInput>
    /**
     * Filter which Residents to update
     */
    where?: ResidentWhereInput
    /**
     * Limit how many Residents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resident upsert
   */
  export type ResidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Resident to update in case it exists.
     */
    where: ResidentWhereUniqueInput
    /**
     * In case the Resident found by the `where` argument doesn't exist, create a new Resident with this data.
     */
    create: XOR<ResidentCreateInput, ResidentUncheckedCreateInput>
    /**
     * In case the Resident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResidentUpdateInput, ResidentUncheckedUpdateInput>
  }

  /**
   * Resident delete
   */
  export type ResidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
    /**
     * Filter which Resident to delete.
     */
    where: ResidentWhereUniqueInput
  }

  /**
   * Resident deleteMany
   */
  export type ResidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Residents to delete
     */
    where?: ResidentWhereInput
    /**
     * Limit how many Residents to delete.
     */
    limit?: number
  }

  /**
   * Resident.user
   */
  export type Resident$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Resident.medications
   */
  export type Resident$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
    where?: MedicationOrderWhereInput
    orderBy?: MedicationOrderOrderByWithRelationInput | MedicationOrderOrderByWithRelationInput[]
    cursor?: MedicationOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationOrderScalarFieldEnum | MedicationOrderScalarFieldEnum[]
  }

  /**
   * Resident.vitalSigns
   */
  export type Resident$vitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    where?: VitalSignWhereInput
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    cursor?: VitalSignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * Resident.nursingNotes
   */
  export type Resident$nursingNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    where?: NursingNoteWhereInput
    orderBy?: NursingNoteOrderByWithRelationInput | NursingNoteOrderByWithRelationInput[]
    cursor?: NursingNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NursingNoteScalarFieldEnum | NursingNoteScalarFieldEnum[]
  }

  /**
   * Resident without action
   */
  export type ResidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resident
     */
    select?: ResidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resident
     */
    omit?: ResidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentInclude<ExtArgs> | null
  }


  /**
   * Model MedicationOrder
   */

  export type AggregateMedicationOrder = {
    _count: MedicationOrderCountAggregateOutputType | null
    _min: MedicationOrderMinAggregateOutputType | null
    _max: MedicationOrderMaxAggregateOutputType | null
  }

  export type MedicationOrderMinAggregateOutputType = {
    id: string | null
    residentId: string | null
    medicationName: string | null
    dosage: string | null
    frequency: string | null
    route: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    instructions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationOrderMaxAggregateOutputType = {
    id: string | null
    residentId: string | null
    medicationName: string | null
    dosage: string | null
    frequency: string | null
    route: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    instructions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationOrderCountAggregateOutputType = {
    id: number
    residentId: number
    medicationName: number
    dosage: number
    frequency: number
    route: number
    startDate: number
    endDate: number
    isActive: number
    instructions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicationOrderMinAggregateInputType = {
    id?: true
    residentId?: true
    medicationName?: true
    dosage?: true
    frequency?: true
    route?: true
    startDate?: true
    endDate?: true
    isActive?: true
    instructions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationOrderMaxAggregateInputType = {
    id?: true
    residentId?: true
    medicationName?: true
    dosage?: true
    frequency?: true
    route?: true
    startDate?: true
    endDate?: true
    isActive?: true
    instructions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationOrderCountAggregateInputType = {
    id?: true
    residentId?: true
    medicationName?: true
    dosage?: true
    frequency?: true
    route?: true
    startDate?: true
    endDate?: true
    isActive?: true
    instructions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicationOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicationOrder to aggregate.
     */
    where?: MedicationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationOrders to fetch.
     */
    orderBy?: MedicationOrderOrderByWithRelationInput | MedicationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicationOrders
    **/
    _count?: true | MedicationOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationOrderMaxAggregateInputType
  }

  export type GetMedicationOrderAggregateType<T extends MedicationOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicationOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicationOrder[P]>
      : GetScalarType<T[P], AggregateMedicationOrder[P]>
  }




  export type MedicationOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationOrderWhereInput
    orderBy?: MedicationOrderOrderByWithAggregationInput | MedicationOrderOrderByWithAggregationInput[]
    by: MedicationOrderScalarFieldEnum[] | MedicationOrderScalarFieldEnum
    having?: MedicationOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationOrderCountAggregateInputType | true
    _min?: MedicationOrderMinAggregateInputType
    _max?: MedicationOrderMaxAggregateInputType
  }

  export type MedicationOrderGroupByOutputType = {
    id: string
    residentId: string
    medicationName: string
    dosage: string
    frequency: string
    route: string
    startDate: Date
    endDate: Date | null
    isActive: boolean
    instructions: string | null
    createdAt: Date
    updatedAt: Date
    _count: MedicationOrderCountAggregateOutputType | null
    _min: MedicationOrderMinAggregateOutputType | null
    _max: MedicationOrderMaxAggregateOutputType | null
  }

  type GetMedicationOrderGroupByPayload<T extends MedicationOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationOrderGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationOrderGroupByOutputType[P]>
        }
      >
    >


  export type MedicationOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    medicationName?: boolean
    dosage?: boolean
    frequency?: boolean
    route?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    logs?: boolean | MedicationOrder$logsArgs<ExtArgs>
    _count?: boolean | MedicationOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationOrder"]>

  export type MedicationOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    medicationName?: boolean
    dosage?: boolean
    frequency?: boolean
    route?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationOrder"]>

  export type MedicationOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    medicationName?: boolean
    dosage?: boolean
    frequency?: boolean
    route?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationOrder"]>

  export type MedicationOrderSelectScalar = {
    id?: boolean
    residentId?: boolean
    medicationName?: boolean
    dosage?: boolean
    frequency?: boolean
    route?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicationOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "residentId" | "medicationName" | "dosage" | "frequency" | "route" | "startDate" | "endDate" | "isActive" | "instructions" | "createdAt" | "updatedAt", ExtArgs["result"]["medicationOrder"]>
  export type MedicationOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    logs?: boolean | MedicationOrder$logsArgs<ExtArgs>
    _count?: boolean | MedicationOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicationOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
  }
  export type MedicationOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
  }

  export type $MedicationOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicationOrder"
    objects: {
      resident: Prisma.$ResidentPayload<ExtArgs>
      logs: Prisma.$MedicationLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      residentId: string
      medicationName: string
      dosage: string
      frequency: string
      route: string
      startDate: Date
      endDate: Date | null
      isActive: boolean
      instructions: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicationOrder"]>
    composites: {}
  }

  type MedicationOrderGetPayload<S extends boolean | null | undefined | MedicationOrderDefaultArgs> = $Result.GetResult<Prisma.$MedicationOrderPayload, S>

  type MedicationOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicationOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicationOrderCountAggregateInputType | true
    }

  export interface MedicationOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicationOrder'], meta: { name: 'MedicationOrder' } }
    /**
     * Find zero or one MedicationOrder that matches the filter.
     * @param {MedicationOrderFindUniqueArgs} args - Arguments to find a MedicationOrder
     * @example
     * // Get one MedicationOrder
     * const medicationOrder = await prisma.medicationOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationOrderFindUniqueArgs>(args: SelectSubset<T, MedicationOrderFindUniqueArgs<ExtArgs>>): Prisma__MedicationOrderClient<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicationOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicationOrderFindUniqueOrThrowArgs} args - Arguments to find a MedicationOrder
     * @example
     * // Get one MedicationOrder
     * const medicationOrder = await prisma.medicationOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationOrderClient<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicationOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationOrderFindFirstArgs} args - Arguments to find a MedicationOrder
     * @example
     * // Get one MedicationOrder
     * const medicationOrder = await prisma.medicationOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationOrderFindFirstArgs>(args?: SelectSubset<T, MedicationOrderFindFirstArgs<ExtArgs>>): Prisma__MedicationOrderClient<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicationOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationOrderFindFirstOrThrowArgs} args - Arguments to find a MedicationOrder
     * @example
     * // Get one MedicationOrder
     * const medicationOrder = await prisma.medicationOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationOrderClient<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicationOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicationOrders
     * const medicationOrders = await prisma.medicationOrder.findMany()
     * 
     * // Get first 10 MedicationOrders
     * const medicationOrders = await prisma.medicationOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationOrderWithIdOnly = await prisma.medicationOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationOrderFindManyArgs>(args?: SelectSubset<T, MedicationOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicationOrder.
     * @param {MedicationOrderCreateArgs} args - Arguments to create a MedicationOrder.
     * @example
     * // Create one MedicationOrder
     * const MedicationOrder = await prisma.medicationOrder.create({
     *   data: {
     *     // ... data to create a MedicationOrder
     *   }
     * })
     * 
     */
    create<T extends MedicationOrderCreateArgs>(args: SelectSubset<T, MedicationOrderCreateArgs<ExtArgs>>): Prisma__MedicationOrderClient<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicationOrders.
     * @param {MedicationOrderCreateManyArgs} args - Arguments to create many MedicationOrders.
     * @example
     * // Create many MedicationOrders
     * const medicationOrder = await prisma.medicationOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationOrderCreateManyArgs>(args?: SelectSubset<T, MedicationOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicationOrders and returns the data saved in the database.
     * @param {MedicationOrderCreateManyAndReturnArgs} args - Arguments to create many MedicationOrders.
     * @example
     * // Create many MedicationOrders
     * const medicationOrder = await prisma.medicationOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicationOrders and only return the `id`
     * const medicationOrderWithIdOnly = await prisma.medicationOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicationOrder.
     * @param {MedicationOrderDeleteArgs} args - Arguments to delete one MedicationOrder.
     * @example
     * // Delete one MedicationOrder
     * const MedicationOrder = await prisma.medicationOrder.delete({
     *   where: {
     *     // ... filter to delete one MedicationOrder
     *   }
     * })
     * 
     */
    delete<T extends MedicationOrderDeleteArgs>(args: SelectSubset<T, MedicationOrderDeleteArgs<ExtArgs>>): Prisma__MedicationOrderClient<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicationOrder.
     * @param {MedicationOrderUpdateArgs} args - Arguments to update one MedicationOrder.
     * @example
     * // Update one MedicationOrder
     * const medicationOrder = await prisma.medicationOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationOrderUpdateArgs>(args: SelectSubset<T, MedicationOrderUpdateArgs<ExtArgs>>): Prisma__MedicationOrderClient<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicationOrders.
     * @param {MedicationOrderDeleteManyArgs} args - Arguments to filter MedicationOrders to delete.
     * @example
     * // Delete a few MedicationOrders
     * const { count } = await prisma.medicationOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationOrderDeleteManyArgs>(args?: SelectSubset<T, MedicationOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicationOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicationOrders
     * const medicationOrder = await prisma.medicationOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationOrderUpdateManyArgs>(args: SelectSubset<T, MedicationOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicationOrders and returns the data updated in the database.
     * @param {MedicationOrderUpdateManyAndReturnArgs} args - Arguments to update many MedicationOrders.
     * @example
     * // Update many MedicationOrders
     * const medicationOrder = await prisma.medicationOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicationOrders and only return the `id`
     * const medicationOrderWithIdOnly = await prisma.medicationOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicationOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicationOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicationOrder.
     * @param {MedicationOrderUpsertArgs} args - Arguments to update or create a MedicationOrder.
     * @example
     * // Update or create a MedicationOrder
     * const medicationOrder = await prisma.medicationOrder.upsert({
     *   create: {
     *     // ... data to create a MedicationOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicationOrder we want to update
     *   }
     * })
     */
    upsert<T extends MedicationOrderUpsertArgs>(args: SelectSubset<T, MedicationOrderUpsertArgs<ExtArgs>>): Prisma__MedicationOrderClient<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicationOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationOrderCountArgs} args - Arguments to filter MedicationOrders to count.
     * @example
     * // Count the number of MedicationOrders
     * const count = await prisma.medicationOrder.count({
     *   where: {
     *     // ... the filter for the MedicationOrders we want to count
     *   }
     * })
    **/
    count<T extends MedicationOrderCountArgs>(
      args?: Subset<T, MedicationOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicationOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationOrderAggregateArgs>(args: Subset<T, MedicationOrderAggregateArgs>): Prisma.PrismaPromise<GetMedicationOrderAggregateType<T>>

    /**
     * Group by MedicationOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationOrderGroupByArgs['orderBy'] }
        : { orderBy?: MedicationOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicationOrder model
   */
  readonly fields: MedicationOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicationOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resident<T extends ResidentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResidentDefaultArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    logs<T extends MedicationOrder$logsArgs<ExtArgs> = {}>(args?: Subset<T, MedicationOrder$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicationOrder model
   */
  interface MedicationOrderFieldRefs {
    readonly id: FieldRef<"MedicationOrder", 'String'>
    readonly residentId: FieldRef<"MedicationOrder", 'String'>
    readonly medicationName: FieldRef<"MedicationOrder", 'String'>
    readonly dosage: FieldRef<"MedicationOrder", 'String'>
    readonly frequency: FieldRef<"MedicationOrder", 'String'>
    readonly route: FieldRef<"MedicationOrder", 'String'>
    readonly startDate: FieldRef<"MedicationOrder", 'DateTime'>
    readonly endDate: FieldRef<"MedicationOrder", 'DateTime'>
    readonly isActive: FieldRef<"MedicationOrder", 'Boolean'>
    readonly instructions: FieldRef<"MedicationOrder", 'String'>
    readonly createdAt: FieldRef<"MedicationOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicationOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicationOrder findUnique
   */
  export type MedicationOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
    /**
     * Filter, which MedicationOrder to fetch.
     */
    where: MedicationOrderWhereUniqueInput
  }

  /**
   * MedicationOrder findUniqueOrThrow
   */
  export type MedicationOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
    /**
     * Filter, which MedicationOrder to fetch.
     */
    where: MedicationOrderWhereUniqueInput
  }

  /**
   * MedicationOrder findFirst
   */
  export type MedicationOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
    /**
     * Filter, which MedicationOrder to fetch.
     */
    where?: MedicationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationOrders to fetch.
     */
    orderBy?: MedicationOrderOrderByWithRelationInput | MedicationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicationOrders.
     */
    cursor?: MedicationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicationOrders.
     */
    distinct?: MedicationOrderScalarFieldEnum | MedicationOrderScalarFieldEnum[]
  }

  /**
   * MedicationOrder findFirstOrThrow
   */
  export type MedicationOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
    /**
     * Filter, which MedicationOrder to fetch.
     */
    where?: MedicationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationOrders to fetch.
     */
    orderBy?: MedicationOrderOrderByWithRelationInput | MedicationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicationOrders.
     */
    cursor?: MedicationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicationOrders.
     */
    distinct?: MedicationOrderScalarFieldEnum | MedicationOrderScalarFieldEnum[]
  }

  /**
   * MedicationOrder findMany
   */
  export type MedicationOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
    /**
     * Filter, which MedicationOrders to fetch.
     */
    where?: MedicationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationOrders to fetch.
     */
    orderBy?: MedicationOrderOrderByWithRelationInput | MedicationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicationOrders.
     */
    cursor?: MedicationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationOrders.
     */
    skip?: number
    distinct?: MedicationOrderScalarFieldEnum | MedicationOrderScalarFieldEnum[]
  }

  /**
   * MedicationOrder create
   */
  export type MedicationOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicationOrder.
     */
    data: XOR<MedicationOrderCreateInput, MedicationOrderUncheckedCreateInput>
  }

  /**
   * MedicationOrder createMany
   */
  export type MedicationOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicationOrders.
     */
    data: MedicationOrderCreateManyInput | MedicationOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicationOrder createManyAndReturn
   */
  export type MedicationOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * The data used to create many MedicationOrders.
     */
    data: MedicationOrderCreateManyInput | MedicationOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicationOrder update
   */
  export type MedicationOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicationOrder.
     */
    data: XOR<MedicationOrderUpdateInput, MedicationOrderUncheckedUpdateInput>
    /**
     * Choose, which MedicationOrder to update.
     */
    where: MedicationOrderWhereUniqueInput
  }

  /**
   * MedicationOrder updateMany
   */
  export type MedicationOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicationOrders.
     */
    data: XOR<MedicationOrderUpdateManyMutationInput, MedicationOrderUncheckedUpdateManyInput>
    /**
     * Filter which MedicationOrders to update
     */
    where?: MedicationOrderWhereInput
    /**
     * Limit how many MedicationOrders to update.
     */
    limit?: number
  }

  /**
   * MedicationOrder updateManyAndReturn
   */
  export type MedicationOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * The data used to update MedicationOrders.
     */
    data: XOR<MedicationOrderUpdateManyMutationInput, MedicationOrderUncheckedUpdateManyInput>
    /**
     * Filter which MedicationOrders to update
     */
    where?: MedicationOrderWhereInput
    /**
     * Limit how many MedicationOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicationOrder upsert
   */
  export type MedicationOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicationOrder to update in case it exists.
     */
    where: MedicationOrderWhereUniqueInput
    /**
     * In case the MedicationOrder found by the `where` argument doesn't exist, create a new MedicationOrder with this data.
     */
    create: XOR<MedicationOrderCreateInput, MedicationOrderUncheckedCreateInput>
    /**
     * In case the MedicationOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationOrderUpdateInput, MedicationOrderUncheckedUpdateInput>
  }

  /**
   * MedicationOrder delete
   */
  export type MedicationOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
    /**
     * Filter which MedicationOrder to delete.
     */
    where: MedicationOrderWhereUniqueInput
  }

  /**
   * MedicationOrder deleteMany
   */
  export type MedicationOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicationOrders to delete
     */
    where?: MedicationOrderWhereInput
    /**
     * Limit how many MedicationOrders to delete.
     */
    limit?: number
  }

  /**
   * MedicationOrder.logs
   */
  export type MedicationOrder$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    where?: MedicationLogWhereInput
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    cursor?: MedicationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationLogScalarFieldEnum | MedicationLogScalarFieldEnum[]
  }

  /**
   * MedicationOrder without action
   */
  export type MedicationOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationOrder
     */
    select?: MedicationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationOrder
     */
    omit?: MedicationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationOrderInclude<ExtArgs> | null
  }


  /**
   * Model MedicationLog
   */

  export type AggregateMedicationLog = {
    _count: MedicationLogCountAggregateOutputType | null
    _min: MedicationLogMinAggregateOutputType | null
    _max: MedicationLogMaxAggregateOutputType | null
  }

  export type MedicationLogMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    administeredBy: string | null
    administeredAt: Date | null
    status: string | null
    notes: string | null
    shift: string | null
  }

  export type MedicationLogMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    administeredBy: string | null
    administeredAt: Date | null
    status: string | null
    notes: string | null
    shift: string | null
  }

  export type MedicationLogCountAggregateOutputType = {
    id: number
    orderId: number
    administeredBy: number
    administeredAt: number
    status: number
    notes: number
    shift: number
    _all: number
  }


  export type MedicationLogMinAggregateInputType = {
    id?: true
    orderId?: true
    administeredBy?: true
    administeredAt?: true
    status?: true
    notes?: true
    shift?: true
  }

  export type MedicationLogMaxAggregateInputType = {
    id?: true
    orderId?: true
    administeredBy?: true
    administeredAt?: true
    status?: true
    notes?: true
    shift?: true
  }

  export type MedicationLogCountAggregateInputType = {
    id?: true
    orderId?: true
    administeredBy?: true
    administeredAt?: true
    status?: true
    notes?: true
    shift?: true
    _all?: true
  }

  export type MedicationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicationLog to aggregate.
     */
    where?: MedicationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationLogs to fetch.
     */
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicationLogs
    **/
    _count?: true | MedicationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationLogMaxAggregateInputType
  }

  export type GetMedicationLogAggregateType<T extends MedicationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicationLog[P]>
      : GetScalarType<T[P], AggregateMedicationLog[P]>
  }




  export type MedicationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationLogWhereInput
    orderBy?: MedicationLogOrderByWithAggregationInput | MedicationLogOrderByWithAggregationInput[]
    by: MedicationLogScalarFieldEnum[] | MedicationLogScalarFieldEnum
    having?: MedicationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationLogCountAggregateInputType | true
    _min?: MedicationLogMinAggregateInputType
    _max?: MedicationLogMaxAggregateInputType
  }

  export type MedicationLogGroupByOutputType = {
    id: string
    orderId: string
    administeredBy: string
    administeredAt: Date
    status: string
    notes: string | null
    shift: string | null
    _count: MedicationLogCountAggregateOutputType | null
    _min: MedicationLogMinAggregateOutputType | null
    _max: MedicationLogMaxAggregateOutputType | null
  }

  type GetMedicationLogGroupByPayload<T extends MedicationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationLogGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationLogGroupByOutputType[P]>
        }
      >
    >


  export type MedicationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    administeredBy?: boolean
    administeredAt?: boolean
    status?: boolean
    notes?: boolean
    shift?: boolean
    order?: boolean | MedicationOrderDefaultArgs<ExtArgs>
    administrator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationLog"]>

  export type MedicationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    administeredBy?: boolean
    administeredAt?: boolean
    status?: boolean
    notes?: boolean
    shift?: boolean
    order?: boolean | MedicationOrderDefaultArgs<ExtArgs>
    administrator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationLog"]>

  export type MedicationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    administeredBy?: boolean
    administeredAt?: boolean
    status?: boolean
    notes?: boolean
    shift?: boolean
    order?: boolean | MedicationOrderDefaultArgs<ExtArgs>
    administrator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationLog"]>

  export type MedicationLogSelectScalar = {
    id?: boolean
    orderId?: boolean
    administeredBy?: boolean
    administeredAt?: boolean
    status?: boolean
    notes?: boolean
    shift?: boolean
  }

  export type MedicationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "administeredBy" | "administeredAt" | "status" | "notes" | "shift", ExtArgs["result"]["medicationLog"]>
  export type MedicationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | MedicationOrderDefaultArgs<ExtArgs>
    administrator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MedicationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | MedicationOrderDefaultArgs<ExtArgs>
    administrator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MedicationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | MedicationOrderDefaultArgs<ExtArgs>
    administrator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MedicationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicationLog"
    objects: {
      order: Prisma.$MedicationOrderPayload<ExtArgs>
      administrator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      administeredBy: string
      administeredAt: Date
      status: string
      notes: string | null
      shift: string | null
    }, ExtArgs["result"]["medicationLog"]>
    composites: {}
  }

  type MedicationLogGetPayload<S extends boolean | null | undefined | MedicationLogDefaultArgs> = $Result.GetResult<Prisma.$MedicationLogPayload, S>

  type MedicationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicationLogCountAggregateInputType | true
    }

  export interface MedicationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicationLog'], meta: { name: 'MedicationLog' } }
    /**
     * Find zero or one MedicationLog that matches the filter.
     * @param {MedicationLogFindUniqueArgs} args - Arguments to find a MedicationLog
     * @example
     * // Get one MedicationLog
     * const medicationLog = await prisma.medicationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationLogFindUniqueArgs>(args: SelectSubset<T, MedicationLogFindUniqueArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicationLogFindUniqueOrThrowArgs} args - Arguments to find a MedicationLog
     * @example
     * // Get one MedicationLog
     * const medicationLog = await prisma.medicationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogFindFirstArgs} args - Arguments to find a MedicationLog
     * @example
     * // Get one MedicationLog
     * const medicationLog = await prisma.medicationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationLogFindFirstArgs>(args?: SelectSubset<T, MedicationLogFindFirstArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogFindFirstOrThrowArgs} args - Arguments to find a MedicationLog
     * @example
     * // Get one MedicationLog
     * const medicationLog = await prisma.medicationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicationLogs
     * const medicationLogs = await prisma.medicationLog.findMany()
     * 
     * // Get first 10 MedicationLogs
     * const medicationLogs = await prisma.medicationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationLogWithIdOnly = await prisma.medicationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationLogFindManyArgs>(args?: SelectSubset<T, MedicationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicationLog.
     * @param {MedicationLogCreateArgs} args - Arguments to create a MedicationLog.
     * @example
     * // Create one MedicationLog
     * const MedicationLog = await prisma.medicationLog.create({
     *   data: {
     *     // ... data to create a MedicationLog
     *   }
     * })
     * 
     */
    create<T extends MedicationLogCreateArgs>(args: SelectSubset<T, MedicationLogCreateArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicationLogs.
     * @param {MedicationLogCreateManyArgs} args - Arguments to create many MedicationLogs.
     * @example
     * // Create many MedicationLogs
     * const medicationLog = await prisma.medicationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationLogCreateManyArgs>(args?: SelectSubset<T, MedicationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicationLogs and returns the data saved in the database.
     * @param {MedicationLogCreateManyAndReturnArgs} args - Arguments to create many MedicationLogs.
     * @example
     * // Create many MedicationLogs
     * const medicationLog = await prisma.medicationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicationLogs and only return the `id`
     * const medicationLogWithIdOnly = await prisma.medicationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicationLog.
     * @param {MedicationLogDeleteArgs} args - Arguments to delete one MedicationLog.
     * @example
     * // Delete one MedicationLog
     * const MedicationLog = await prisma.medicationLog.delete({
     *   where: {
     *     // ... filter to delete one MedicationLog
     *   }
     * })
     * 
     */
    delete<T extends MedicationLogDeleteArgs>(args: SelectSubset<T, MedicationLogDeleteArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicationLog.
     * @param {MedicationLogUpdateArgs} args - Arguments to update one MedicationLog.
     * @example
     * // Update one MedicationLog
     * const medicationLog = await prisma.medicationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationLogUpdateArgs>(args: SelectSubset<T, MedicationLogUpdateArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicationLogs.
     * @param {MedicationLogDeleteManyArgs} args - Arguments to filter MedicationLogs to delete.
     * @example
     * // Delete a few MedicationLogs
     * const { count } = await prisma.medicationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationLogDeleteManyArgs>(args?: SelectSubset<T, MedicationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicationLogs
     * const medicationLog = await prisma.medicationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationLogUpdateManyArgs>(args: SelectSubset<T, MedicationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicationLogs and returns the data updated in the database.
     * @param {MedicationLogUpdateManyAndReturnArgs} args - Arguments to update many MedicationLogs.
     * @example
     * // Update many MedicationLogs
     * const medicationLog = await prisma.medicationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicationLogs and only return the `id`
     * const medicationLogWithIdOnly = await prisma.medicationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicationLog.
     * @param {MedicationLogUpsertArgs} args - Arguments to update or create a MedicationLog.
     * @example
     * // Update or create a MedicationLog
     * const medicationLog = await prisma.medicationLog.upsert({
     *   create: {
     *     // ... data to create a MedicationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicationLog we want to update
     *   }
     * })
     */
    upsert<T extends MedicationLogUpsertArgs>(args: SelectSubset<T, MedicationLogUpsertArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogCountArgs} args - Arguments to filter MedicationLogs to count.
     * @example
     * // Count the number of MedicationLogs
     * const count = await prisma.medicationLog.count({
     *   where: {
     *     // ... the filter for the MedicationLogs we want to count
     *   }
     * })
    **/
    count<T extends MedicationLogCountArgs>(
      args?: Subset<T, MedicationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationLogAggregateArgs>(args: Subset<T, MedicationLogAggregateArgs>): Prisma.PrismaPromise<GetMedicationLogAggregateType<T>>

    /**
     * Group by MedicationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationLogGroupByArgs['orderBy'] }
        : { orderBy?: MedicationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicationLog model
   */
  readonly fields: MedicationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends MedicationOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicationOrderDefaultArgs<ExtArgs>>): Prisma__MedicationOrderClient<$Result.GetResult<Prisma.$MedicationOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    administrator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicationLog model
   */
  interface MedicationLogFieldRefs {
    readonly id: FieldRef<"MedicationLog", 'String'>
    readonly orderId: FieldRef<"MedicationLog", 'String'>
    readonly administeredBy: FieldRef<"MedicationLog", 'String'>
    readonly administeredAt: FieldRef<"MedicationLog", 'DateTime'>
    readonly status: FieldRef<"MedicationLog", 'String'>
    readonly notes: FieldRef<"MedicationLog", 'String'>
    readonly shift: FieldRef<"MedicationLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MedicationLog findUnique
   */
  export type MedicationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter, which MedicationLog to fetch.
     */
    where: MedicationLogWhereUniqueInput
  }

  /**
   * MedicationLog findUniqueOrThrow
   */
  export type MedicationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter, which MedicationLog to fetch.
     */
    where: MedicationLogWhereUniqueInput
  }

  /**
   * MedicationLog findFirst
   */
  export type MedicationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter, which MedicationLog to fetch.
     */
    where?: MedicationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationLogs to fetch.
     */
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicationLogs.
     */
    cursor?: MedicationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicationLogs.
     */
    distinct?: MedicationLogScalarFieldEnum | MedicationLogScalarFieldEnum[]
  }

  /**
   * MedicationLog findFirstOrThrow
   */
  export type MedicationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter, which MedicationLog to fetch.
     */
    where?: MedicationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationLogs to fetch.
     */
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicationLogs.
     */
    cursor?: MedicationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicationLogs.
     */
    distinct?: MedicationLogScalarFieldEnum | MedicationLogScalarFieldEnum[]
  }

  /**
   * MedicationLog findMany
   */
  export type MedicationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter, which MedicationLogs to fetch.
     */
    where?: MedicationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationLogs to fetch.
     */
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicationLogs.
     */
    cursor?: MedicationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationLogs.
     */
    skip?: number
    distinct?: MedicationLogScalarFieldEnum | MedicationLogScalarFieldEnum[]
  }

  /**
   * MedicationLog create
   */
  export type MedicationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicationLog.
     */
    data: XOR<MedicationLogCreateInput, MedicationLogUncheckedCreateInput>
  }

  /**
   * MedicationLog createMany
   */
  export type MedicationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicationLogs.
     */
    data: MedicationLogCreateManyInput | MedicationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicationLog createManyAndReturn
   */
  export type MedicationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * The data used to create many MedicationLogs.
     */
    data: MedicationLogCreateManyInput | MedicationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicationLog update
   */
  export type MedicationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicationLog.
     */
    data: XOR<MedicationLogUpdateInput, MedicationLogUncheckedUpdateInput>
    /**
     * Choose, which MedicationLog to update.
     */
    where: MedicationLogWhereUniqueInput
  }

  /**
   * MedicationLog updateMany
   */
  export type MedicationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicationLogs.
     */
    data: XOR<MedicationLogUpdateManyMutationInput, MedicationLogUncheckedUpdateManyInput>
    /**
     * Filter which MedicationLogs to update
     */
    where?: MedicationLogWhereInput
    /**
     * Limit how many MedicationLogs to update.
     */
    limit?: number
  }

  /**
   * MedicationLog updateManyAndReturn
   */
  export type MedicationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * The data used to update MedicationLogs.
     */
    data: XOR<MedicationLogUpdateManyMutationInput, MedicationLogUncheckedUpdateManyInput>
    /**
     * Filter which MedicationLogs to update
     */
    where?: MedicationLogWhereInput
    /**
     * Limit how many MedicationLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicationLog upsert
   */
  export type MedicationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicationLog to update in case it exists.
     */
    where: MedicationLogWhereUniqueInput
    /**
     * In case the MedicationLog found by the `where` argument doesn't exist, create a new MedicationLog with this data.
     */
    create: XOR<MedicationLogCreateInput, MedicationLogUncheckedCreateInput>
    /**
     * In case the MedicationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationLogUpdateInput, MedicationLogUncheckedUpdateInput>
  }

  /**
   * MedicationLog delete
   */
  export type MedicationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter which MedicationLog to delete.
     */
    where: MedicationLogWhereUniqueInput
  }

  /**
   * MedicationLog deleteMany
   */
  export type MedicationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicationLogs to delete
     */
    where?: MedicationLogWhereInput
    /**
     * Limit how many MedicationLogs to delete.
     */
    limit?: number
  }

  /**
   * MedicationLog without action
   */
  export type MedicationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationLog
     */
    omit?: MedicationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
  }


  /**
   * Model VitalSign
   */

  export type AggregateVitalSign = {
    _count: VitalSignCountAggregateOutputType | null
    _avg: VitalSignAvgAggregateOutputType | null
    _sum: VitalSignSumAggregateOutputType | null
    _min: VitalSignMinAggregateOutputType | null
    _max: VitalSignMaxAggregateOutputType | null
  }

  export type VitalSignAvgAggregateOutputType = {
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    temperature: number | null
    oxygenSaturation: number | null
    glucose: number | null
    weight: number | null
  }

  export type VitalSignSumAggregateOutputType = {
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    temperature: number | null
    oxygenSaturation: number | null
    glucose: number | null
    weight: number | null
  }

  export type VitalSignMinAggregateOutputType = {
    id: string | null
    residentId: string | null
    recordedBy: string | null
    recordedAt: Date | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    temperature: number | null
    oxygenSaturation: number | null
    glucose: number | null
    weight: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VitalSignMaxAggregateOutputType = {
    id: string | null
    residentId: string | null
    recordedBy: string | null
    recordedAt: Date | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    temperature: number | null
    oxygenSaturation: number | null
    glucose: number | null
    weight: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VitalSignCountAggregateOutputType = {
    id: number
    residentId: number
    recordedBy: number
    recordedAt: number
    bloodPressureSystolic: number
    bloodPressureDiastolic: number
    heartRate: number
    temperature: number
    oxygenSaturation: number
    glucose: number
    weight: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VitalSignAvgAggregateInputType = {
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    temperature?: true
    oxygenSaturation?: true
    glucose?: true
    weight?: true
  }

  export type VitalSignSumAggregateInputType = {
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    temperature?: true
    oxygenSaturation?: true
    glucose?: true
    weight?: true
  }

  export type VitalSignMinAggregateInputType = {
    id?: true
    residentId?: true
    recordedBy?: true
    recordedAt?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    temperature?: true
    oxygenSaturation?: true
    glucose?: true
    weight?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VitalSignMaxAggregateInputType = {
    id?: true
    residentId?: true
    recordedBy?: true
    recordedAt?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    temperature?: true
    oxygenSaturation?: true
    glucose?: true
    weight?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VitalSignCountAggregateInputType = {
    id?: true
    residentId?: true
    recordedBy?: true
    recordedAt?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    temperature?: true
    oxygenSaturation?: true
    glucose?: true
    weight?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VitalSignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSign to aggregate.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitalSigns
    **/
    _count?: true | VitalSignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitalSignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitalSignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitalSignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitalSignMaxAggregateInputType
  }

  export type GetVitalSignAggregateType<T extends VitalSignAggregateArgs> = {
        [P in keyof T & keyof AggregateVitalSign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitalSign[P]>
      : GetScalarType<T[P], AggregateVitalSign[P]>
  }




  export type VitalSignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignWhereInput
    orderBy?: VitalSignOrderByWithAggregationInput | VitalSignOrderByWithAggregationInput[]
    by: VitalSignScalarFieldEnum[] | VitalSignScalarFieldEnum
    having?: VitalSignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitalSignCountAggregateInputType | true
    _avg?: VitalSignAvgAggregateInputType
    _sum?: VitalSignSumAggregateInputType
    _min?: VitalSignMinAggregateInputType
    _max?: VitalSignMaxAggregateInputType
  }

  export type VitalSignGroupByOutputType = {
    id: string
    residentId: string
    recordedBy: string
    recordedAt: Date
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    temperature: number | null
    oxygenSaturation: number | null
    glucose: number | null
    weight: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: VitalSignCountAggregateOutputType | null
    _avg: VitalSignAvgAggregateOutputType | null
    _sum: VitalSignSumAggregateOutputType | null
    _min: VitalSignMinAggregateOutputType | null
    _max: VitalSignMaxAggregateOutputType | null
  }

  type GetVitalSignGroupByPayload<T extends VitalSignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VitalSignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitalSignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitalSignGroupByOutputType[P]>
            : GetScalarType<T[P], VitalSignGroupByOutputType[P]>
        }
      >
    >


  export type VitalSignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    temperature?: boolean
    oxygenSaturation?: boolean
    glucose?: boolean
    weight?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    recorder?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSign"]>

  export type VitalSignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    temperature?: boolean
    oxygenSaturation?: boolean
    glucose?: boolean
    weight?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    recorder?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSign"]>

  export type VitalSignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    temperature?: boolean
    oxygenSaturation?: boolean
    glucose?: boolean
    weight?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    recorder?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSign"]>

  export type VitalSignSelectScalar = {
    id?: boolean
    residentId?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    temperature?: boolean
    oxygenSaturation?: boolean
    glucose?: boolean
    weight?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VitalSignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "residentId" | "recordedBy" | "recordedAt" | "bloodPressureSystolic" | "bloodPressureDiastolic" | "heartRate" | "temperature" | "oxygenSaturation" | "glucose" | "weight" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["vitalSign"]>
  export type VitalSignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    recorder?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VitalSignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    recorder?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VitalSignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    recorder?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VitalSignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VitalSign"
    objects: {
      resident: Prisma.$ResidentPayload<ExtArgs>
      recorder: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      residentId: string
      recordedBy: string
      recordedAt: Date
      bloodPressureSystolic: number | null
      bloodPressureDiastolic: number | null
      heartRate: number | null
      temperature: number | null
      oxygenSaturation: number | null
      glucose: number | null
      weight: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vitalSign"]>
    composites: {}
  }

  type VitalSignGetPayload<S extends boolean | null | undefined | VitalSignDefaultArgs> = $Result.GetResult<Prisma.$VitalSignPayload, S>

  type VitalSignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VitalSignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VitalSignCountAggregateInputType | true
    }

  export interface VitalSignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VitalSign'], meta: { name: 'VitalSign' } }
    /**
     * Find zero or one VitalSign that matches the filter.
     * @param {VitalSignFindUniqueArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VitalSignFindUniqueArgs>(args: SelectSubset<T, VitalSignFindUniqueArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VitalSign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VitalSignFindUniqueOrThrowArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VitalSignFindUniqueOrThrowArgs>(args: SelectSubset<T, VitalSignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignFindFirstArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VitalSignFindFirstArgs>(args?: SelectSubset<T, VitalSignFindFirstArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignFindFirstOrThrowArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VitalSignFindFirstOrThrowArgs>(args?: SelectSubset<T, VitalSignFindFirstOrThrowArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VitalSigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitalSigns
     * const vitalSigns = await prisma.vitalSign.findMany()
     * 
     * // Get first 10 VitalSigns
     * const vitalSigns = await prisma.vitalSign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitalSignWithIdOnly = await prisma.vitalSign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VitalSignFindManyArgs>(args?: SelectSubset<T, VitalSignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VitalSign.
     * @param {VitalSignCreateArgs} args - Arguments to create a VitalSign.
     * @example
     * // Create one VitalSign
     * const VitalSign = await prisma.vitalSign.create({
     *   data: {
     *     // ... data to create a VitalSign
     *   }
     * })
     * 
     */
    create<T extends VitalSignCreateArgs>(args: SelectSubset<T, VitalSignCreateArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VitalSigns.
     * @param {VitalSignCreateManyArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSign = await prisma.vitalSign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VitalSignCreateManyArgs>(args?: SelectSubset<T, VitalSignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VitalSigns and returns the data saved in the database.
     * @param {VitalSignCreateManyAndReturnArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSign = await prisma.vitalSign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VitalSigns and only return the `id`
     * const vitalSignWithIdOnly = await prisma.vitalSign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VitalSignCreateManyAndReturnArgs>(args?: SelectSubset<T, VitalSignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VitalSign.
     * @param {VitalSignDeleteArgs} args - Arguments to delete one VitalSign.
     * @example
     * // Delete one VitalSign
     * const VitalSign = await prisma.vitalSign.delete({
     *   where: {
     *     // ... filter to delete one VitalSign
     *   }
     * })
     * 
     */
    delete<T extends VitalSignDeleteArgs>(args: SelectSubset<T, VitalSignDeleteArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VitalSign.
     * @param {VitalSignUpdateArgs} args - Arguments to update one VitalSign.
     * @example
     * // Update one VitalSign
     * const vitalSign = await prisma.vitalSign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VitalSignUpdateArgs>(args: SelectSubset<T, VitalSignUpdateArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VitalSigns.
     * @param {VitalSignDeleteManyArgs} args - Arguments to filter VitalSigns to delete.
     * @example
     * // Delete a few VitalSigns
     * const { count } = await prisma.vitalSign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VitalSignDeleteManyArgs>(args?: SelectSubset<T, VitalSignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitalSigns
     * const vitalSign = await prisma.vitalSign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VitalSignUpdateManyArgs>(args: SelectSubset<T, VitalSignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns and returns the data updated in the database.
     * @param {VitalSignUpdateManyAndReturnArgs} args - Arguments to update many VitalSigns.
     * @example
     * // Update many VitalSigns
     * const vitalSign = await prisma.vitalSign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VitalSigns and only return the `id`
     * const vitalSignWithIdOnly = await prisma.vitalSign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VitalSignUpdateManyAndReturnArgs>(args: SelectSubset<T, VitalSignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VitalSign.
     * @param {VitalSignUpsertArgs} args - Arguments to update or create a VitalSign.
     * @example
     * // Update or create a VitalSign
     * const vitalSign = await prisma.vitalSign.upsert({
     *   create: {
     *     // ... data to create a VitalSign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitalSign we want to update
     *   }
     * })
     */
    upsert<T extends VitalSignUpsertArgs>(args: SelectSubset<T, VitalSignUpsertArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignCountArgs} args - Arguments to filter VitalSigns to count.
     * @example
     * // Count the number of VitalSigns
     * const count = await prisma.vitalSign.count({
     *   where: {
     *     // ... the filter for the VitalSigns we want to count
     *   }
     * })
    **/
    count<T extends VitalSignCountArgs>(
      args?: Subset<T, VitalSignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitalSignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitalSign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitalSignAggregateArgs>(args: Subset<T, VitalSignAggregateArgs>): Prisma.PrismaPromise<GetVitalSignAggregateType<T>>

    /**
     * Group by VitalSign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitalSignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitalSignGroupByArgs['orderBy'] }
        : { orderBy?: VitalSignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitalSignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitalSignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VitalSign model
   */
  readonly fields: VitalSignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitalSign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VitalSignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resident<T extends ResidentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResidentDefaultArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recorder<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VitalSign model
   */
  interface VitalSignFieldRefs {
    readonly id: FieldRef<"VitalSign", 'String'>
    readonly residentId: FieldRef<"VitalSign", 'String'>
    readonly recordedBy: FieldRef<"VitalSign", 'String'>
    readonly recordedAt: FieldRef<"VitalSign", 'DateTime'>
    readonly bloodPressureSystolic: FieldRef<"VitalSign", 'Int'>
    readonly bloodPressureDiastolic: FieldRef<"VitalSign", 'Int'>
    readonly heartRate: FieldRef<"VitalSign", 'Int'>
    readonly temperature: FieldRef<"VitalSign", 'Float'>
    readonly oxygenSaturation: FieldRef<"VitalSign", 'Int'>
    readonly glucose: FieldRef<"VitalSign", 'Int'>
    readonly weight: FieldRef<"VitalSign", 'Float'>
    readonly notes: FieldRef<"VitalSign", 'String'>
    readonly createdAt: FieldRef<"VitalSign", 'DateTime'>
    readonly updatedAt: FieldRef<"VitalSign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VitalSign findUnique
   */
  export type VitalSignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign findUniqueOrThrow
   */
  export type VitalSignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign findFirst
   */
  export type VitalSignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * VitalSign findFirstOrThrow
   */
  export type VitalSignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * VitalSign findMany
   */
  export type VitalSignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitalSigns.
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * VitalSign create
   */
  export type VitalSignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * The data needed to create a VitalSign.
     */
    data: XOR<VitalSignCreateInput, VitalSignUncheckedCreateInput>
  }

  /**
   * VitalSign createMany
   */
  export type VitalSignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignCreateManyInput | VitalSignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VitalSign createManyAndReturn
   */
  export type VitalSignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignCreateManyInput | VitalSignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VitalSign update
   */
  export type VitalSignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * The data needed to update a VitalSign.
     */
    data: XOR<VitalSignUpdateInput, VitalSignUncheckedUpdateInput>
    /**
     * Choose, which VitalSign to update.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign updateMany
   */
  export type VitalSignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
  }

  /**
   * VitalSign updateManyAndReturn
   */
  export type VitalSignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VitalSign upsert
   */
  export type VitalSignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * The filter to search for the VitalSign to update in case it exists.
     */
    where: VitalSignWhereUniqueInput
    /**
     * In case the VitalSign found by the `where` argument doesn't exist, create a new VitalSign with this data.
     */
    create: XOR<VitalSignCreateInput, VitalSignUncheckedCreateInput>
    /**
     * In case the VitalSign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VitalSignUpdateInput, VitalSignUncheckedUpdateInput>
  }

  /**
   * VitalSign delete
   */
  export type VitalSignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter which VitalSign to delete.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign deleteMany
   */
  export type VitalSignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSigns to delete
     */
    where?: VitalSignWhereInput
    /**
     * Limit how many VitalSigns to delete.
     */
    limit?: number
  }

  /**
   * VitalSign without action
   */
  export type VitalSignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
  }


  /**
   * Model NursingNote
   */

  export type AggregateNursingNote = {
    _count: NursingNoteCountAggregateOutputType | null
    _min: NursingNoteMinAggregateOutputType | null
    _max: NursingNoteMaxAggregateOutputType | null
  }

  export type NursingNoteMinAggregateOutputType = {
    id: string | null
    residentId: string | null
    authorId: string | null
    createdAt: Date | null
    shift: string | null
    category: string | null
    content: string | null
    severity: string | null
    updatedAt: Date | null
  }

  export type NursingNoteMaxAggregateOutputType = {
    id: string | null
    residentId: string | null
    authorId: string | null
    createdAt: Date | null
    shift: string | null
    category: string | null
    content: string | null
    severity: string | null
    updatedAt: Date | null
  }

  export type NursingNoteCountAggregateOutputType = {
    id: number
    residentId: number
    authorId: number
    createdAt: number
    shift: number
    category: number
    content: number
    severity: number
    updatedAt: number
    _all: number
  }


  export type NursingNoteMinAggregateInputType = {
    id?: true
    residentId?: true
    authorId?: true
    createdAt?: true
    shift?: true
    category?: true
    content?: true
    severity?: true
    updatedAt?: true
  }

  export type NursingNoteMaxAggregateInputType = {
    id?: true
    residentId?: true
    authorId?: true
    createdAt?: true
    shift?: true
    category?: true
    content?: true
    severity?: true
    updatedAt?: true
  }

  export type NursingNoteCountAggregateInputType = {
    id?: true
    residentId?: true
    authorId?: true
    createdAt?: true
    shift?: true
    category?: true
    content?: true
    severity?: true
    updatedAt?: true
    _all?: true
  }

  export type NursingNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NursingNote to aggregate.
     */
    where?: NursingNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NursingNotes to fetch.
     */
    orderBy?: NursingNoteOrderByWithRelationInput | NursingNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NursingNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NursingNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NursingNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NursingNotes
    **/
    _count?: true | NursingNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NursingNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NursingNoteMaxAggregateInputType
  }

  export type GetNursingNoteAggregateType<T extends NursingNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNursingNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNursingNote[P]>
      : GetScalarType<T[P], AggregateNursingNote[P]>
  }




  export type NursingNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NursingNoteWhereInput
    orderBy?: NursingNoteOrderByWithAggregationInput | NursingNoteOrderByWithAggregationInput[]
    by: NursingNoteScalarFieldEnum[] | NursingNoteScalarFieldEnum
    having?: NursingNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NursingNoteCountAggregateInputType | true
    _min?: NursingNoteMinAggregateInputType
    _max?: NursingNoteMaxAggregateInputType
  }

  export type NursingNoteGroupByOutputType = {
    id: string
    residentId: string
    authorId: string
    createdAt: Date
    shift: string
    category: string
    content: string
    severity: string
    updatedAt: Date
    _count: NursingNoteCountAggregateOutputType | null
    _min: NursingNoteMinAggregateOutputType | null
    _max: NursingNoteMaxAggregateOutputType | null
  }

  type GetNursingNoteGroupByPayload<T extends NursingNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NursingNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NursingNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NursingNoteGroupByOutputType[P]>
            : GetScalarType<T[P], NursingNoteGroupByOutputType[P]>
        }
      >
    >


  export type NursingNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    authorId?: boolean
    createdAt?: boolean
    shift?: boolean
    category?: boolean
    content?: boolean
    severity?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nursingNote"]>

  export type NursingNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    authorId?: boolean
    createdAt?: boolean
    shift?: boolean
    category?: boolean
    content?: boolean
    severity?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nursingNote"]>

  export type NursingNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    residentId?: boolean
    authorId?: boolean
    createdAt?: boolean
    shift?: boolean
    category?: boolean
    content?: boolean
    severity?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nursingNote"]>

  export type NursingNoteSelectScalar = {
    id?: boolean
    residentId?: boolean
    authorId?: boolean
    createdAt?: boolean
    shift?: boolean
    category?: boolean
    content?: boolean
    severity?: boolean
    updatedAt?: boolean
  }

  export type NursingNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "residentId" | "authorId" | "createdAt" | "shift" | "category" | "content" | "severity" | "updatedAt", ExtArgs["result"]["nursingNote"]>
  export type NursingNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NursingNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NursingNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NursingNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NursingNote"
    objects: {
      resident: Prisma.$ResidentPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      residentId: string
      authorId: string
      createdAt: Date
      shift: string
      category: string
      content: string
      severity: string
      updatedAt: Date
    }, ExtArgs["result"]["nursingNote"]>
    composites: {}
  }

  type NursingNoteGetPayload<S extends boolean | null | undefined | NursingNoteDefaultArgs> = $Result.GetResult<Prisma.$NursingNotePayload, S>

  type NursingNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NursingNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NursingNoteCountAggregateInputType | true
    }

  export interface NursingNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NursingNote'], meta: { name: 'NursingNote' } }
    /**
     * Find zero or one NursingNote that matches the filter.
     * @param {NursingNoteFindUniqueArgs} args - Arguments to find a NursingNote
     * @example
     * // Get one NursingNote
     * const nursingNote = await prisma.nursingNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NursingNoteFindUniqueArgs>(args: SelectSubset<T, NursingNoteFindUniqueArgs<ExtArgs>>): Prisma__NursingNoteClient<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NursingNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NursingNoteFindUniqueOrThrowArgs} args - Arguments to find a NursingNote
     * @example
     * // Get one NursingNote
     * const nursingNote = await prisma.nursingNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NursingNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NursingNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NursingNoteClient<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NursingNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingNoteFindFirstArgs} args - Arguments to find a NursingNote
     * @example
     * // Get one NursingNote
     * const nursingNote = await prisma.nursingNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NursingNoteFindFirstArgs>(args?: SelectSubset<T, NursingNoteFindFirstArgs<ExtArgs>>): Prisma__NursingNoteClient<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NursingNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingNoteFindFirstOrThrowArgs} args - Arguments to find a NursingNote
     * @example
     * // Get one NursingNote
     * const nursingNote = await prisma.nursingNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NursingNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NursingNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NursingNoteClient<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NursingNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NursingNotes
     * const nursingNotes = await prisma.nursingNote.findMany()
     * 
     * // Get first 10 NursingNotes
     * const nursingNotes = await prisma.nursingNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nursingNoteWithIdOnly = await prisma.nursingNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NursingNoteFindManyArgs>(args?: SelectSubset<T, NursingNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NursingNote.
     * @param {NursingNoteCreateArgs} args - Arguments to create a NursingNote.
     * @example
     * // Create one NursingNote
     * const NursingNote = await prisma.nursingNote.create({
     *   data: {
     *     // ... data to create a NursingNote
     *   }
     * })
     * 
     */
    create<T extends NursingNoteCreateArgs>(args: SelectSubset<T, NursingNoteCreateArgs<ExtArgs>>): Prisma__NursingNoteClient<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NursingNotes.
     * @param {NursingNoteCreateManyArgs} args - Arguments to create many NursingNotes.
     * @example
     * // Create many NursingNotes
     * const nursingNote = await prisma.nursingNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NursingNoteCreateManyArgs>(args?: SelectSubset<T, NursingNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NursingNotes and returns the data saved in the database.
     * @param {NursingNoteCreateManyAndReturnArgs} args - Arguments to create many NursingNotes.
     * @example
     * // Create many NursingNotes
     * const nursingNote = await prisma.nursingNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NursingNotes and only return the `id`
     * const nursingNoteWithIdOnly = await prisma.nursingNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NursingNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, NursingNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NursingNote.
     * @param {NursingNoteDeleteArgs} args - Arguments to delete one NursingNote.
     * @example
     * // Delete one NursingNote
     * const NursingNote = await prisma.nursingNote.delete({
     *   where: {
     *     // ... filter to delete one NursingNote
     *   }
     * })
     * 
     */
    delete<T extends NursingNoteDeleteArgs>(args: SelectSubset<T, NursingNoteDeleteArgs<ExtArgs>>): Prisma__NursingNoteClient<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NursingNote.
     * @param {NursingNoteUpdateArgs} args - Arguments to update one NursingNote.
     * @example
     * // Update one NursingNote
     * const nursingNote = await prisma.nursingNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NursingNoteUpdateArgs>(args: SelectSubset<T, NursingNoteUpdateArgs<ExtArgs>>): Prisma__NursingNoteClient<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NursingNotes.
     * @param {NursingNoteDeleteManyArgs} args - Arguments to filter NursingNotes to delete.
     * @example
     * // Delete a few NursingNotes
     * const { count } = await prisma.nursingNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NursingNoteDeleteManyArgs>(args?: SelectSubset<T, NursingNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NursingNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NursingNotes
     * const nursingNote = await prisma.nursingNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NursingNoteUpdateManyArgs>(args: SelectSubset<T, NursingNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NursingNotes and returns the data updated in the database.
     * @param {NursingNoteUpdateManyAndReturnArgs} args - Arguments to update many NursingNotes.
     * @example
     * // Update many NursingNotes
     * const nursingNote = await prisma.nursingNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NursingNotes and only return the `id`
     * const nursingNoteWithIdOnly = await prisma.nursingNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NursingNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, NursingNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NursingNote.
     * @param {NursingNoteUpsertArgs} args - Arguments to update or create a NursingNote.
     * @example
     * // Update or create a NursingNote
     * const nursingNote = await prisma.nursingNote.upsert({
     *   create: {
     *     // ... data to create a NursingNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NursingNote we want to update
     *   }
     * })
     */
    upsert<T extends NursingNoteUpsertArgs>(args: SelectSubset<T, NursingNoteUpsertArgs<ExtArgs>>): Prisma__NursingNoteClient<$Result.GetResult<Prisma.$NursingNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NursingNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingNoteCountArgs} args - Arguments to filter NursingNotes to count.
     * @example
     * // Count the number of NursingNotes
     * const count = await prisma.nursingNote.count({
     *   where: {
     *     // ... the filter for the NursingNotes we want to count
     *   }
     * })
    **/
    count<T extends NursingNoteCountArgs>(
      args?: Subset<T, NursingNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NursingNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NursingNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NursingNoteAggregateArgs>(args: Subset<T, NursingNoteAggregateArgs>): Prisma.PrismaPromise<GetNursingNoteAggregateType<T>>

    /**
     * Group by NursingNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NursingNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NursingNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NursingNoteGroupByArgs['orderBy'] }
        : { orderBy?: NursingNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NursingNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNursingNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NursingNote model
   */
  readonly fields: NursingNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NursingNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NursingNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resident<T extends ResidentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResidentDefaultArgs<ExtArgs>>): Prisma__ResidentClient<$Result.GetResult<Prisma.$ResidentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NursingNote model
   */
  interface NursingNoteFieldRefs {
    readonly id: FieldRef<"NursingNote", 'String'>
    readonly residentId: FieldRef<"NursingNote", 'String'>
    readonly authorId: FieldRef<"NursingNote", 'String'>
    readonly createdAt: FieldRef<"NursingNote", 'DateTime'>
    readonly shift: FieldRef<"NursingNote", 'String'>
    readonly category: FieldRef<"NursingNote", 'String'>
    readonly content: FieldRef<"NursingNote", 'String'>
    readonly severity: FieldRef<"NursingNote", 'String'>
    readonly updatedAt: FieldRef<"NursingNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NursingNote findUnique
   */
  export type NursingNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    /**
     * Filter, which NursingNote to fetch.
     */
    where: NursingNoteWhereUniqueInput
  }

  /**
   * NursingNote findUniqueOrThrow
   */
  export type NursingNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    /**
     * Filter, which NursingNote to fetch.
     */
    where: NursingNoteWhereUniqueInput
  }

  /**
   * NursingNote findFirst
   */
  export type NursingNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    /**
     * Filter, which NursingNote to fetch.
     */
    where?: NursingNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NursingNotes to fetch.
     */
    orderBy?: NursingNoteOrderByWithRelationInput | NursingNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NursingNotes.
     */
    cursor?: NursingNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NursingNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NursingNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NursingNotes.
     */
    distinct?: NursingNoteScalarFieldEnum | NursingNoteScalarFieldEnum[]
  }

  /**
   * NursingNote findFirstOrThrow
   */
  export type NursingNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    /**
     * Filter, which NursingNote to fetch.
     */
    where?: NursingNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NursingNotes to fetch.
     */
    orderBy?: NursingNoteOrderByWithRelationInput | NursingNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NursingNotes.
     */
    cursor?: NursingNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NursingNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NursingNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NursingNotes.
     */
    distinct?: NursingNoteScalarFieldEnum | NursingNoteScalarFieldEnum[]
  }

  /**
   * NursingNote findMany
   */
  export type NursingNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    /**
     * Filter, which NursingNotes to fetch.
     */
    where?: NursingNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NursingNotes to fetch.
     */
    orderBy?: NursingNoteOrderByWithRelationInput | NursingNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NursingNotes.
     */
    cursor?: NursingNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NursingNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NursingNotes.
     */
    skip?: number
    distinct?: NursingNoteScalarFieldEnum | NursingNoteScalarFieldEnum[]
  }

  /**
   * NursingNote create
   */
  export type NursingNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a NursingNote.
     */
    data: XOR<NursingNoteCreateInput, NursingNoteUncheckedCreateInput>
  }

  /**
   * NursingNote createMany
   */
  export type NursingNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NursingNotes.
     */
    data: NursingNoteCreateManyInput | NursingNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NursingNote createManyAndReturn
   */
  export type NursingNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * The data used to create many NursingNotes.
     */
    data: NursingNoteCreateManyInput | NursingNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NursingNote update
   */
  export type NursingNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a NursingNote.
     */
    data: XOR<NursingNoteUpdateInput, NursingNoteUncheckedUpdateInput>
    /**
     * Choose, which NursingNote to update.
     */
    where: NursingNoteWhereUniqueInput
  }

  /**
   * NursingNote updateMany
   */
  export type NursingNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NursingNotes.
     */
    data: XOR<NursingNoteUpdateManyMutationInput, NursingNoteUncheckedUpdateManyInput>
    /**
     * Filter which NursingNotes to update
     */
    where?: NursingNoteWhereInput
    /**
     * Limit how many NursingNotes to update.
     */
    limit?: number
  }

  /**
   * NursingNote updateManyAndReturn
   */
  export type NursingNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * The data used to update NursingNotes.
     */
    data: XOR<NursingNoteUpdateManyMutationInput, NursingNoteUncheckedUpdateManyInput>
    /**
     * Filter which NursingNotes to update
     */
    where?: NursingNoteWhereInput
    /**
     * Limit how many NursingNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NursingNote upsert
   */
  export type NursingNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the NursingNote to update in case it exists.
     */
    where: NursingNoteWhereUniqueInput
    /**
     * In case the NursingNote found by the `where` argument doesn't exist, create a new NursingNote with this data.
     */
    create: XOR<NursingNoteCreateInput, NursingNoteUncheckedCreateInput>
    /**
     * In case the NursingNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NursingNoteUpdateInput, NursingNoteUncheckedUpdateInput>
  }

  /**
   * NursingNote delete
   */
  export type NursingNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
    /**
     * Filter which NursingNote to delete.
     */
    where: NursingNoteWhereUniqueInput
  }

  /**
   * NursingNote deleteMany
   */
  export type NursingNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NursingNotes to delete
     */
    where?: NursingNoteWhereInput
    /**
     * Limit how many NursingNotes to delete.
     */
    limit?: number
  }

  /**
   * NursingNote without action
   */
  export type NursingNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NursingNote
     */
    select?: NursingNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NursingNote
     */
    omit?: NursingNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NursingNoteInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    classCode: string | null
    section: string | null
    subject: string | null
    room: string | null
    teacherId: string | null
    moduleId: string | null
    backgroundImage: string | null
    isArchived: boolean | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    classCode: string | null
    section: string | null
    subject: string | null
    room: string | null
    teacherId: string | null
    moduleId: string | null
    backgroundImage: string | null
    isArchived: boolean | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    title: number
    description: number
    classCode: number
    section: number
    subject: number
    room: number
    teacherId: number
    moduleId: number
    backgroundImage: number
    isArchived: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    classCode?: true
    section?: true
    subject?: true
    room?: true
    teacherId?: true
    moduleId?: true
    backgroundImage?: true
    isArchived?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    classCode?: true
    section?: true
    subject?: true
    room?: true
    teacherId?: true
    moduleId?: true
    backgroundImage?: true
    isArchived?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    classCode?: true
    section?: true
    subject?: true
    room?: true
    teacherId?: true
    moduleId?: true
    backgroundImage?: true
    isArchived?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    title: string
    description: string | null
    classCode: string
    section: string | null
    subject: string | null
    room: string | null
    teacherId: string
    moduleId: string | null
    backgroundImage: string | null
    isArchived: boolean
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    classCode?: boolean
    section?: boolean
    subject?: boolean
    room?: boolean
    teacherId?: boolean
    moduleId?: boolean
    backgroundImage?: boolean
    isArchived?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Class$membersArgs<ExtArgs>
    module?: boolean | Class$moduleArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    grades?: boolean | Class$gradesArgs<ExtArgs>
    streamItems?: boolean | Class$streamItemsArgs<ExtArgs>
    topics?: boolean | Class$topicsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    classCode?: boolean
    section?: boolean
    subject?: boolean
    room?: boolean
    teacherId?: boolean
    moduleId?: boolean
    backgroundImage?: boolean
    isArchived?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | Class$moduleArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    classCode?: boolean
    section?: boolean
    subject?: boolean
    room?: boolean
    teacherId?: boolean
    moduleId?: boolean
    backgroundImage?: boolean
    isArchived?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | Class$moduleArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    classCode?: boolean
    section?: boolean
    subject?: boolean
    room?: boolean
    teacherId?: boolean
    moduleId?: boolean
    backgroundImage?: boolean
    isArchived?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "classCode" | "section" | "subject" | "room" | "teacherId" | "moduleId" | "backgroundImage" | "isArchived" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Class$membersArgs<ExtArgs>
    module?: boolean | Class$moduleArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    grades?: boolean | Class$gradesArgs<ExtArgs>
    streamItems?: boolean | Class$streamItemsArgs<ExtArgs>
    topics?: boolean | Class$topicsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | Class$moduleArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | Class$moduleArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      members: Prisma.$ClassMemberPayload<ExtArgs>[]
      module: Prisma.$ModulePayload<ExtArgs> | null
      teacher: Prisma.$UserPayload<ExtArgs>
      grades: Prisma.$GradePayload<ExtArgs>[]
      streamItems: Prisma.$StreamItemPayload<ExtArgs>[]
      topics: Prisma.$TopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      classCode: string
      section: string | null
      subject: string | null
      room: string | null
      teacherId: string
      moduleId: string | null
      backgroundImage: string | null
      isArchived: boolean
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Class$membersArgs<ExtArgs> = {}>(args?: Subset<T, Class$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    module<T extends Class$moduleArgs<ExtArgs> = {}>(args?: Subset<T, Class$moduleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grades<T extends Class$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Class$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    streamItems<T extends Class$streamItemsArgs<ExtArgs> = {}>(args?: Subset<T, Class$streamItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    topics<T extends Class$topicsArgs<ExtArgs> = {}>(args?: Subset<T, Class$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly title: FieldRef<"Class", 'String'>
    readonly description: FieldRef<"Class", 'String'>
    readonly classCode: FieldRef<"Class", 'String'>
    readonly section: FieldRef<"Class", 'String'>
    readonly subject: FieldRef<"Class", 'String'>
    readonly room: FieldRef<"Class", 'String'>
    readonly teacherId: FieldRef<"Class", 'String'>
    readonly moduleId: FieldRef<"Class", 'String'>
    readonly backgroundImage: FieldRef<"Class", 'String'>
    readonly isArchived: FieldRef<"Class", 'Boolean'>
    readonly status: FieldRef<"Class", 'String'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.members
   */
  export type Class$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    where?: ClassMemberWhereInput
    orderBy?: ClassMemberOrderByWithRelationInput | ClassMemberOrderByWithRelationInput[]
    cursor?: ClassMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassMemberScalarFieldEnum | ClassMemberScalarFieldEnum[]
  }

  /**
   * Class.module
   */
  export type Class$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * Class.grades
   */
  export type Class$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Class.streamItems
   */
  export type Class$streamItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    where?: StreamItemWhereInput
    orderBy?: StreamItemOrderByWithRelationInput | StreamItemOrderByWithRelationInput[]
    cursor?: StreamItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StreamItemScalarFieldEnum | StreamItemScalarFieldEnum[]
  }

  /**
   * Class.topics
   */
  export type Class$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model ClassMember
   */

  export type AggregateClassMember = {
    _count: ClassMemberCountAggregateOutputType | null
    _min: ClassMemberMinAggregateOutputType | null
    _max: ClassMemberMaxAggregateOutputType | null
  }

  export type ClassMemberMinAggregateOutputType = {
    id: string | null
    classId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    status: string | null
  }

  export type ClassMemberMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    status: string | null
  }

  export type ClassMemberCountAggregateOutputType = {
    id: number
    classId: number
    userId: number
    role: number
    joinedAt: number
    status: number
    _all: number
  }


  export type ClassMemberMinAggregateInputType = {
    id?: true
    classId?: true
    userId?: true
    role?: true
    joinedAt?: true
    status?: true
  }

  export type ClassMemberMaxAggregateInputType = {
    id?: true
    classId?: true
    userId?: true
    role?: true
    joinedAt?: true
    status?: true
  }

  export type ClassMemberCountAggregateInputType = {
    id?: true
    classId?: true
    userId?: true
    role?: true
    joinedAt?: true
    status?: true
    _all?: true
  }

  export type ClassMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassMember to aggregate.
     */
    where?: ClassMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassMembers to fetch.
     */
    orderBy?: ClassMemberOrderByWithRelationInput | ClassMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassMembers
    **/
    _count?: true | ClassMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMemberMaxAggregateInputType
  }

  export type GetClassMemberAggregateType<T extends ClassMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateClassMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassMember[P]>
      : GetScalarType<T[P], AggregateClassMember[P]>
  }




  export type ClassMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassMemberWhereInput
    orderBy?: ClassMemberOrderByWithAggregationInput | ClassMemberOrderByWithAggregationInput[]
    by: ClassMemberScalarFieldEnum[] | ClassMemberScalarFieldEnum
    having?: ClassMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassMemberCountAggregateInputType | true
    _min?: ClassMemberMinAggregateInputType
    _max?: ClassMemberMaxAggregateInputType
  }

  export type ClassMemberGroupByOutputType = {
    id: string
    classId: string
    userId: string
    role: string
    joinedAt: Date
    status: string
    _count: ClassMemberCountAggregateOutputType | null
    _min: ClassMemberMinAggregateOutputType | null
    _max: ClassMemberMaxAggregateOutputType | null
  }

  type GetClassMemberGroupByPayload<T extends ClassMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ClassMemberGroupByOutputType[P]>
        }
      >
    >


  export type ClassMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    status?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classMember"]>

  export type ClassMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    status?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classMember"]>

  export type ClassMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    status?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classMember"]>

  export type ClassMemberSelectScalar = {
    id?: boolean
    classId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    status?: boolean
  }

  export type ClassMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "userId" | "role" | "joinedAt" | "status", ExtArgs["result"]["classMember"]>
  export type ClassMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClassMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassMember"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      userId: string
      role: string
      joinedAt: Date
      status: string
    }, ExtArgs["result"]["classMember"]>
    composites: {}
  }

  type ClassMemberGetPayload<S extends boolean | null | undefined | ClassMemberDefaultArgs> = $Result.GetResult<Prisma.$ClassMemberPayload, S>

  type ClassMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassMemberCountAggregateInputType | true
    }

  export interface ClassMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassMember'], meta: { name: 'ClassMember' } }
    /**
     * Find zero or one ClassMember that matches the filter.
     * @param {ClassMemberFindUniqueArgs} args - Arguments to find a ClassMember
     * @example
     * // Get one ClassMember
     * const classMember = await prisma.classMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassMemberFindUniqueArgs>(args: SelectSubset<T, ClassMemberFindUniqueArgs<ExtArgs>>): Prisma__ClassMemberClient<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassMemberFindUniqueOrThrowArgs} args - Arguments to find a ClassMember
     * @example
     * // Get one ClassMember
     * const classMember = await prisma.classMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassMemberClient<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassMemberFindFirstArgs} args - Arguments to find a ClassMember
     * @example
     * // Get one ClassMember
     * const classMember = await prisma.classMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassMemberFindFirstArgs>(args?: SelectSubset<T, ClassMemberFindFirstArgs<ExtArgs>>): Prisma__ClassMemberClient<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassMemberFindFirstOrThrowArgs} args - Arguments to find a ClassMember
     * @example
     * // Get one ClassMember
     * const classMember = await prisma.classMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassMemberClient<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassMembers
     * const classMembers = await prisma.classMember.findMany()
     * 
     * // Get first 10 ClassMembers
     * const classMembers = await prisma.classMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classMemberWithIdOnly = await prisma.classMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassMemberFindManyArgs>(args?: SelectSubset<T, ClassMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassMember.
     * @param {ClassMemberCreateArgs} args - Arguments to create a ClassMember.
     * @example
     * // Create one ClassMember
     * const ClassMember = await prisma.classMember.create({
     *   data: {
     *     // ... data to create a ClassMember
     *   }
     * })
     * 
     */
    create<T extends ClassMemberCreateArgs>(args: SelectSubset<T, ClassMemberCreateArgs<ExtArgs>>): Prisma__ClassMemberClient<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassMembers.
     * @param {ClassMemberCreateManyArgs} args - Arguments to create many ClassMembers.
     * @example
     * // Create many ClassMembers
     * const classMember = await prisma.classMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassMemberCreateManyArgs>(args?: SelectSubset<T, ClassMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassMembers and returns the data saved in the database.
     * @param {ClassMemberCreateManyAndReturnArgs} args - Arguments to create many ClassMembers.
     * @example
     * // Create many ClassMembers
     * const classMember = await prisma.classMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassMembers and only return the `id`
     * const classMemberWithIdOnly = await prisma.classMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassMember.
     * @param {ClassMemberDeleteArgs} args - Arguments to delete one ClassMember.
     * @example
     * // Delete one ClassMember
     * const ClassMember = await prisma.classMember.delete({
     *   where: {
     *     // ... filter to delete one ClassMember
     *   }
     * })
     * 
     */
    delete<T extends ClassMemberDeleteArgs>(args: SelectSubset<T, ClassMemberDeleteArgs<ExtArgs>>): Prisma__ClassMemberClient<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassMember.
     * @param {ClassMemberUpdateArgs} args - Arguments to update one ClassMember.
     * @example
     * // Update one ClassMember
     * const classMember = await prisma.classMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassMemberUpdateArgs>(args: SelectSubset<T, ClassMemberUpdateArgs<ExtArgs>>): Prisma__ClassMemberClient<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassMembers.
     * @param {ClassMemberDeleteManyArgs} args - Arguments to filter ClassMembers to delete.
     * @example
     * // Delete a few ClassMembers
     * const { count } = await prisma.classMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassMemberDeleteManyArgs>(args?: SelectSubset<T, ClassMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassMembers
     * const classMember = await prisma.classMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassMemberUpdateManyArgs>(args: SelectSubset<T, ClassMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassMembers and returns the data updated in the database.
     * @param {ClassMemberUpdateManyAndReturnArgs} args - Arguments to update many ClassMembers.
     * @example
     * // Update many ClassMembers
     * const classMember = await prisma.classMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassMembers and only return the `id`
     * const classMemberWithIdOnly = await prisma.classMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassMember.
     * @param {ClassMemberUpsertArgs} args - Arguments to update or create a ClassMember.
     * @example
     * // Update or create a ClassMember
     * const classMember = await prisma.classMember.upsert({
     *   create: {
     *     // ... data to create a ClassMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassMember we want to update
     *   }
     * })
     */
    upsert<T extends ClassMemberUpsertArgs>(args: SelectSubset<T, ClassMemberUpsertArgs<ExtArgs>>): Prisma__ClassMemberClient<$Result.GetResult<Prisma.$ClassMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassMemberCountArgs} args - Arguments to filter ClassMembers to count.
     * @example
     * // Count the number of ClassMembers
     * const count = await prisma.classMember.count({
     *   where: {
     *     // ... the filter for the ClassMembers we want to count
     *   }
     * })
    **/
    count<T extends ClassMemberCountArgs>(
      args?: Subset<T, ClassMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassMemberAggregateArgs>(args: Subset<T, ClassMemberAggregateArgs>): Prisma.PrismaPromise<GetClassMemberAggregateType<T>>

    /**
     * Group by ClassMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassMemberGroupByArgs['orderBy'] }
        : { orderBy?: ClassMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassMember model
   */
  readonly fields: ClassMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassMember model
   */
  interface ClassMemberFieldRefs {
    readonly id: FieldRef<"ClassMember", 'String'>
    readonly classId: FieldRef<"ClassMember", 'String'>
    readonly userId: FieldRef<"ClassMember", 'String'>
    readonly role: FieldRef<"ClassMember", 'String'>
    readonly joinedAt: FieldRef<"ClassMember", 'DateTime'>
    readonly status: FieldRef<"ClassMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassMember findUnique
   */
  export type ClassMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClassMember to fetch.
     */
    where: ClassMemberWhereUniqueInput
  }

  /**
   * ClassMember findUniqueOrThrow
   */
  export type ClassMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClassMember to fetch.
     */
    where: ClassMemberWhereUniqueInput
  }

  /**
   * ClassMember findFirst
   */
  export type ClassMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClassMember to fetch.
     */
    where?: ClassMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassMembers to fetch.
     */
    orderBy?: ClassMemberOrderByWithRelationInput | ClassMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassMembers.
     */
    cursor?: ClassMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassMembers.
     */
    distinct?: ClassMemberScalarFieldEnum | ClassMemberScalarFieldEnum[]
  }

  /**
   * ClassMember findFirstOrThrow
   */
  export type ClassMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClassMember to fetch.
     */
    where?: ClassMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassMembers to fetch.
     */
    orderBy?: ClassMemberOrderByWithRelationInput | ClassMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassMembers.
     */
    cursor?: ClassMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassMembers.
     */
    distinct?: ClassMemberScalarFieldEnum | ClassMemberScalarFieldEnum[]
  }

  /**
   * ClassMember findMany
   */
  export type ClassMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClassMembers to fetch.
     */
    where?: ClassMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassMembers to fetch.
     */
    orderBy?: ClassMemberOrderByWithRelationInput | ClassMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassMembers.
     */
    cursor?: ClassMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassMembers.
     */
    skip?: number
    distinct?: ClassMemberScalarFieldEnum | ClassMemberScalarFieldEnum[]
  }

  /**
   * ClassMember create
   */
  export type ClassMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassMember.
     */
    data: XOR<ClassMemberCreateInput, ClassMemberUncheckedCreateInput>
  }

  /**
   * ClassMember createMany
   */
  export type ClassMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassMembers.
     */
    data: ClassMemberCreateManyInput | ClassMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassMember createManyAndReturn
   */
  export type ClassMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ClassMembers.
     */
    data: ClassMemberCreateManyInput | ClassMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassMember update
   */
  export type ClassMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassMember.
     */
    data: XOR<ClassMemberUpdateInput, ClassMemberUncheckedUpdateInput>
    /**
     * Choose, which ClassMember to update.
     */
    where: ClassMemberWhereUniqueInput
  }

  /**
   * ClassMember updateMany
   */
  export type ClassMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassMembers.
     */
    data: XOR<ClassMemberUpdateManyMutationInput, ClassMemberUncheckedUpdateManyInput>
    /**
     * Filter which ClassMembers to update
     */
    where?: ClassMemberWhereInput
    /**
     * Limit how many ClassMembers to update.
     */
    limit?: number
  }

  /**
   * ClassMember updateManyAndReturn
   */
  export type ClassMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * The data used to update ClassMembers.
     */
    data: XOR<ClassMemberUpdateManyMutationInput, ClassMemberUncheckedUpdateManyInput>
    /**
     * Filter which ClassMembers to update
     */
    where?: ClassMemberWhereInput
    /**
     * Limit how many ClassMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassMember upsert
   */
  export type ClassMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassMember to update in case it exists.
     */
    where: ClassMemberWhereUniqueInput
    /**
     * In case the ClassMember found by the `where` argument doesn't exist, create a new ClassMember with this data.
     */
    create: XOR<ClassMemberCreateInput, ClassMemberUncheckedCreateInput>
    /**
     * In case the ClassMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassMemberUpdateInput, ClassMemberUncheckedUpdateInput>
  }

  /**
   * ClassMember delete
   */
  export type ClassMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
    /**
     * Filter which ClassMember to delete.
     */
    where: ClassMemberWhereUniqueInput
  }

  /**
   * ClassMember deleteMany
   */
  export type ClassMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassMembers to delete
     */
    where?: ClassMemberWhereInput
    /**
     * Limit how many ClassMembers to delete.
     */
    limit?: number
  }

  /**
   * ClassMember without action
   */
  export type ClassMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassMember
     */
    select?: ClassMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassMember
     */
    omit?: ClassMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassMemberInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicAvgAggregateOutputType = {
    order: number | null
  }

  export type TopicSumAggregateOutputType = {
    order: number | null
  }

  export type TopicMinAggregateOutputType = {
    id: string | null
    classId: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    classId: number
    name: number
    description: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopicAvgAggregateInputType = {
    order?: true
  }

  export type TopicSumAggregateInputType = {
    order?: true
  }

  export type TopicMinAggregateInputType = {
    id?: true
    classId?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    classId?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    classId?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _avg?: TopicAvgAggregateInputType
    _sum?: TopicSumAggregateInputType
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: string
    classId: string
    name: string
    description: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    streamItems?: boolean | Topic$streamItemsArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    id?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "name" | "description" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["topic"]>
  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItems?: boolean | Topic$streamItemsArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type TopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      streamItems: Prisma.$StreamItemPayload<ExtArgs>[]
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      name: string
      description: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics and returns the data updated in the database.
     * @param {TopicUpdateManyAndReturnArgs} args - Arguments to update many Topics.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    streamItems<T extends Topic$streamItemsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$streamItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'String'>
    readonly classId: FieldRef<"Topic", 'String'>
    readonly name: FieldRef<"Topic", 'String'>
    readonly description: FieldRef<"Topic", 'String'>
    readonly order: FieldRef<"Topic", 'Int'>
    readonly createdAt: FieldRef<"Topic", 'DateTime'>
    readonly updatedAt: FieldRef<"Topic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topic updateManyAndReturn
   */
  export type TopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to delete.
     */
    limit?: number
  }

  /**
   * Topic.streamItems
   */
  export type Topic$streamItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    where?: StreamItemWhereInput
    orderBy?: StreamItemOrderByWithRelationInput | StreamItemOrderByWithRelationInput[]
    cursor?: StreamItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StreamItemScalarFieldEnum | StreamItemScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model StreamItem
   */

  export type AggregateStreamItem = {
    _count: StreamItemCountAggregateOutputType | null
    _min: StreamItemMinAggregateOutputType | null
    _max: StreamItemMaxAggregateOutputType | null
  }

  export type StreamItemMinAggregateOutputType = {
    id: string | null
    classId: string | null
    type: string | null
    title: string | null
    content: string | null
    authorId: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isArchived: boolean | null
  }

  export type StreamItemMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    type: string | null
    title: string | null
    content: string | null
    authorId: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isArchived: boolean | null
  }

  export type StreamItemCountAggregateOutputType = {
    id: number
    classId: number
    type: number
    title: number
    content: number
    authorId: number
    topicId: number
    createdAt: number
    updatedAt: number
    isArchived: number
    _all: number
  }


  export type StreamItemMinAggregateInputType = {
    id?: true
    classId?: true
    type?: true
    title?: true
    content?: true
    authorId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    isArchived?: true
  }

  export type StreamItemMaxAggregateInputType = {
    id?: true
    classId?: true
    type?: true
    title?: true
    content?: true
    authorId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    isArchived?: true
  }

  export type StreamItemCountAggregateInputType = {
    id?: true
    classId?: true
    type?: true
    title?: true
    content?: true
    authorId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    isArchived?: true
    _all?: true
  }

  export type StreamItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StreamItem to aggregate.
     */
    where?: StreamItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreamItems to fetch.
     */
    orderBy?: StreamItemOrderByWithRelationInput | StreamItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StreamItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreamItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreamItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StreamItems
    **/
    _count?: true | StreamItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StreamItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StreamItemMaxAggregateInputType
  }

  export type GetStreamItemAggregateType<T extends StreamItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStreamItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStreamItem[P]>
      : GetScalarType<T[P], AggregateStreamItem[P]>
  }




  export type StreamItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreamItemWhereInput
    orderBy?: StreamItemOrderByWithAggregationInput | StreamItemOrderByWithAggregationInput[]
    by: StreamItemScalarFieldEnum[] | StreamItemScalarFieldEnum
    having?: StreamItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StreamItemCountAggregateInputType | true
    _min?: StreamItemMinAggregateInputType
    _max?: StreamItemMaxAggregateInputType
  }

  export type StreamItemGroupByOutputType = {
    id: string
    classId: string | null
    type: string
    title: string
    content: string | null
    authorId: string
    topicId: string | null
    createdAt: Date
    updatedAt: Date
    isArchived: boolean
    _count: StreamItemCountAggregateOutputType | null
    _min: StreamItemMinAggregateOutputType | null
    _max: StreamItemMaxAggregateOutputType | null
  }

  type GetStreamItemGroupByPayload<T extends StreamItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StreamItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StreamItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StreamItemGroupByOutputType[P]>
            : GetScalarType<T[P], StreamItemGroupByOutputType[P]>
        }
      >
    >


  export type StreamItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isArchived?: boolean
    announcementStudents?: boolean | StreamItem$announcementStudentsArgs<ExtArgs>
    assignment?: boolean | StreamItem$assignmentArgs<ExtArgs>
    attachments?: boolean | StreamItem$attachmentsArgs<ExtArgs>
    material?: boolean | StreamItem$materialArgs<ExtArgs>
    quiz?: boolean | StreamItem$quizArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | StreamItem$classArgs<ExtArgs>
    topic?: boolean | StreamItem$topicArgs<ExtArgs>
    _count?: boolean | StreamItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streamItem"]>

  export type StreamItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isArchived?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | StreamItem$classArgs<ExtArgs>
    topic?: boolean | StreamItem$topicArgs<ExtArgs>
  }, ExtArgs["result"]["streamItem"]>

  export type StreamItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isArchived?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | StreamItem$classArgs<ExtArgs>
    topic?: boolean | StreamItem$topicArgs<ExtArgs>
  }, ExtArgs["result"]["streamItem"]>

  export type StreamItemSelectScalar = {
    id?: boolean
    classId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isArchived?: boolean
  }

  export type StreamItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "type" | "title" | "content" | "authorId" | "topicId" | "createdAt" | "updatedAt" | "isArchived", ExtArgs["result"]["streamItem"]>
  export type StreamItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcementStudents?: boolean | StreamItem$announcementStudentsArgs<ExtArgs>
    assignment?: boolean | StreamItem$assignmentArgs<ExtArgs>
    attachments?: boolean | StreamItem$attachmentsArgs<ExtArgs>
    material?: boolean | StreamItem$materialArgs<ExtArgs>
    quiz?: boolean | StreamItem$quizArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | StreamItem$classArgs<ExtArgs>
    topic?: boolean | StreamItem$topicArgs<ExtArgs>
    _count?: boolean | StreamItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StreamItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | StreamItem$classArgs<ExtArgs>
    topic?: boolean | StreamItem$topicArgs<ExtArgs>
  }
  export type StreamItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | StreamItem$classArgs<ExtArgs>
    topic?: boolean | StreamItem$topicArgs<ExtArgs>
  }

  export type $StreamItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StreamItem"
    objects: {
      announcementStudents: Prisma.$AnnouncementStudentPayload<ExtArgs>[]
      assignment: Prisma.$AssignmentPayload<ExtArgs> | null
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      material: Prisma.$MaterialPayload<ExtArgs> | null
      quiz: Prisma.$QuizPayload<ExtArgs> | null
      author: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs> | null
      topic: Prisma.$TopicPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string | null
      type: string
      title: string
      content: string | null
      authorId: string
      topicId: string | null
      createdAt: Date
      updatedAt: Date
      isArchived: boolean
    }, ExtArgs["result"]["streamItem"]>
    composites: {}
  }

  type StreamItemGetPayload<S extends boolean | null | undefined | StreamItemDefaultArgs> = $Result.GetResult<Prisma.$StreamItemPayload, S>

  type StreamItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StreamItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StreamItemCountAggregateInputType | true
    }

  export interface StreamItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StreamItem'], meta: { name: 'StreamItem' } }
    /**
     * Find zero or one StreamItem that matches the filter.
     * @param {StreamItemFindUniqueArgs} args - Arguments to find a StreamItem
     * @example
     * // Get one StreamItem
     * const streamItem = await prisma.streamItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StreamItemFindUniqueArgs>(args: SelectSubset<T, StreamItemFindUniqueArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StreamItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StreamItemFindUniqueOrThrowArgs} args - Arguments to find a StreamItem
     * @example
     * // Get one StreamItem
     * const streamItem = await prisma.streamItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StreamItemFindUniqueOrThrowArgs>(args: SelectSubset<T, StreamItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StreamItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamItemFindFirstArgs} args - Arguments to find a StreamItem
     * @example
     * // Get one StreamItem
     * const streamItem = await prisma.streamItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StreamItemFindFirstArgs>(args?: SelectSubset<T, StreamItemFindFirstArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StreamItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamItemFindFirstOrThrowArgs} args - Arguments to find a StreamItem
     * @example
     * // Get one StreamItem
     * const streamItem = await prisma.streamItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StreamItemFindFirstOrThrowArgs>(args?: SelectSubset<T, StreamItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StreamItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StreamItems
     * const streamItems = await prisma.streamItem.findMany()
     * 
     * // Get first 10 StreamItems
     * const streamItems = await prisma.streamItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const streamItemWithIdOnly = await prisma.streamItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StreamItemFindManyArgs>(args?: SelectSubset<T, StreamItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StreamItem.
     * @param {StreamItemCreateArgs} args - Arguments to create a StreamItem.
     * @example
     * // Create one StreamItem
     * const StreamItem = await prisma.streamItem.create({
     *   data: {
     *     // ... data to create a StreamItem
     *   }
     * })
     * 
     */
    create<T extends StreamItemCreateArgs>(args: SelectSubset<T, StreamItemCreateArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StreamItems.
     * @param {StreamItemCreateManyArgs} args - Arguments to create many StreamItems.
     * @example
     * // Create many StreamItems
     * const streamItem = await prisma.streamItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StreamItemCreateManyArgs>(args?: SelectSubset<T, StreamItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StreamItems and returns the data saved in the database.
     * @param {StreamItemCreateManyAndReturnArgs} args - Arguments to create many StreamItems.
     * @example
     * // Create many StreamItems
     * const streamItem = await prisma.streamItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StreamItems and only return the `id`
     * const streamItemWithIdOnly = await prisma.streamItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StreamItemCreateManyAndReturnArgs>(args?: SelectSubset<T, StreamItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StreamItem.
     * @param {StreamItemDeleteArgs} args - Arguments to delete one StreamItem.
     * @example
     * // Delete one StreamItem
     * const StreamItem = await prisma.streamItem.delete({
     *   where: {
     *     // ... filter to delete one StreamItem
     *   }
     * })
     * 
     */
    delete<T extends StreamItemDeleteArgs>(args: SelectSubset<T, StreamItemDeleteArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StreamItem.
     * @param {StreamItemUpdateArgs} args - Arguments to update one StreamItem.
     * @example
     * // Update one StreamItem
     * const streamItem = await prisma.streamItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StreamItemUpdateArgs>(args: SelectSubset<T, StreamItemUpdateArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StreamItems.
     * @param {StreamItemDeleteManyArgs} args - Arguments to filter StreamItems to delete.
     * @example
     * // Delete a few StreamItems
     * const { count } = await prisma.streamItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StreamItemDeleteManyArgs>(args?: SelectSubset<T, StreamItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StreamItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StreamItems
     * const streamItem = await prisma.streamItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StreamItemUpdateManyArgs>(args: SelectSubset<T, StreamItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StreamItems and returns the data updated in the database.
     * @param {StreamItemUpdateManyAndReturnArgs} args - Arguments to update many StreamItems.
     * @example
     * // Update many StreamItems
     * const streamItem = await prisma.streamItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StreamItems and only return the `id`
     * const streamItemWithIdOnly = await prisma.streamItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StreamItemUpdateManyAndReturnArgs>(args: SelectSubset<T, StreamItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StreamItem.
     * @param {StreamItemUpsertArgs} args - Arguments to update or create a StreamItem.
     * @example
     * // Update or create a StreamItem
     * const streamItem = await prisma.streamItem.upsert({
     *   create: {
     *     // ... data to create a StreamItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StreamItem we want to update
     *   }
     * })
     */
    upsert<T extends StreamItemUpsertArgs>(args: SelectSubset<T, StreamItemUpsertArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StreamItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamItemCountArgs} args - Arguments to filter StreamItems to count.
     * @example
     * // Count the number of StreamItems
     * const count = await prisma.streamItem.count({
     *   where: {
     *     // ... the filter for the StreamItems we want to count
     *   }
     * })
    **/
    count<T extends StreamItemCountArgs>(
      args?: Subset<T, StreamItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StreamItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StreamItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StreamItemAggregateArgs>(args: Subset<T, StreamItemAggregateArgs>): Prisma.PrismaPromise<GetStreamItemAggregateType<T>>

    /**
     * Group by StreamItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StreamItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StreamItemGroupByArgs['orderBy'] }
        : { orderBy?: StreamItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StreamItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStreamItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StreamItem model
   */
  readonly fields: StreamItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StreamItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StreamItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    announcementStudents<T extends StreamItem$announcementStudentsArgs<ExtArgs> = {}>(args?: Subset<T, StreamItem$announcementStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignment<T extends StreamItem$assignmentArgs<ExtArgs> = {}>(args?: Subset<T, StreamItem$assignmentArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attachments<T extends StreamItem$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, StreamItem$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    material<T extends StreamItem$materialArgs<ExtArgs> = {}>(args?: Subset<T, StreamItem$materialArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quiz<T extends StreamItem$quizArgs<ExtArgs> = {}>(args?: Subset<T, StreamItem$quizArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends StreamItem$classArgs<ExtArgs> = {}>(args?: Subset<T, StreamItem$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    topic<T extends StreamItem$topicArgs<ExtArgs> = {}>(args?: Subset<T, StreamItem$topicArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StreamItem model
   */
  interface StreamItemFieldRefs {
    readonly id: FieldRef<"StreamItem", 'String'>
    readonly classId: FieldRef<"StreamItem", 'String'>
    readonly type: FieldRef<"StreamItem", 'String'>
    readonly title: FieldRef<"StreamItem", 'String'>
    readonly content: FieldRef<"StreamItem", 'String'>
    readonly authorId: FieldRef<"StreamItem", 'String'>
    readonly topicId: FieldRef<"StreamItem", 'String'>
    readonly createdAt: FieldRef<"StreamItem", 'DateTime'>
    readonly updatedAt: FieldRef<"StreamItem", 'DateTime'>
    readonly isArchived: FieldRef<"StreamItem", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * StreamItem findUnique
   */
  export type StreamItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    /**
     * Filter, which StreamItem to fetch.
     */
    where: StreamItemWhereUniqueInput
  }

  /**
   * StreamItem findUniqueOrThrow
   */
  export type StreamItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    /**
     * Filter, which StreamItem to fetch.
     */
    where: StreamItemWhereUniqueInput
  }

  /**
   * StreamItem findFirst
   */
  export type StreamItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    /**
     * Filter, which StreamItem to fetch.
     */
    where?: StreamItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreamItems to fetch.
     */
    orderBy?: StreamItemOrderByWithRelationInput | StreamItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StreamItems.
     */
    cursor?: StreamItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreamItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreamItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StreamItems.
     */
    distinct?: StreamItemScalarFieldEnum | StreamItemScalarFieldEnum[]
  }

  /**
   * StreamItem findFirstOrThrow
   */
  export type StreamItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    /**
     * Filter, which StreamItem to fetch.
     */
    where?: StreamItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreamItems to fetch.
     */
    orderBy?: StreamItemOrderByWithRelationInput | StreamItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StreamItems.
     */
    cursor?: StreamItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreamItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreamItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StreamItems.
     */
    distinct?: StreamItemScalarFieldEnum | StreamItemScalarFieldEnum[]
  }

  /**
   * StreamItem findMany
   */
  export type StreamItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    /**
     * Filter, which StreamItems to fetch.
     */
    where?: StreamItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreamItems to fetch.
     */
    orderBy?: StreamItemOrderByWithRelationInput | StreamItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StreamItems.
     */
    cursor?: StreamItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreamItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreamItems.
     */
    skip?: number
    distinct?: StreamItemScalarFieldEnum | StreamItemScalarFieldEnum[]
  }

  /**
   * StreamItem create
   */
  export type StreamItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    /**
     * The data needed to create a StreamItem.
     */
    data: XOR<StreamItemCreateInput, StreamItemUncheckedCreateInput>
  }

  /**
   * StreamItem createMany
   */
  export type StreamItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StreamItems.
     */
    data: StreamItemCreateManyInput | StreamItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StreamItem createManyAndReturn
   */
  export type StreamItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * The data used to create many StreamItems.
     */
    data: StreamItemCreateManyInput | StreamItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StreamItem update
   */
  export type StreamItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    /**
     * The data needed to update a StreamItem.
     */
    data: XOR<StreamItemUpdateInput, StreamItemUncheckedUpdateInput>
    /**
     * Choose, which StreamItem to update.
     */
    where: StreamItemWhereUniqueInput
  }

  /**
   * StreamItem updateMany
   */
  export type StreamItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StreamItems.
     */
    data: XOR<StreamItemUpdateManyMutationInput, StreamItemUncheckedUpdateManyInput>
    /**
     * Filter which StreamItems to update
     */
    where?: StreamItemWhereInput
    /**
     * Limit how many StreamItems to update.
     */
    limit?: number
  }

  /**
   * StreamItem updateManyAndReturn
   */
  export type StreamItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * The data used to update StreamItems.
     */
    data: XOR<StreamItemUpdateManyMutationInput, StreamItemUncheckedUpdateManyInput>
    /**
     * Filter which StreamItems to update
     */
    where?: StreamItemWhereInput
    /**
     * Limit how many StreamItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StreamItem upsert
   */
  export type StreamItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    /**
     * The filter to search for the StreamItem to update in case it exists.
     */
    where: StreamItemWhereUniqueInput
    /**
     * In case the StreamItem found by the `where` argument doesn't exist, create a new StreamItem with this data.
     */
    create: XOR<StreamItemCreateInput, StreamItemUncheckedCreateInput>
    /**
     * In case the StreamItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StreamItemUpdateInput, StreamItemUncheckedUpdateInput>
  }

  /**
   * StreamItem delete
   */
  export type StreamItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
    /**
     * Filter which StreamItem to delete.
     */
    where: StreamItemWhereUniqueInput
  }

  /**
   * StreamItem deleteMany
   */
  export type StreamItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StreamItems to delete
     */
    where?: StreamItemWhereInput
    /**
     * Limit how many StreamItems to delete.
     */
    limit?: number
  }

  /**
   * StreamItem.announcementStudents
   */
  export type StreamItem$announcementStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    where?: AnnouncementStudentWhereInput
    orderBy?: AnnouncementStudentOrderByWithRelationInput | AnnouncementStudentOrderByWithRelationInput[]
    cursor?: AnnouncementStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementStudentScalarFieldEnum | AnnouncementStudentScalarFieldEnum[]
  }

  /**
   * StreamItem.assignment
   */
  export type StreamItem$assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
  }

  /**
   * StreamItem.attachments
   */
  export type StreamItem$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * StreamItem.material
   */
  export type StreamItem$materialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
  }

  /**
   * StreamItem.quiz
   */
  export type StreamItem$quizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
  }

  /**
   * StreamItem.class
   */
  export type StreamItem$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * StreamItem.topic
   */
  export type StreamItem$topicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
  }

  /**
   * StreamItem without action
   */
  export type StreamItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamItem
     */
    select?: StreamItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreamItem
     */
    omit?: StreamItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamItemInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    points: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    points: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: string | null
    streamItemId: string | null
    points: number | null
    dueDate: Date | null
    dueTime: Date | null
    instructions: string | null
    assignToAll: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    isDeleted: boolean | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: string | null
    streamItemId: string | null
    points: number | null
    dueDate: Date | null
    dueTime: Date | null
    instructions: string | null
    assignToAll: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    isDeleted: boolean | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    streamItemId: number
    points: number
    dueDate: number
    dueTime: number
    instructions: number
    assignToAll: number
    createdAt: number
    updatedAt: number
    assignedGroups: number
    deletedAt: number
    isDeleted: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    points?: true
  }

  export type AssignmentSumAggregateInputType = {
    points?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    streamItemId?: true
    points?: true
    dueDate?: true
    dueTime?: true
    instructions?: true
    assignToAll?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isDeleted?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    streamItemId?: true
    points?: true
    dueDate?: true
    dueTime?: true
    instructions?: true
    assignToAll?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isDeleted?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    streamItemId?: true
    points?: true
    dueDate?: true
    dueTime?: true
    instructions?: true
    assignToAll?: true
    createdAt?: true
    updatedAt?: true
    assignedGroups?: true
    deletedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: string
    streamItemId: string
    points: number | null
    dueDate: Date | null
    dueTime: Date | null
    instructions: string | null
    assignToAll: boolean
    createdAt: Date
    updatedAt: Date
    assignedGroups: string[]
    deletedAt: Date | null
    isDeleted: boolean
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    points?: boolean
    dueDate?: boolean
    dueTime?: boolean
    instructions?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    assignmentStudents?: boolean | Assignment$assignmentStudentsArgs<ExtArgs>
    assignmentSubmissions?: boolean | Assignment$assignmentSubmissionsArgs<ExtArgs>
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    grades?: boolean | Assignment$gradesArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    points?: boolean
    dueDate?: boolean
    dueTime?: boolean
    instructions?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    points?: boolean
    dueDate?: boolean
    dueTime?: boolean
    instructions?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectScalar = {
    id?: boolean
    streamItemId?: boolean
    points?: boolean
    dueDate?: boolean
    dueTime?: boolean
    instructions?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
  }

  export type AssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "streamItemId" | "points" | "dueDate" | "dueTime" | "instructions" | "assignToAll" | "createdAt" | "updatedAt" | "assignedGroups" | "deletedAt" | "isDeleted", ExtArgs["result"]["assignment"]>
  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignmentStudents?: boolean | Assignment$assignmentStudentsArgs<ExtArgs>
    assignmentSubmissions?: boolean | Assignment$assignmentSubmissionsArgs<ExtArgs>
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    grades?: boolean | Assignment$gradesArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      assignmentStudents: Prisma.$AssignmentStudentPayload<ExtArgs>[]
      assignmentSubmissions: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
      streamItem: Prisma.$StreamItemPayload<ExtArgs>
      grades: Prisma.$GradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      streamItemId: string
      points: number | null
      dueDate: Date | null
      dueTime: Date | null
      instructions: string | null
      assignToAll: boolean
      createdAt: Date
      updatedAt: Date
      assignedGroups: string[]
      deletedAt: Date | null
      isDeleted: boolean
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {AssignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments and returns the data updated in the database.
     * @param {AssignmentUpdateManyAndReturnArgs} args - Arguments to update many Assignments.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignmentStudents<T extends Assignment$assignmentStudentsArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$assignmentStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignmentSubmissions<T extends Assignment$assignmentSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$assignmentSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    streamItem<T extends StreamItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StreamItemDefaultArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grades<T extends Assignment$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'String'>
    readonly streamItemId: FieldRef<"Assignment", 'String'>
    readonly points: FieldRef<"Assignment", 'Int'>
    readonly dueDate: FieldRef<"Assignment", 'DateTime'>
    readonly dueTime: FieldRef<"Assignment", 'DateTime'>
    readonly instructions: FieldRef<"Assignment", 'String'>
    readonly assignToAll: FieldRef<"Assignment", 'Boolean'>
    readonly createdAt: FieldRef<"Assignment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assignment", 'DateTime'>
    readonly assignedGroups: FieldRef<"Assignment", 'String[]'>
    readonly deletedAt: FieldRef<"Assignment", 'DateTime'>
    readonly isDeleted: FieldRef<"Assignment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment createManyAndReturn
   */
  export type AssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
  }

  /**
   * Assignment updateManyAndReturn
   */
  export type AssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to delete.
     */
    limit?: number
  }

  /**
   * Assignment.assignmentStudents
   */
  export type Assignment$assignmentStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    where?: AssignmentStudentWhereInput
    orderBy?: AssignmentStudentOrderByWithRelationInput | AssignmentStudentOrderByWithRelationInput[]
    cursor?: AssignmentStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentStudentScalarFieldEnum | AssignmentStudentScalarFieldEnum[]
  }

  /**
   * Assignment.assignmentSubmissions
   */
  export type Assignment$assignmentSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * Assignment.grades
   */
  export type Assignment$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model AssignmentStudent
   */

  export type AggregateAssignmentStudent = {
    _count: AssignmentStudentCountAggregateOutputType | null
    _min: AssignmentStudentMinAggregateOutputType | null
    _max: AssignmentStudentMaxAggregateOutputType | null
  }

  export type AssignmentStudentMinAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    studentId: string | null
  }

  export type AssignmentStudentMaxAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    studentId: string | null
  }

  export type AssignmentStudentCountAggregateOutputType = {
    id: number
    assignmentId: number
    studentId: number
    _all: number
  }


  export type AssignmentStudentMinAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
  }

  export type AssignmentStudentMaxAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
  }

  export type AssignmentStudentCountAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    _all?: true
  }

  export type AssignmentStudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentStudent to aggregate.
     */
    where?: AssignmentStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentStudents to fetch.
     */
    orderBy?: AssignmentStudentOrderByWithRelationInput | AssignmentStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssignmentStudents
    **/
    _count?: true | AssignmentStudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentStudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentStudentMaxAggregateInputType
  }

  export type GetAssignmentStudentAggregateType<T extends AssignmentStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignmentStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignmentStudent[P]>
      : GetScalarType<T[P], AggregateAssignmentStudent[P]>
  }




  export type AssignmentStudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentStudentWhereInput
    orderBy?: AssignmentStudentOrderByWithAggregationInput | AssignmentStudentOrderByWithAggregationInput[]
    by: AssignmentStudentScalarFieldEnum[] | AssignmentStudentScalarFieldEnum
    having?: AssignmentStudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentStudentCountAggregateInputType | true
    _min?: AssignmentStudentMinAggregateInputType
    _max?: AssignmentStudentMaxAggregateInputType
  }

  export type AssignmentStudentGroupByOutputType = {
    id: string
    assignmentId: string
    studentId: string
    _count: AssignmentStudentCountAggregateOutputType | null
    _min: AssignmentStudentMinAggregateOutputType | null
    _max: AssignmentStudentMaxAggregateOutputType | null
  }

  type GetAssignmentStudentGroupByPayload<T extends AssignmentStudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentStudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentStudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentStudentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentStudentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentStudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentStudent"]>

  export type AssignmentStudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentStudent"]>

  export type AssignmentStudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentStudent"]>

  export type AssignmentStudentSelectScalar = {
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
  }

  export type AssignmentStudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assignmentId" | "studentId", ExtArgs["result"]["assignmentStudent"]>
  export type AssignmentStudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssignmentStudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssignmentStudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AssignmentStudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssignmentStudent"
    objects: {
      assignment: Prisma.$AssignmentPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assignmentId: string
      studentId: string
    }, ExtArgs["result"]["assignmentStudent"]>
    composites: {}
  }

  type AssignmentStudentGetPayload<S extends boolean | null | undefined | AssignmentStudentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentStudentPayload, S>

  type AssignmentStudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentStudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentStudentCountAggregateInputType | true
    }

  export interface AssignmentStudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssignmentStudent'], meta: { name: 'AssignmentStudent' } }
    /**
     * Find zero or one AssignmentStudent that matches the filter.
     * @param {AssignmentStudentFindUniqueArgs} args - Arguments to find a AssignmentStudent
     * @example
     * // Get one AssignmentStudent
     * const assignmentStudent = await prisma.assignmentStudent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentStudentFindUniqueArgs>(args: SelectSubset<T, AssignmentStudentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentStudentClient<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssignmentStudent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentStudentFindUniqueOrThrowArgs} args - Arguments to find a AssignmentStudent
     * @example
     * // Get one AssignmentStudent
     * const assignmentStudent = await prisma.assignmentStudent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentStudentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentStudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentStudentClient<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssignmentStudent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentStudentFindFirstArgs} args - Arguments to find a AssignmentStudent
     * @example
     * // Get one AssignmentStudent
     * const assignmentStudent = await prisma.assignmentStudent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentStudentFindFirstArgs>(args?: SelectSubset<T, AssignmentStudentFindFirstArgs<ExtArgs>>): Prisma__AssignmentStudentClient<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssignmentStudent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentStudentFindFirstOrThrowArgs} args - Arguments to find a AssignmentStudent
     * @example
     * // Get one AssignmentStudent
     * const assignmentStudent = await prisma.assignmentStudent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentStudentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentStudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentStudentClient<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssignmentStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentStudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssignmentStudents
     * const assignmentStudents = await prisma.assignmentStudent.findMany()
     * 
     * // Get first 10 AssignmentStudents
     * const assignmentStudents = await prisma.assignmentStudent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentStudentWithIdOnly = await prisma.assignmentStudent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentStudentFindManyArgs>(args?: SelectSubset<T, AssignmentStudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssignmentStudent.
     * @param {AssignmentStudentCreateArgs} args - Arguments to create a AssignmentStudent.
     * @example
     * // Create one AssignmentStudent
     * const AssignmentStudent = await prisma.assignmentStudent.create({
     *   data: {
     *     // ... data to create a AssignmentStudent
     *   }
     * })
     * 
     */
    create<T extends AssignmentStudentCreateArgs>(args: SelectSubset<T, AssignmentStudentCreateArgs<ExtArgs>>): Prisma__AssignmentStudentClient<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssignmentStudents.
     * @param {AssignmentStudentCreateManyArgs} args - Arguments to create many AssignmentStudents.
     * @example
     * // Create many AssignmentStudents
     * const assignmentStudent = await prisma.assignmentStudent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentStudentCreateManyArgs>(args?: SelectSubset<T, AssignmentStudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssignmentStudents and returns the data saved in the database.
     * @param {AssignmentStudentCreateManyAndReturnArgs} args - Arguments to create many AssignmentStudents.
     * @example
     * // Create many AssignmentStudents
     * const assignmentStudent = await prisma.assignmentStudent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssignmentStudents and only return the `id`
     * const assignmentStudentWithIdOnly = await prisma.assignmentStudent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentStudentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentStudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssignmentStudent.
     * @param {AssignmentStudentDeleteArgs} args - Arguments to delete one AssignmentStudent.
     * @example
     * // Delete one AssignmentStudent
     * const AssignmentStudent = await prisma.assignmentStudent.delete({
     *   where: {
     *     // ... filter to delete one AssignmentStudent
     *   }
     * })
     * 
     */
    delete<T extends AssignmentStudentDeleteArgs>(args: SelectSubset<T, AssignmentStudentDeleteArgs<ExtArgs>>): Prisma__AssignmentStudentClient<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssignmentStudent.
     * @param {AssignmentStudentUpdateArgs} args - Arguments to update one AssignmentStudent.
     * @example
     * // Update one AssignmentStudent
     * const assignmentStudent = await prisma.assignmentStudent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentStudentUpdateArgs>(args: SelectSubset<T, AssignmentStudentUpdateArgs<ExtArgs>>): Prisma__AssignmentStudentClient<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssignmentStudents.
     * @param {AssignmentStudentDeleteManyArgs} args - Arguments to filter AssignmentStudents to delete.
     * @example
     * // Delete a few AssignmentStudents
     * const { count } = await prisma.assignmentStudent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentStudentDeleteManyArgs>(args?: SelectSubset<T, AssignmentStudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentStudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssignmentStudents
     * const assignmentStudent = await prisma.assignmentStudent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentStudentUpdateManyArgs>(args: SelectSubset<T, AssignmentStudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentStudents and returns the data updated in the database.
     * @param {AssignmentStudentUpdateManyAndReturnArgs} args - Arguments to update many AssignmentStudents.
     * @example
     * // Update many AssignmentStudents
     * const assignmentStudent = await prisma.assignmentStudent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssignmentStudents and only return the `id`
     * const assignmentStudentWithIdOnly = await prisma.assignmentStudent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssignmentStudentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssignmentStudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssignmentStudent.
     * @param {AssignmentStudentUpsertArgs} args - Arguments to update or create a AssignmentStudent.
     * @example
     * // Update or create a AssignmentStudent
     * const assignmentStudent = await prisma.assignmentStudent.upsert({
     *   create: {
     *     // ... data to create a AssignmentStudent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssignmentStudent we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentStudentUpsertArgs>(args: SelectSubset<T, AssignmentStudentUpsertArgs<ExtArgs>>): Prisma__AssignmentStudentClient<$Result.GetResult<Prisma.$AssignmentStudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssignmentStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentStudentCountArgs} args - Arguments to filter AssignmentStudents to count.
     * @example
     * // Count the number of AssignmentStudents
     * const count = await prisma.assignmentStudent.count({
     *   where: {
     *     // ... the filter for the AssignmentStudents we want to count
     *   }
     * })
    **/
    count<T extends AssignmentStudentCountArgs>(
      args?: Subset<T, AssignmentStudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentStudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssignmentStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentStudentAggregateArgs>(args: Subset<T, AssignmentStudentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentStudentAggregateType<T>>

    /**
     * Group by AssignmentStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentStudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentStudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentStudentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentStudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentStudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssignmentStudent model
   */
  readonly fields: AssignmentStudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssignmentStudent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentStudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends AssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssignmentDefaultArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssignmentStudent model
   */
  interface AssignmentStudentFieldRefs {
    readonly id: FieldRef<"AssignmentStudent", 'String'>
    readonly assignmentId: FieldRef<"AssignmentStudent", 'String'>
    readonly studentId: FieldRef<"AssignmentStudent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AssignmentStudent findUnique
   */
  export type AssignmentStudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentStudent to fetch.
     */
    where: AssignmentStudentWhereUniqueInput
  }

  /**
   * AssignmentStudent findUniqueOrThrow
   */
  export type AssignmentStudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentStudent to fetch.
     */
    where: AssignmentStudentWhereUniqueInput
  }

  /**
   * AssignmentStudent findFirst
   */
  export type AssignmentStudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentStudent to fetch.
     */
    where?: AssignmentStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentStudents to fetch.
     */
    orderBy?: AssignmentStudentOrderByWithRelationInput | AssignmentStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentStudents.
     */
    cursor?: AssignmentStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentStudents.
     */
    distinct?: AssignmentStudentScalarFieldEnum | AssignmentStudentScalarFieldEnum[]
  }

  /**
   * AssignmentStudent findFirstOrThrow
   */
  export type AssignmentStudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentStudent to fetch.
     */
    where?: AssignmentStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentStudents to fetch.
     */
    orderBy?: AssignmentStudentOrderByWithRelationInput | AssignmentStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentStudents.
     */
    cursor?: AssignmentStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentStudents.
     */
    distinct?: AssignmentStudentScalarFieldEnum | AssignmentStudentScalarFieldEnum[]
  }

  /**
   * AssignmentStudent findMany
   */
  export type AssignmentStudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentStudents to fetch.
     */
    where?: AssignmentStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentStudents to fetch.
     */
    orderBy?: AssignmentStudentOrderByWithRelationInput | AssignmentStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssignmentStudents.
     */
    cursor?: AssignmentStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentStudents.
     */
    skip?: number
    distinct?: AssignmentStudentScalarFieldEnum | AssignmentStudentScalarFieldEnum[]
  }

  /**
   * AssignmentStudent create
   */
  export type AssignmentStudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    /**
     * The data needed to create a AssignmentStudent.
     */
    data: XOR<AssignmentStudentCreateInput, AssignmentStudentUncheckedCreateInput>
  }

  /**
   * AssignmentStudent createMany
   */
  export type AssignmentStudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssignmentStudents.
     */
    data: AssignmentStudentCreateManyInput | AssignmentStudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssignmentStudent createManyAndReturn
   */
  export type AssignmentStudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * The data used to create many AssignmentStudents.
     */
    data: AssignmentStudentCreateManyInput | AssignmentStudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentStudent update
   */
  export type AssignmentStudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    /**
     * The data needed to update a AssignmentStudent.
     */
    data: XOR<AssignmentStudentUpdateInput, AssignmentStudentUncheckedUpdateInput>
    /**
     * Choose, which AssignmentStudent to update.
     */
    where: AssignmentStudentWhereUniqueInput
  }

  /**
   * AssignmentStudent updateMany
   */
  export type AssignmentStudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssignmentStudents.
     */
    data: XOR<AssignmentStudentUpdateManyMutationInput, AssignmentStudentUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentStudents to update
     */
    where?: AssignmentStudentWhereInput
    /**
     * Limit how many AssignmentStudents to update.
     */
    limit?: number
  }

  /**
   * AssignmentStudent updateManyAndReturn
   */
  export type AssignmentStudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * The data used to update AssignmentStudents.
     */
    data: XOR<AssignmentStudentUpdateManyMutationInput, AssignmentStudentUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentStudents to update
     */
    where?: AssignmentStudentWhereInput
    /**
     * Limit how many AssignmentStudents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentStudent upsert
   */
  export type AssignmentStudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    /**
     * The filter to search for the AssignmentStudent to update in case it exists.
     */
    where: AssignmentStudentWhereUniqueInput
    /**
     * In case the AssignmentStudent found by the `where` argument doesn't exist, create a new AssignmentStudent with this data.
     */
    create: XOR<AssignmentStudentCreateInput, AssignmentStudentUncheckedCreateInput>
    /**
     * In case the AssignmentStudent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentStudentUpdateInput, AssignmentStudentUncheckedUpdateInput>
  }

  /**
   * AssignmentStudent delete
   */
  export type AssignmentStudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
    /**
     * Filter which AssignmentStudent to delete.
     */
    where: AssignmentStudentWhereUniqueInput
  }

  /**
   * AssignmentStudent deleteMany
   */
  export type AssignmentStudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentStudents to delete
     */
    where?: AssignmentStudentWhereInput
    /**
     * Limit how many AssignmentStudents to delete.
     */
    limit?: number
  }

  /**
   * AssignmentStudent without action
   */
  export type AssignmentStudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentStudent
     */
    select?: AssignmentStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentStudent
     */
    omit?: AssignmentStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentStudentInclude<ExtArgs> | null
  }


  /**
   * Model AssignmentSubmission
   */

  export type AggregateAssignmentSubmission = {
    _count: AssignmentSubmissionCountAggregateOutputType | null
    _avg: AssignmentSubmissionAvgAggregateOutputType | null
    _sum: AssignmentSubmissionSumAggregateOutputType | null
    _min: AssignmentSubmissionMinAggregateOutputType | null
    _max: AssignmentSubmissionMaxAggregateOutputType | null
  }

  export type AssignmentSubmissionAvgAggregateOutputType = {
    grade: Decimal | null
  }

  export type AssignmentSubmissionSumAggregateOutputType = {
    grade: Decimal | null
  }

  export type AssignmentSubmissionMinAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    studentId: string | null
    content: string | null
    status: string | null
    submittedAt: Date | null
    returnedAt: Date | null
    gradedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    grade: Decimal | null
    studentComments: string | null
    teacherComments: string | null
    reviewedAt: Date | null
  }

  export type AssignmentSubmissionMaxAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    studentId: string | null
    content: string | null
    status: string | null
    submittedAt: Date | null
    returnedAt: Date | null
    gradedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    grade: Decimal | null
    studentComments: string | null
    teacherComments: string | null
    reviewedAt: Date | null
  }

  export type AssignmentSubmissionCountAggregateOutputType = {
    id: number
    assignmentId: number
    studentId: number
    content: number
    attachments: number
    status: number
    submittedAt: number
    returnedAt: number
    gradedAt: number
    createdAt: number
    updatedAt: number
    grade: number
    studentComments: number
    teacherComments: number
    reviewedAt: number
    _all: number
  }


  export type AssignmentSubmissionAvgAggregateInputType = {
    grade?: true
  }

  export type AssignmentSubmissionSumAggregateInputType = {
    grade?: true
  }

  export type AssignmentSubmissionMinAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    content?: true
    status?: true
    submittedAt?: true
    returnedAt?: true
    gradedAt?: true
    createdAt?: true
    updatedAt?: true
    grade?: true
    studentComments?: true
    teacherComments?: true
    reviewedAt?: true
  }

  export type AssignmentSubmissionMaxAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    content?: true
    status?: true
    submittedAt?: true
    returnedAt?: true
    gradedAt?: true
    createdAt?: true
    updatedAt?: true
    grade?: true
    studentComments?: true
    teacherComments?: true
    reviewedAt?: true
  }

  export type AssignmentSubmissionCountAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    content?: true
    attachments?: true
    status?: true
    submittedAt?: true
    returnedAt?: true
    gradedAt?: true
    createdAt?: true
    updatedAt?: true
    grade?: true
    studentComments?: true
    teacherComments?: true
    reviewedAt?: true
    _all?: true
  }

  export type AssignmentSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentSubmission to aggregate.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssignmentSubmissions
    **/
    _count?: true | AssignmentSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentSubmissionMaxAggregateInputType
  }

  export type GetAssignmentSubmissionAggregateType<T extends AssignmentSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignmentSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignmentSubmission[P]>
      : GetScalarType<T[P], AggregateAssignmentSubmission[P]>
  }




  export type AssignmentSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithAggregationInput | AssignmentSubmissionOrderByWithAggregationInput[]
    by: AssignmentSubmissionScalarFieldEnum[] | AssignmentSubmissionScalarFieldEnum
    having?: AssignmentSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentSubmissionCountAggregateInputType | true
    _avg?: AssignmentSubmissionAvgAggregateInputType
    _sum?: AssignmentSubmissionSumAggregateInputType
    _min?: AssignmentSubmissionMinAggregateInputType
    _max?: AssignmentSubmissionMaxAggregateInputType
  }

  export type AssignmentSubmissionGroupByOutputType = {
    id: string
    assignmentId: string
    studentId: string
    content: string | null
    attachments: JsonValue | null
    status: string
    submittedAt: Date | null
    returnedAt: Date | null
    gradedAt: Date | null
    createdAt: Date
    updatedAt: Date
    grade: Decimal | null
    studentComments: string | null
    teacherComments: string | null
    reviewedAt: Date | null
    _count: AssignmentSubmissionCountAggregateOutputType | null
    _avg: AssignmentSubmissionAvgAggregateOutputType | null
    _sum: AssignmentSubmissionSumAggregateOutputType | null
    _min: AssignmentSubmissionMinAggregateOutputType | null
    _max: AssignmentSubmissionMaxAggregateOutputType | null
  }

  type GetAssignmentSubmissionGroupByPayload<T extends AssignmentSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    content?: boolean
    attachments?: boolean
    status?: boolean
    submittedAt?: boolean
    returnedAt?: boolean
    gradedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grade?: boolean
    studentComments?: boolean
    teacherComments?: boolean
    reviewedAt?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    content?: boolean
    attachments?: boolean
    status?: boolean
    submittedAt?: boolean
    returnedAt?: boolean
    gradedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grade?: boolean
    studentComments?: boolean
    teacherComments?: boolean
    reviewedAt?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    content?: boolean
    attachments?: boolean
    status?: boolean
    submittedAt?: boolean
    returnedAt?: boolean
    gradedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grade?: boolean
    studentComments?: boolean
    teacherComments?: boolean
    reviewedAt?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectScalar = {
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    content?: boolean
    attachments?: boolean
    status?: boolean
    submittedAt?: boolean
    returnedAt?: boolean
    gradedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grade?: boolean
    studentComments?: boolean
    teacherComments?: boolean
    reviewedAt?: boolean
  }

  export type AssignmentSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assignmentId" | "studentId" | "content" | "attachments" | "status" | "submittedAt" | "returnedAt" | "gradedAt" | "createdAt" | "updatedAt" | "grade" | "studentComments" | "teacherComments" | "reviewedAt", ExtArgs["result"]["assignmentSubmission"]>
  export type AssignmentSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssignmentSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssignmentSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AssignmentSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssignmentSubmission"
    objects: {
      assignment: Prisma.$AssignmentPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assignmentId: string
      studentId: string
      content: string | null
      attachments: Prisma.JsonValue | null
      status: string
      submittedAt: Date | null
      returnedAt: Date | null
      gradedAt: Date | null
      createdAt: Date
      updatedAt: Date
      grade: Prisma.Decimal | null
      studentComments: string | null
      teacherComments: string | null
      reviewedAt: Date | null
    }, ExtArgs["result"]["assignmentSubmission"]>
    composites: {}
  }

  type AssignmentSubmissionGetPayload<S extends boolean | null | undefined | AssignmentSubmissionDefaultArgs> = $Result.GetResult<Prisma.$AssignmentSubmissionPayload, S>

  type AssignmentSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentSubmissionCountAggregateInputType | true
    }

  export interface AssignmentSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssignmentSubmission'], meta: { name: 'AssignmentSubmission' } }
    /**
     * Find zero or one AssignmentSubmission that matches the filter.
     * @param {AssignmentSubmissionFindUniqueArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentSubmissionFindUniqueArgs>(args: SelectSubset<T, AssignmentSubmissionFindUniqueArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssignmentSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentSubmissionFindUniqueOrThrowArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssignmentSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindFirstArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentSubmissionFindFirstArgs>(args?: SelectSubset<T, AssignmentSubmissionFindFirstArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssignmentSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindFirstOrThrowArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssignmentSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssignmentSubmissions
     * const assignmentSubmissions = await prisma.assignmentSubmission.findMany()
     * 
     * // Get first 10 AssignmentSubmissions
     * const assignmentSubmissions = await prisma.assignmentSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentSubmissionFindManyArgs>(args?: SelectSubset<T, AssignmentSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssignmentSubmission.
     * @param {AssignmentSubmissionCreateArgs} args - Arguments to create a AssignmentSubmission.
     * @example
     * // Create one AssignmentSubmission
     * const AssignmentSubmission = await prisma.assignmentSubmission.create({
     *   data: {
     *     // ... data to create a AssignmentSubmission
     *   }
     * })
     * 
     */
    create<T extends AssignmentSubmissionCreateArgs>(args: SelectSubset<T, AssignmentSubmissionCreateArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssignmentSubmissions.
     * @param {AssignmentSubmissionCreateManyArgs} args - Arguments to create many AssignmentSubmissions.
     * @example
     * // Create many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentSubmissionCreateManyArgs>(args?: SelectSubset<T, AssignmentSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssignmentSubmissions and returns the data saved in the database.
     * @param {AssignmentSubmissionCreateManyAndReturnArgs} args - Arguments to create many AssignmentSubmissions.
     * @example
     * // Create many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssignmentSubmissions and only return the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssignmentSubmission.
     * @param {AssignmentSubmissionDeleteArgs} args - Arguments to delete one AssignmentSubmission.
     * @example
     * // Delete one AssignmentSubmission
     * const AssignmentSubmission = await prisma.assignmentSubmission.delete({
     *   where: {
     *     // ... filter to delete one AssignmentSubmission
     *   }
     * })
     * 
     */
    delete<T extends AssignmentSubmissionDeleteArgs>(args: SelectSubset<T, AssignmentSubmissionDeleteArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssignmentSubmission.
     * @param {AssignmentSubmissionUpdateArgs} args - Arguments to update one AssignmentSubmission.
     * @example
     * // Update one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentSubmissionUpdateArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssignmentSubmissions.
     * @param {AssignmentSubmissionDeleteManyArgs} args - Arguments to filter AssignmentSubmissions to delete.
     * @example
     * // Delete a few AssignmentSubmissions
     * const { count } = await prisma.assignmentSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentSubmissionDeleteManyArgs>(args?: SelectSubset<T, AssignmentSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentSubmissionUpdateManyArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentSubmissions and returns the data updated in the database.
     * @param {AssignmentSubmissionUpdateManyAndReturnArgs} args - Arguments to update many AssignmentSubmissions.
     * @example
     * // Update many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssignmentSubmissions and only return the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssignmentSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssignmentSubmission.
     * @param {AssignmentSubmissionUpsertArgs} args - Arguments to update or create a AssignmentSubmission.
     * @example
     * // Update or create a AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.upsert({
     *   create: {
     *     // ... data to create a AssignmentSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssignmentSubmission we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentSubmissionUpsertArgs>(args: SelectSubset<T, AssignmentSubmissionUpsertArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssignmentSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionCountArgs} args - Arguments to filter AssignmentSubmissions to count.
     * @example
     * // Count the number of AssignmentSubmissions
     * const count = await prisma.assignmentSubmission.count({
     *   where: {
     *     // ... the filter for the AssignmentSubmissions we want to count
     *   }
     * })
    **/
    count<T extends AssignmentSubmissionCountArgs>(
      args?: Subset<T, AssignmentSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssignmentSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentSubmissionAggregateArgs>(args: Subset<T, AssignmentSubmissionAggregateArgs>): Prisma.PrismaPromise<GetAssignmentSubmissionAggregateType<T>>

    /**
     * Group by AssignmentSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssignmentSubmission model
   */
  readonly fields: AssignmentSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssignmentSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends AssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssignmentDefaultArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssignmentSubmission model
   */
  interface AssignmentSubmissionFieldRefs {
    readonly id: FieldRef<"AssignmentSubmission", 'String'>
    readonly assignmentId: FieldRef<"AssignmentSubmission", 'String'>
    readonly studentId: FieldRef<"AssignmentSubmission", 'String'>
    readonly content: FieldRef<"AssignmentSubmission", 'String'>
    readonly attachments: FieldRef<"AssignmentSubmission", 'Json'>
    readonly status: FieldRef<"AssignmentSubmission", 'String'>
    readonly submittedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly returnedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly gradedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly createdAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly grade: FieldRef<"AssignmentSubmission", 'Decimal'>
    readonly studentComments: FieldRef<"AssignmentSubmission", 'String'>
    readonly teacherComments: FieldRef<"AssignmentSubmission", 'String'>
    readonly reviewedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssignmentSubmission findUnique
   */
  export type AssignmentSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission findUniqueOrThrow
   */
  export type AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission findFirst
   */
  export type AssignmentSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentSubmissions.
     */
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission findFirstOrThrow
   */
  export type AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentSubmissions.
     */
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission findMany
   */
  export type AssignmentSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmissions to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission create
   */
  export type AssignmentSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AssignmentSubmission.
     */
    data: XOR<AssignmentSubmissionCreateInput, AssignmentSubmissionUncheckedCreateInput>
  }

  /**
   * AssignmentSubmission createMany
   */
  export type AssignmentSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssignmentSubmissions.
     */
    data: AssignmentSubmissionCreateManyInput | AssignmentSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssignmentSubmission createManyAndReturn
   */
  export type AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many AssignmentSubmissions.
     */
    data: AssignmentSubmissionCreateManyInput | AssignmentSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentSubmission update
   */
  export type AssignmentSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AssignmentSubmission.
     */
    data: XOR<AssignmentSubmissionUpdateInput, AssignmentSubmissionUncheckedUpdateInput>
    /**
     * Choose, which AssignmentSubmission to update.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission updateMany
   */
  export type AssignmentSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssignmentSubmissions.
     */
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentSubmissions to update
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * Limit how many AssignmentSubmissions to update.
     */
    limit?: number
  }

  /**
   * AssignmentSubmission updateManyAndReturn
   */
  export type AssignmentSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update AssignmentSubmissions.
     */
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentSubmissions to update
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * Limit how many AssignmentSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentSubmission upsert
   */
  export type AssignmentSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AssignmentSubmission to update in case it exists.
     */
    where: AssignmentSubmissionWhereUniqueInput
    /**
     * In case the AssignmentSubmission found by the `where` argument doesn't exist, create a new AssignmentSubmission with this data.
     */
    create: XOR<AssignmentSubmissionCreateInput, AssignmentSubmissionUncheckedCreateInput>
    /**
     * In case the AssignmentSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentSubmissionUpdateInput, AssignmentSubmissionUncheckedUpdateInput>
  }

  /**
   * AssignmentSubmission delete
   */
  export type AssignmentSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter which AssignmentSubmission to delete.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission deleteMany
   */
  export type AssignmentSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentSubmissions to delete
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * Limit how many AssignmentSubmissions to delete.
     */
    limit?: number
  }

  /**
   * AssignmentSubmission without action
   */
  export type AssignmentSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    points: number | null
  }

  export type QuizSumAggregateOutputType = {
    points: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: string | null
    streamItemId: string | null
    points: number | null
    dueDate: Date | null
    dueTime: Date | null
    description: string | null
    assignToAll: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizMaxAggregateOutputType = {
    id: string | null
    streamItemId: string | null
    points: number | null
    dueDate: Date | null
    dueTime: Date | null
    description: string | null
    assignToAll: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    streamItemId: number
    points: number
    dueDate: number
    dueTime: number
    description: number
    assignToAll: number
    createdAt: number
    updatedAt: number
    assignedGroups: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    points?: true
  }

  export type QuizSumAggregateInputType = {
    points?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    streamItemId?: true
    points?: true
    dueDate?: true
    dueTime?: true
    description?: true
    assignToAll?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    streamItemId?: true
    points?: true
    dueDate?: true
    dueTime?: true
    description?: true
    assignToAll?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    streamItemId?: true
    points?: true
    dueDate?: true
    dueTime?: true
    description?: true
    assignToAll?: true
    createdAt?: true
    updatedAt?: true
    assignedGroups?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: string
    streamItemId: string
    points: number | null
    dueDate: Date | null
    dueTime: Date | null
    description: string | null
    assignToAll: boolean
    createdAt: Date
    updatedAt: Date
    assignedGroups: string[]
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    points?: boolean
    dueDate?: boolean
    dueTime?: boolean
    description?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
    grades?: boolean | Quiz$gradesArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    quizStudents?: boolean | Quiz$quizStudentsArgs<ExtArgs>
    quizSubmissions?: boolean | Quiz$quizSubmissionsArgs<ExtArgs>
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    points?: boolean
    dueDate?: boolean
    dueTime?: boolean
    description?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    points?: boolean
    dueDate?: boolean
    dueTime?: boolean
    description?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    streamItemId?: boolean
    points?: boolean
    dueDate?: boolean
    dueTime?: boolean
    description?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
  }

  export type QuizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "streamItemId" | "points" | "dueDate" | "dueTime" | "description" | "assignToAll" | "createdAt" | "updatedAt" | "assignedGroups", ExtArgs["result"]["quiz"]>
  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grades?: boolean | Quiz$gradesArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    quizStudents?: boolean | Quiz$quizStudentsArgs<ExtArgs>
    quizSubmissions?: boolean | Quiz$quizSubmissionsArgs<ExtArgs>
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }
  export type QuizIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      grades: Prisma.$GradePayload<ExtArgs>[]
      questions: Prisma.$QuizQuestionPayload<ExtArgs>[]
      quizStudents: Prisma.$QuizStudentPayload<ExtArgs>[]
      quizSubmissions: Prisma.$QuizSubmissionPayload<ExtArgs>[]
      streamItem: Prisma.$StreamItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      streamItemId: string
      points: number | null
      dueDate: Date | null
      dueTime: Date | null
      description: string | null
      assignToAll: boolean
      createdAt: Date
      updatedAt: Date
      assignedGroups: string[]
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes and returns the data updated in the database.
     * @param {QuizUpdateManyAndReturnArgs} args - Arguments to update many Quizzes.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grades<T extends Quiz$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends Quiz$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizStudents<T extends Quiz$quizStudentsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$quizStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizSubmissions<T extends Quiz$quizSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$quizSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    streamItem<T extends StreamItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StreamItemDefaultArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'String'>
    readonly streamItemId: FieldRef<"Quiz", 'String'>
    readonly points: FieldRef<"Quiz", 'Int'>
    readonly dueDate: FieldRef<"Quiz", 'DateTime'>
    readonly dueTime: FieldRef<"Quiz", 'DateTime'>
    readonly description: FieldRef<"Quiz", 'String'>
    readonly assignToAll: FieldRef<"Quiz", 'Boolean'>
    readonly createdAt: FieldRef<"Quiz", 'DateTime'>
    readonly updatedAt: FieldRef<"Quiz", 'DateTime'>
    readonly assignedGroups: FieldRef<"Quiz", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
  }

  /**
   * Quiz updateManyAndReturn
   */
  export type QuizUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to delete.
     */
    limit?: number
  }

  /**
   * Quiz.grades
   */
  export type Quiz$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Quiz.questions
   */
  export type Quiz$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * Quiz.quizStudents
   */
  export type Quiz$quizStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    where?: QuizStudentWhereInput
    orderBy?: QuizStudentOrderByWithRelationInput | QuizStudentOrderByWithRelationInput[]
    cursor?: QuizStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizStudentScalarFieldEnum | QuizStudentScalarFieldEnum[]
  }

  /**
   * Quiz.quizSubmissions
   */
  export type Quiz$quizSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    where?: QuizSubmissionWhereInput
    orderBy?: QuizSubmissionOrderByWithRelationInput | QuizSubmissionOrderByWithRelationInput[]
    cursor?: QuizSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizSubmissionScalarFieldEnum | QuizSubmissionScalarFieldEnum[]
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestion
   */

  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionAvgAggregateOutputType = {
    points: number | null
    order: number | null
  }

  export type QuizQuestionSumAggregateOutputType = {
    points: number | null
    order: number | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: string | null
    quizId: string | null
    title: string | null
    description: string | null
    type: string | null
    required: boolean | null
    points: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: string | null
    quizId: string | null
    title: string | null
    description: string | null
    type: string | null
    required: boolean | null
    points: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    quizId: number
    title: number
    description: number
    type: number
    required: number
    points: number
    correctAnswer: number
    options: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizQuestionAvgAggregateInputType = {
    points?: true
    order?: true
  }

  export type QuizQuestionSumAggregateInputType = {
    points?: true
    order?: true
  }

  export type QuizQuestionMinAggregateInputType = {
    id?: true
    quizId?: true
    title?: true
    description?: true
    type?: true
    required?: true
    points?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    quizId?: true
    title?: true
    description?: true
    type?: true
    required?: true
    points?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    quizId?: true
    title?: true
    description?: true
    type?: true
    required?: true
    points?: true
    correctAnswer?: true
    options?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithAggregationInput | QuizQuestionOrderByWithAggregationInput[]
    by: QuizQuestionScalarFieldEnum[] | QuizQuestionScalarFieldEnum
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _avg?: QuizQuestionAvgAggregateInputType
    _sum?: QuizQuestionSumAggregateInputType
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type QuizQuestionGroupByOutputType = {
    id: string
    quizId: string
    title: string
    description: string | null
    type: string
    required: boolean
    points: number
    correctAnswer: JsonValue | null
    options: JsonValue | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    required?: boolean
    points?: boolean
    correctAnswer?: boolean
    options?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    required?: boolean
    points?: boolean
    correctAnswer?: boolean
    options?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    required?: boolean
    points?: boolean
    correctAnswer?: boolean
    options?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectScalar = {
    id?: boolean
    quizId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    required?: boolean
    points?: boolean
    correctAnswer?: boolean
    options?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuizQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "title" | "description" | "type" | "required" | "points" | "correctAnswer" | "options" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["quizQuestion"]>
  export type QuizQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestion"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quizId: string
      title: string
      description: string | null
      type: string
      required: boolean
      points: number
      correctAnswer: Prisma.JsonValue | null
      options: Prisma.JsonValue | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quizQuestion"]>
    composites: {}
  }

  type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionPayload, S>

  type QuizQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestion'], meta: { name: 'QuizQuestion' } }
    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionFindManyArgs>(args?: SelectSubset<T, QuizQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionCreateArgs>(args: SelectSubset<T, QuizQuestionCreateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestions.
     * @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestions and returns the data saved in the database.
     * @param {QuizQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionDeleteArgs>(args: SelectSubset<T, QuizQuestionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionUpdateArgs>(args: SelectSubset<T, QuizQuestionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions and returns the data updated in the database.
     * @param {QuizQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestions.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionUpsertArgs>(args: SelectSubset<T, QuizQuestionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestion model
   */
  readonly fields: QuizQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestion model
   */
  interface QuizQuestionFieldRefs {
    readonly id: FieldRef<"QuizQuestion", 'String'>
    readonly quizId: FieldRef<"QuizQuestion", 'String'>
    readonly title: FieldRef<"QuizQuestion", 'String'>
    readonly description: FieldRef<"QuizQuestion", 'String'>
    readonly type: FieldRef<"QuizQuestion", 'String'>
    readonly required: FieldRef<"QuizQuestion", 'Boolean'>
    readonly points: FieldRef<"QuizQuestion", 'Int'>
    readonly correctAnswer: FieldRef<"QuizQuestion", 'Json'>
    readonly options: FieldRef<"QuizQuestion", 'Json'>
    readonly order: FieldRef<"QuizQuestion", 'Int'>
    readonly createdAt: FieldRef<"QuizQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"QuizQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestion findUnique
   */
  export type QuizQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findFirst
   */
  export type QuizQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }

  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion createManyAndReturn
   */
  export type QuizQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
  }

  /**
   * QuizQuestion updateManyAndReturn
   */
  export type QuizQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }

  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestion without action
   */
  export type QuizQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
  }


  /**
   * Model QuizStudent
   */

  export type AggregateQuizStudent = {
    _count: QuizStudentCountAggregateOutputType | null
    _min: QuizStudentMinAggregateOutputType | null
    _max: QuizStudentMaxAggregateOutputType | null
  }

  export type QuizStudentMinAggregateOutputType = {
    id: string | null
    quizId: string | null
    studentId: string | null
  }

  export type QuizStudentMaxAggregateOutputType = {
    id: string | null
    quizId: string | null
    studentId: string | null
  }

  export type QuizStudentCountAggregateOutputType = {
    id: number
    quizId: number
    studentId: number
    _all: number
  }


  export type QuizStudentMinAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
  }

  export type QuizStudentMaxAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
  }

  export type QuizStudentCountAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
    _all?: true
  }

  export type QuizStudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizStudent to aggregate.
     */
    where?: QuizStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizStudents to fetch.
     */
    orderBy?: QuizStudentOrderByWithRelationInput | QuizStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizStudents
    **/
    _count?: true | QuizStudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizStudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizStudentMaxAggregateInputType
  }

  export type GetQuizStudentAggregateType<T extends QuizStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizStudent[P]>
      : GetScalarType<T[P], AggregateQuizStudent[P]>
  }




  export type QuizStudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizStudentWhereInput
    orderBy?: QuizStudentOrderByWithAggregationInput | QuizStudentOrderByWithAggregationInput[]
    by: QuizStudentScalarFieldEnum[] | QuizStudentScalarFieldEnum
    having?: QuizStudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizStudentCountAggregateInputType | true
    _min?: QuizStudentMinAggregateInputType
    _max?: QuizStudentMaxAggregateInputType
  }

  export type QuizStudentGroupByOutputType = {
    id: string
    quizId: string
    studentId: string
    _count: QuizStudentCountAggregateOutputType | null
    _min: QuizStudentMinAggregateOutputType | null
    _max: QuizStudentMaxAggregateOutputType | null
  }

  type GetQuizStudentGroupByPayload<T extends QuizStudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizStudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizStudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizStudentGroupByOutputType[P]>
            : GetScalarType<T[P], QuizStudentGroupByOutputType[P]>
        }
      >
    >


  export type QuizStudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizStudent"]>

  export type QuizStudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizStudent"]>

  export type QuizStudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizStudent"]>

  export type QuizStudentSelectScalar = {
    id?: boolean
    quizId?: boolean
    studentId?: boolean
  }

  export type QuizStudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "studentId", ExtArgs["result"]["quizStudent"]>
  export type QuizStudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuizStudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuizStudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuizStudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizStudent"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quizId: string
      studentId: string
    }, ExtArgs["result"]["quizStudent"]>
    composites: {}
  }

  type QuizStudentGetPayload<S extends boolean | null | undefined | QuizStudentDefaultArgs> = $Result.GetResult<Prisma.$QuizStudentPayload, S>

  type QuizStudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizStudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizStudentCountAggregateInputType | true
    }

  export interface QuizStudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizStudent'], meta: { name: 'QuizStudent' } }
    /**
     * Find zero or one QuizStudent that matches the filter.
     * @param {QuizStudentFindUniqueArgs} args - Arguments to find a QuizStudent
     * @example
     * // Get one QuizStudent
     * const quizStudent = await prisma.quizStudent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizStudentFindUniqueArgs>(args: SelectSubset<T, QuizStudentFindUniqueArgs<ExtArgs>>): Prisma__QuizStudentClient<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizStudent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizStudentFindUniqueOrThrowArgs} args - Arguments to find a QuizStudent
     * @example
     * // Get one QuizStudent
     * const quizStudent = await prisma.quizStudent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizStudentFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizStudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizStudentClient<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizStudent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizStudentFindFirstArgs} args - Arguments to find a QuizStudent
     * @example
     * // Get one QuizStudent
     * const quizStudent = await prisma.quizStudent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizStudentFindFirstArgs>(args?: SelectSubset<T, QuizStudentFindFirstArgs<ExtArgs>>): Prisma__QuizStudentClient<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizStudent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizStudentFindFirstOrThrowArgs} args - Arguments to find a QuizStudent
     * @example
     * // Get one QuizStudent
     * const quizStudent = await prisma.quizStudent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizStudentFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizStudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizStudentClient<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizStudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizStudents
     * const quizStudents = await prisma.quizStudent.findMany()
     * 
     * // Get first 10 QuizStudents
     * const quizStudents = await prisma.quizStudent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizStudentWithIdOnly = await prisma.quizStudent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizStudentFindManyArgs>(args?: SelectSubset<T, QuizStudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizStudent.
     * @param {QuizStudentCreateArgs} args - Arguments to create a QuizStudent.
     * @example
     * // Create one QuizStudent
     * const QuizStudent = await prisma.quizStudent.create({
     *   data: {
     *     // ... data to create a QuizStudent
     *   }
     * })
     * 
     */
    create<T extends QuizStudentCreateArgs>(args: SelectSubset<T, QuizStudentCreateArgs<ExtArgs>>): Prisma__QuizStudentClient<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizStudents.
     * @param {QuizStudentCreateManyArgs} args - Arguments to create many QuizStudents.
     * @example
     * // Create many QuizStudents
     * const quizStudent = await prisma.quizStudent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizStudentCreateManyArgs>(args?: SelectSubset<T, QuizStudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizStudents and returns the data saved in the database.
     * @param {QuizStudentCreateManyAndReturnArgs} args - Arguments to create many QuizStudents.
     * @example
     * // Create many QuizStudents
     * const quizStudent = await prisma.quizStudent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizStudents and only return the `id`
     * const quizStudentWithIdOnly = await prisma.quizStudent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizStudentCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizStudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizStudent.
     * @param {QuizStudentDeleteArgs} args - Arguments to delete one QuizStudent.
     * @example
     * // Delete one QuizStudent
     * const QuizStudent = await prisma.quizStudent.delete({
     *   where: {
     *     // ... filter to delete one QuizStudent
     *   }
     * })
     * 
     */
    delete<T extends QuizStudentDeleteArgs>(args: SelectSubset<T, QuizStudentDeleteArgs<ExtArgs>>): Prisma__QuizStudentClient<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizStudent.
     * @param {QuizStudentUpdateArgs} args - Arguments to update one QuizStudent.
     * @example
     * // Update one QuizStudent
     * const quizStudent = await prisma.quizStudent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizStudentUpdateArgs>(args: SelectSubset<T, QuizStudentUpdateArgs<ExtArgs>>): Prisma__QuizStudentClient<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizStudents.
     * @param {QuizStudentDeleteManyArgs} args - Arguments to filter QuizStudents to delete.
     * @example
     * // Delete a few QuizStudents
     * const { count } = await prisma.quizStudent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizStudentDeleteManyArgs>(args?: SelectSubset<T, QuizStudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizStudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizStudents
     * const quizStudent = await prisma.quizStudent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizStudentUpdateManyArgs>(args: SelectSubset<T, QuizStudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizStudents and returns the data updated in the database.
     * @param {QuizStudentUpdateManyAndReturnArgs} args - Arguments to update many QuizStudents.
     * @example
     * // Update many QuizStudents
     * const quizStudent = await prisma.quizStudent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizStudents and only return the `id`
     * const quizStudentWithIdOnly = await prisma.quizStudent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizStudentUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizStudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizStudent.
     * @param {QuizStudentUpsertArgs} args - Arguments to update or create a QuizStudent.
     * @example
     * // Update or create a QuizStudent
     * const quizStudent = await prisma.quizStudent.upsert({
     *   create: {
     *     // ... data to create a QuizStudent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizStudent we want to update
     *   }
     * })
     */
    upsert<T extends QuizStudentUpsertArgs>(args: SelectSubset<T, QuizStudentUpsertArgs<ExtArgs>>): Prisma__QuizStudentClient<$Result.GetResult<Prisma.$QuizStudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizStudentCountArgs} args - Arguments to filter QuizStudents to count.
     * @example
     * // Count the number of QuizStudents
     * const count = await prisma.quizStudent.count({
     *   where: {
     *     // ... the filter for the QuizStudents we want to count
     *   }
     * })
    **/
    count<T extends QuizStudentCountArgs>(
      args?: Subset<T, QuizStudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizStudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizStudentAggregateArgs>(args: Subset<T, QuizStudentAggregateArgs>): Prisma.PrismaPromise<GetQuizStudentAggregateType<T>>

    /**
     * Group by QuizStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizStudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizStudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizStudentGroupByArgs['orderBy'] }
        : { orderBy?: QuizStudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizStudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizStudent model
   */
  readonly fields: QuizStudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizStudent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizStudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizStudent model
   */
  interface QuizStudentFieldRefs {
    readonly id: FieldRef<"QuizStudent", 'String'>
    readonly quizId: FieldRef<"QuizStudent", 'String'>
    readonly studentId: FieldRef<"QuizStudent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuizStudent findUnique
   */
  export type QuizStudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    /**
     * Filter, which QuizStudent to fetch.
     */
    where: QuizStudentWhereUniqueInput
  }

  /**
   * QuizStudent findUniqueOrThrow
   */
  export type QuizStudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    /**
     * Filter, which QuizStudent to fetch.
     */
    where: QuizStudentWhereUniqueInput
  }

  /**
   * QuizStudent findFirst
   */
  export type QuizStudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    /**
     * Filter, which QuizStudent to fetch.
     */
    where?: QuizStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizStudents to fetch.
     */
    orderBy?: QuizStudentOrderByWithRelationInput | QuizStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizStudents.
     */
    cursor?: QuizStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizStudents.
     */
    distinct?: QuizStudentScalarFieldEnum | QuizStudentScalarFieldEnum[]
  }

  /**
   * QuizStudent findFirstOrThrow
   */
  export type QuizStudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    /**
     * Filter, which QuizStudent to fetch.
     */
    where?: QuizStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizStudents to fetch.
     */
    orderBy?: QuizStudentOrderByWithRelationInput | QuizStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizStudents.
     */
    cursor?: QuizStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizStudents.
     */
    distinct?: QuizStudentScalarFieldEnum | QuizStudentScalarFieldEnum[]
  }

  /**
   * QuizStudent findMany
   */
  export type QuizStudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    /**
     * Filter, which QuizStudents to fetch.
     */
    where?: QuizStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizStudents to fetch.
     */
    orderBy?: QuizStudentOrderByWithRelationInput | QuizStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizStudents.
     */
    cursor?: QuizStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizStudents.
     */
    skip?: number
    distinct?: QuizStudentScalarFieldEnum | QuizStudentScalarFieldEnum[]
  }

  /**
   * QuizStudent create
   */
  export type QuizStudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizStudent.
     */
    data: XOR<QuizStudentCreateInput, QuizStudentUncheckedCreateInput>
  }

  /**
   * QuizStudent createMany
   */
  export type QuizStudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizStudents.
     */
    data: QuizStudentCreateManyInput | QuizStudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizStudent createManyAndReturn
   */
  export type QuizStudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * The data used to create many QuizStudents.
     */
    data: QuizStudentCreateManyInput | QuizStudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizStudent update
   */
  export type QuizStudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizStudent.
     */
    data: XOR<QuizStudentUpdateInput, QuizStudentUncheckedUpdateInput>
    /**
     * Choose, which QuizStudent to update.
     */
    where: QuizStudentWhereUniqueInput
  }

  /**
   * QuizStudent updateMany
   */
  export type QuizStudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizStudents.
     */
    data: XOR<QuizStudentUpdateManyMutationInput, QuizStudentUncheckedUpdateManyInput>
    /**
     * Filter which QuizStudents to update
     */
    where?: QuizStudentWhereInput
    /**
     * Limit how many QuizStudents to update.
     */
    limit?: number
  }

  /**
   * QuizStudent updateManyAndReturn
   */
  export type QuizStudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * The data used to update QuizStudents.
     */
    data: XOR<QuizStudentUpdateManyMutationInput, QuizStudentUncheckedUpdateManyInput>
    /**
     * Filter which QuizStudents to update
     */
    where?: QuizStudentWhereInput
    /**
     * Limit how many QuizStudents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizStudent upsert
   */
  export type QuizStudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizStudent to update in case it exists.
     */
    where: QuizStudentWhereUniqueInput
    /**
     * In case the QuizStudent found by the `where` argument doesn't exist, create a new QuizStudent with this data.
     */
    create: XOR<QuizStudentCreateInput, QuizStudentUncheckedCreateInput>
    /**
     * In case the QuizStudent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizStudentUpdateInput, QuizStudentUncheckedUpdateInput>
  }

  /**
   * QuizStudent delete
   */
  export type QuizStudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
    /**
     * Filter which QuizStudent to delete.
     */
    where: QuizStudentWhereUniqueInput
  }

  /**
   * QuizStudent deleteMany
   */
  export type QuizStudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizStudents to delete
     */
    where?: QuizStudentWhereInput
    /**
     * Limit how many QuizStudents to delete.
     */
    limit?: number
  }

  /**
   * QuizStudent without action
   */
  export type QuizStudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizStudent
     */
    select?: QuizStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizStudent
     */
    omit?: QuizStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizStudentInclude<ExtArgs> | null
  }


  /**
   * Model QuizSubmission
   */

  export type AggregateQuizSubmission = {
    _count: QuizSubmissionCountAggregateOutputType | null
    _avg: QuizSubmissionAvgAggregateOutputType | null
    _sum: QuizSubmissionSumAggregateOutputType | null
    _min: QuizSubmissionMinAggregateOutputType | null
    _max: QuizSubmissionMaxAggregateOutputType | null
  }

  export type QuizSubmissionAvgAggregateOutputType = {
    grade: Decimal | null
  }

  export type QuizSubmissionSumAggregateOutputType = {
    grade: Decimal | null
  }

  export type QuizSubmissionMinAggregateOutputType = {
    id: string | null
    quizId: string | null
    studentId: string | null
    status: string | null
    grade: Decimal | null
    studentComments: string | null
    teacherComments: string | null
    submittedAt: Date | null
    gradedAt: Date | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizSubmissionMaxAggregateOutputType = {
    id: string | null
    quizId: string | null
    studentId: string | null
    status: string | null
    grade: Decimal | null
    studentComments: string | null
    teacherComments: string | null
    submittedAt: Date | null
    gradedAt: Date | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizSubmissionCountAggregateOutputType = {
    id: number
    quizId: number
    studentId: number
    answers: number
    status: number
    grade: number
    studentComments: number
    teacherComments: number
    submittedAt: number
    gradedAt: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizSubmissionAvgAggregateInputType = {
    grade?: true
  }

  export type QuizSubmissionSumAggregateInputType = {
    grade?: true
  }

  export type QuizSubmissionMinAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
    status?: true
    grade?: true
    studentComments?: true
    teacherComments?: true
    submittedAt?: true
    gradedAt?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizSubmissionMaxAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
    status?: true
    grade?: true
    studentComments?: true
    teacherComments?: true
    submittedAt?: true
    gradedAt?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizSubmissionCountAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
    answers?: true
    status?: true
    grade?: true
    studentComments?: true
    teacherComments?: true
    submittedAt?: true
    gradedAt?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizSubmission to aggregate.
     */
    where?: QuizSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSubmissions to fetch.
     */
    orderBy?: QuizSubmissionOrderByWithRelationInput | QuizSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizSubmissions
    **/
    _count?: true | QuizSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizSubmissionMaxAggregateInputType
  }

  export type GetQuizSubmissionAggregateType<T extends QuizSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizSubmission[P]>
      : GetScalarType<T[P], AggregateQuizSubmission[P]>
  }




  export type QuizSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSubmissionWhereInput
    orderBy?: QuizSubmissionOrderByWithAggregationInput | QuizSubmissionOrderByWithAggregationInput[]
    by: QuizSubmissionScalarFieldEnum[] | QuizSubmissionScalarFieldEnum
    having?: QuizSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizSubmissionCountAggregateInputType | true
    _avg?: QuizSubmissionAvgAggregateInputType
    _sum?: QuizSubmissionSumAggregateInputType
    _min?: QuizSubmissionMinAggregateInputType
    _max?: QuizSubmissionMaxAggregateInputType
  }

  export type QuizSubmissionGroupByOutputType = {
    id: string
    quizId: string
    studentId: string
    answers: JsonValue | null
    status: string
    grade: Decimal | null
    studentComments: string | null
    teacherComments: string | null
    submittedAt: Date | null
    gradedAt: Date | null
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: QuizSubmissionCountAggregateOutputType | null
    _avg: QuizSubmissionAvgAggregateOutputType | null
    _sum: QuizSubmissionSumAggregateOutputType | null
    _min: QuizSubmissionMinAggregateOutputType | null
    _max: QuizSubmissionMaxAggregateOutputType | null
  }

  type GetQuizSubmissionGroupByPayload<T extends QuizSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type QuizSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    answers?: boolean
    status?: boolean
    grade?: boolean
    studentComments?: boolean
    teacherComments?: boolean
    submittedAt?: boolean
    gradedAt?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSubmission"]>

  export type QuizSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    answers?: boolean
    status?: boolean
    grade?: boolean
    studentComments?: boolean
    teacherComments?: boolean
    submittedAt?: boolean
    gradedAt?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSubmission"]>

  export type QuizSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    answers?: boolean
    status?: boolean
    grade?: boolean
    studentComments?: boolean
    teacherComments?: boolean
    submittedAt?: boolean
    gradedAt?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSubmission"]>

  export type QuizSubmissionSelectScalar = {
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    answers?: boolean
    status?: boolean
    grade?: boolean
    studentComments?: boolean
    teacherComments?: boolean
    submittedAt?: boolean
    gradedAt?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuizSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "studentId" | "answers" | "status" | "grade" | "studentComments" | "teacherComments" | "submittedAt" | "gradedAt" | "reviewedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["quizSubmission"]>
  export type QuizSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuizSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuizSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuizSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizSubmission"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quizId: string
      studentId: string
      answers: Prisma.JsonValue | null
      status: string
      grade: Prisma.Decimal | null
      studentComments: string | null
      teacherComments: string | null
      submittedAt: Date | null
      gradedAt: Date | null
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quizSubmission"]>
    composites: {}
  }

  type QuizSubmissionGetPayload<S extends boolean | null | undefined | QuizSubmissionDefaultArgs> = $Result.GetResult<Prisma.$QuizSubmissionPayload, S>

  type QuizSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizSubmissionCountAggregateInputType | true
    }

  export interface QuizSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizSubmission'], meta: { name: 'QuizSubmission' } }
    /**
     * Find zero or one QuizSubmission that matches the filter.
     * @param {QuizSubmissionFindUniqueArgs} args - Arguments to find a QuizSubmission
     * @example
     * // Get one QuizSubmission
     * const quizSubmission = await prisma.quizSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizSubmissionFindUniqueArgs>(args: SelectSubset<T, QuizSubmissionFindUniqueArgs<ExtArgs>>): Prisma__QuizSubmissionClient<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizSubmissionFindUniqueOrThrowArgs} args - Arguments to find a QuizSubmission
     * @example
     * // Get one QuizSubmission
     * const quizSubmission = await prisma.quizSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizSubmissionClient<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSubmissionFindFirstArgs} args - Arguments to find a QuizSubmission
     * @example
     * // Get one QuizSubmission
     * const quizSubmission = await prisma.quizSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizSubmissionFindFirstArgs>(args?: SelectSubset<T, QuizSubmissionFindFirstArgs<ExtArgs>>): Prisma__QuizSubmissionClient<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSubmissionFindFirstOrThrowArgs} args - Arguments to find a QuizSubmission
     * @example
     * // Get one QuizSubmission
     * const quizSubmission = await prisma.quizSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizSubmissionClient<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizSubmissions
     * const quizSubmissions = await prisma.quizSubmission.findMany()
     * 
     * // Get first 10 QuizSubmissions
     * const quizSubmissions = await prisma.quizSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizSubmissionWithIdOnly = await prisma.quizSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizSubmissionFindManyArgs>(args?: SelectSubset<T, QuizSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizSubmission.
     * @param {QuizSubmissionCreateArgs} args - Arguments to create a QuizSubmission.
     * @example
     * // Create one QuizSubmission
     * const QuizSubmission = await prisma.quizSubmission.create({
     *   data: {
     *     // ... data to create a QuizSubmission
     *   }
     * })
     * 
     */
    create<T extends QuizSubmissionCreateArgs>(args: SelectSubset<T, QuizSubmissionCreateArgs<ExtArgs>>): Prisma__QuizSubmissionClient<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizSubmissions.
     * @param {QuizSubmissionCreateManyArgs} args - Arguments to create many QuizSubmissions.
     * @example
     * // Create many QuizSubmissions
     * const quizSubmission = await prisma.quizSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizSubmissionCreateManyArgs>(args?: SelectSubset<T, QuizSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizSubmissions and returns the data saved in the database.
     * @param {QuizSubmissionCreateManyAndReturnArgs} args - Arguments to create many QuizSubmissions.
     * @example
     * // Create many QuizSubmissions
     * const quizSubmission = await prisma.quizSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizSubmissions and only return the `id`
     * const quizSubmissionWithIdOnly = await prisma.quizSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizSubmission.
     * @param {QuizSubmissionDeleteArgs} args - Arguments to delete one QuizSubmission.
     * @example
     * // Delete one QuizSubmission
     * const QuizSubmission = await prisma.quizSubmission.delete({
     *   where: {
     *     // ... filter to delete one QuizSubmission
     *   }
     * })
     * 
     */
    delete<T extends QuizSubmissionDeleteArgs>(args: SelectSubset<T, QuizSubmissionDeleteArgs<ExtArgs>>): Prisma__QuizSubmissionClient<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizSubmission.
     * @param {QuizSubmissionUpdateArgs} args - Arguments to update one QuizSubmission.
     * @example
     * // Update one QuizSubmission
     * const quizSubmission = await prisma.quizSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizSubmissionUpdateArgs>(args: SelectSubset<T, QuizSubmissionUpdateArgs<ExtArgs>>): Prisma__QuizSubmissionClient<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizSubmissions.
     * @param {QuizSubmissionDeleteManyArgs} args - Arguments to filter QuizSubmissions to delete.
     * @example
     * // Delete a few QuizSubmissions
     * const { count } = await prisma.quizSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizSubmissionDeleteManyArgs>(args?: SelectSubset<T, QuizSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizSubmissions
     * const quizSubmission = await prisma.quizSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizSubmissionUpdateManyArgs>(args: SelectSubset<T, QuizSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizSubmissions and returns the data updated in the database.
     * @param {QuizSubmissionUpdateManyAndReturnArgs} args - Arguments to update many QuizSubmissions.
     * @example
     * // Update many QuizSubmissions
     * const quizSubmission = await prisma.quizSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizSubmissions and only return the `id`
     * const quizSubmissionWithIdOnly = await prisma.quizSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizSubmission.
     * @param {QuizSubmissionUpsertArgs} args - Arguments to update or create a QuizSubmission.
     * @example
     * // Update or create a QuizSubmission
     * const quizSubmission = await prisma.quizSubmission.upsert({
     *   create: {
     *     // ... data to create a QuizSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizSubmission we want to update
     *   }
     * })
     */
    upsert<T extends QuizSubmissionUpsertArgs>(args: SelectSubset<T, QuizSubmissionUpsertArgs<ExtArgs>>): Prisma__QuizSubmissionClient<$Result.GetResult<Prisma.$QuizSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSubmissionCountArgs} args - Arguments to filter QuizSubmissions to count.
     * @example
     * // Count the number of QuizSubmissions
     * const count = await prisma.quizSubmission.count({
     *   where: {
     *     // ... the filter for the QuizSubmissions we want to count
     *   }
     * })
    **/
    count<T extends QuizSubmissionCountArgs>(
      args?: Subset<T, QuizSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizSubmissionAggregateArgs>(args: Subset<T, QuizSubmissionAggregateArgs>): Prisma.PrismaPromise<GetQuizSubmissionAggregateType<T>>

    /**
     * Group by QuizSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: QuizSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizSubmission model
   */
  readonly fields: QuizSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizSubmission model
   */
  interface QuizSubmissionFieldRefs {
    readonly id: FieldRef<"QuizSubmission", 'String'>
    readonly quizId: FieldRef<"QuizSubmission", 'String'>
    readonly studentId: FieldRef<"QuizSubmission", 'String'>
    readonly answers: FieldRef<"QuizSubmission", 'Json'>
    readonly status: FieldRef<"QuizSubmission", 'String'>
    readonly grade: FieldRef<"QuizSubmission", 'Decimal'>
    readonly studentComments: FieldRef<"QuizSubmission", 'String'>
    readonly teacherComments: FieldRef<"QuizSubmission", 'String'>
    readonly submittedAt: FieldRef<"QuizSubmission", 'DateTime'>
    readonly gradedAt: FieldRef<"QuizSubmission", 'DateTime'>
    readonly reviewedAt: FieldRef<"QuizSubmission", 'DateTime'>
    readonly createdAt: FieldRef<"QuizSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"QuizSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizSubmission findUnique
   */
  export type QuizSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSubmission to fetch.
     */
    where: QuizSubmissionWhereUniqueInput
  }

  /**
   * QuizSubmission findUniqueOrThrow
   */
  export type QuizSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSubmission to fetch.
     */
    where: QuizSubmissionWhereUniqueInput
  }

  /**
   * QuizSubmission findFirst
   */
  export type QuizSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSubmission to fetch.
     */
    where?: QuizSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSubmissions to fetch.
     */
    orderBy?: QuizSubmissionOrderByWithRelationInput | QuizSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizSubmissions.
     */
    cursor?: QuizSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizSubmissions.
     */
    distinct?: QuizSubmissionScalarFieldEnum | QuizSubmissionScalarFieldEnum[]
  }

  /**
   * QuizSubmission findFirstOrThrow
   */
  export type QuizSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSubmission to fetch.
     */
    where?: QuizSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSubmissions to fetch.
     */
    orderBy?: QuizSubmissionOrderByWithRelationInput | QuizSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizSubmissions.
     */
    cursor?: QuizSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizSubmissions.
     */
    distinct?: QuizSubmissionScalarFieldEnum | QuizSubmissionScalarFieldEnum[]
  }

  /**
   * QuizSubmission findMany
   */
  export type QuizSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSubmissions to fetch.
     */
    where?: QuizSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSubmissions to fetch.
     */
    orderBy?: QuizSubmissionOrderByWithRelationInput | QuizSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizSubmissions.
     */
    cursor?: QuizSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSubmissions.
     */
    skip?: number
    distinct?: QuizSubmissionScalarFieldEnum | QuizSubmissionScalarFieldEnum[]
  }

  /**
   * QuizSubmission create
   */
  export type QuizSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizSubmission.
     */
    data: XOR<QuizSubmissionCreateInput, QuizSubmissionUncheckedCreateInput>
  }

  /**
   * QuizSubmission createMany
   */
  export type QuizSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizSubmissions.
     */
    data: QuizSubmissionCreateManyInput | QuizSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizSubmission createManyAndReturn
   */
  export type QuizSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizSubmissions.
     */
    data: QuizSubmissionCreateManyInput | QuizSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizSubmission update
   */
  export type QuizSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizSubmission.
     */
    data: XOR<QuizSubmissionUpdateInput, QuizSubmissionUncheckedUpdateInput>
    /**
     * Choose, which QuizSubmission to update.
     */
    where: QuizSubmissionWhereUniqueInput
  }

  /**
   * QuizSubmission updateMany
   */
  export type QuizSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizSubmissions.
     */
    data: XOR<QuizSubmissionUpdateManyMutationInput, QuizSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which QuizSubmissions to update
     */
    where?: QuizSubmissionWhereInput
    /**
     * Limit how many QuizSubmissions to update.
     */
    limit?: number
  }

  /**
   * QuizSubmission updateManyAndReturn
   */
  export type QuizSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update QuizSubmissions.
     */
    data: XOR<QuizSubmissionUpdateManyMutationInput, QuizSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which QuizSubmissions to update
     */
    where?: QuizSubmissionWhereInput
    /**
     * Limit how many QuizSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizSubmission upsert
   */
  export type QuizSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizSubmission to update in case it exists.
     */
    where: QuizSubmissionWhereUniqueInput
    /**
     * In case the QuizSubmission found by the `where` argument doesn't exist, create a new QuizSubmission with this data.
     */
    create: XOR<QuizSubmissionCreateInput, QuizSubmissionUncheckedCreateInput>
    /**
     * In case the QuizSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizSubmissionUpdateInput, QuizSubmissionUncheckedUpdateInput>
  }

  /**
   * QuizSubmission delete
   */
  export type QuizSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
    /**
     * Filter which QuizSubmission to delete.
     */
    where: QuizSubmissionWhereUniqueInput
  }

  /**
   * QuizSubmission deleteMany
   */
  export type QuizSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizSubmissions to delete
     */
    where?: QuizSubmissionWhereInput
    /**
     * Limit how many QuizSubmissions to delete.
     */
    limit?: number
  }

  /**
   * QuizSubmission without action
   */
  export type QuizSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSubmission
     */
    select?: QuizSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSubmission
     */
    omit?: QuizSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialMinAggregateOutputType = {
    id: string | null
    streamItemId: string | null
    description: string | null
    assignToAll: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: string | null
    streamItemId: string | null
    description: string | null
    assignToAll: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    streamItemId: number
    description: number
    assignToAll: number
    createdAt: number
    updatedAt: number
    assignedGroups: number
    _all: number
  }


  export type MaterialMinAggregateInputType = {
    id?: true
    streamItemId?: true
    description?: true
    assignToAll?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    streamItemId?: true
    description?: true
    assignToAll?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    streamItemId?: true
    description?: true
    assignToAll?: true
    createdAt?: true
    updatedAt?: true
    assignedGroups?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: string
    streamItemId: string
    description: string | null
    assignToAll: boolean
    createdAt: Date
    updatedAt: Date
    assignedGroups: string[]
    _count: MaterialCountAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    description?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
    materialStudents?: boolean | Material$materialStudentsArgs<ExtArgs>
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    description?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    description?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    streamItemId?: boolean
    description?: boolean
    assignToAll?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedGroups?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "streamItemId" | "description" | "assignToAll" | "createdAt" | "updatedAt" | "assignedGroups", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materialStudents?: boolean | Material$materialStudentsArgs<ExtArgs>
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      materialStudents: Prisma.$MaterialStudentPayload<ExtArgs>[]
      streamItem: Prisma.$StreamItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      streamItemId: string
      description: string | null
      assignToAll: boolean
      createdAt: Date
      updatedAt: Date
      assignedGroups: string[]
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materialStudents<T extends Material$materialStudentsArgs<ExtArgs> = {}>(args?: Subset<T, Material$materialStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    streamItem<T extends StreamItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StreamItemDefaultArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'String'>
    readonly streamItemId: FieldRef<"Material", 'String'>
    readonly description: FieldRef<"Material", 'String'>
    readonly assignToAll: FieldRef<"Material", 'Boolean'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
    readonly updatedAt: FieldRef<"Material", 'DateTime'>
    readonly assignedGroups: FieldRef<"Material", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material.materialStudents
   */
  export type Material$materialStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    where?: MaterialStudentWhereInput
    orderBy?: MaterialStudentOrderByWithRelationInput | MaterialStudentOrderByWithRelationInput[]
    cursor?: MaterialStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialStudentScalarFieldEnum | MaterialStudentScalarFieldEnum[]
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model MaterialStudent
   */

  export type AggregateMaterialStudent = {
    _count: MaterialStudentCountAggregateOutputType | null
    _min: MaterialStudentMinAggregateOutputType | null
    _max: MaterialStudentMaxAggregateOutputType | null
  }

  export type MaterialStudentMinAggregateOutputType = {
    id: string | null
    materialId: string | null
    studentId: string | null
  }

  export type MaterialStudentMaxAggregateOutputType = {
    id: string | null
    materialId: string | null
    studentId: string | null
  }

  export type MaterialStudentCountAggregateOutputType = {
    id: number
    materialId: number
    studentId: number
    _all: number
  }


  export type MaterialStudentMinAggregateInputType = {
    id?: true
    materialId?: true
    studentId?: true
  }

  export type MaterialStudentMaxAggregateInputType = {
    id?: true
    materialId?: true
    studentId?: true
  }

  export type MaterialStudentCountAggregateInputType = {
    id?: true
    materialId?: true
    studentId?: true
    _all?: true
  }

  export type MaterialStudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialStudent to aggregate.
     */
    where?: MaterialStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialStudents to fetch.
     */
    orderBy?: MaterialStudentOrderByWithRelationInput | MaterialStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialStudents
    **/
    _count?: true | MaterialStudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialStudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialStudentMaxAggregateInputType
  }

  export type GetMaterialStudentAggregateType<T extends MaterialStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialStudent[P]>
      : GetScalarType<T[P], AggregateMaterialStudent[P]>
  }




  export type MaterialStudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialStudentWhereInput
    orderBy?: MaterialStudentOrderByWithAggregationInput | MaterialStudentOrderByWithAggregationInput[]
    by: MaterialStudentScalarFieldEnum[] | MaterialStudentScalarFieldEnum
    having?: MaterialStudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialStudentCountAggregateInputType | true
    _min?: MaterialStudentMinAggregateInputType
    _max?: MaterialStudentMaxAggregateInputType
  }

  export type MaterialStudentGroupByOutputType = {
    id: string
    materialId: string
    studentId: string
    _count: MaterialStudentCountAggregateOutputType | null
    _min: MaterialStudentMinAggregateOutputType | null
    _max: MaterialStudentMaxAggregateOutputType | null
  }

  type GetMaterialStudentGroupByPayload<T extends MaterialStudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialStudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialStudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialStudentGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialStudentGroupByOutputType[P]>
        }
      >
    >


  export type MaterialStudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    studentId?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialStudent"]>

  export type MaterialStudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    studentId?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialStudent"]>

  export type MaterialStudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    studentId?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialStudent"]>

  export type MaterialStudentSelectScalar = {
    id?: boolean
    materialId?: boolean
    studentId?: boolean
  }

  export type MaterialStudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materialId" | "studentId", ExtArgs["result"]["materialStudent"]>
  export type MaterialStudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MaterialStudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MaterialStudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MaterialStudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialStudent"
    objects: {
      material: Prisma.$MaterialPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      materialId: string
      studentId: string
    }, ExtArgs["result"]["materialStudent"]>
    composites: {}
  }

  type MaterialStudentGetPayload<S extends boolean | null | undefined | MaterialStudentDefaultArgs> = $Result.GetResult<Prisma.$MaterialStudentPayload, S>

  type MaterialStudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialStudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialStudentCountAggregateInputType | true
    }

  export interface MaterialStudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialStudent'], meta: { name: 'MaterialStudent' } }
    /**
     * Find zero or one MaterialStudent that matches the filter.
     * @param {MaterialStudentFindUniqueArgs} args - Arguments to find a MaterialStudent
     * @example
     * // Get one MaterialStudent
     * const materialStudent = await prisma.materialStudent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialStudentFindUniqueArgs>(args: SelectSubset<T, MaterialStudentFindUniqueArgs<ExtArgs>>): Prisma__MaterialStudentClient<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaterialStudent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialStudentFindUniqueOrThrowArgs} args - Arguments to find a MaterialStudent
     * @example
     * // Get one MaterialStudent
     * const materialStudent = await prisma.materialStudent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialStudentFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialStudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialStudentClient<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialStudent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialStudentFindFirstArgs} args - Arguments to find a MaterialStudent
     * @example
     * // Get one MaterialStudent
     * const materialStudent = await prisma.materialStudent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialStudentFindFirstArgs>(args?: SelectSubset<T, MaterialStudentFindFirstArgs<ExtArgs>>): Prisma__MaterialStudentClient<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialStudent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialStudentFindFirstOrThrowArgs} args - Arguments to find a MaterialStudent
     * @example
     * // Get one MaterialStudent
     * const materialStudent = await prisma.materialStudent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialStudentFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialStudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialStudentClient<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaterialStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialStudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialStudents
     * const materialStudents = await prisma.materialStudent.findMany()
     * 
     * // Get first 10 MaterialStudents
     * const materialStudents = await prisma.materialStudent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialStudentWithIdOnly = await prisma.materialStudent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialStudentFindManyArgs>(args?: SelectSubset<T, MaterialStudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaterialStudent.
     * @param {MaterialStudentCreateArgs} args - Arguments to create a MaterialStudent.
     * @example
     * // Create one MaterialStudent
     * const MaterialStudent = await prisma.materialStudent.create({
     *   data: {
     *     // ... data to create a MaterialStudent
     *   }
     * })
     * 
     */
    create<T extends MaterialStudentCreateArgs>(args: SelectSubset<T, MaterialStudentCreateArgs<ExtArgs>>): Prisma__MaterialStudentClient<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaterialStudents.
     * @param {MaterialStudentCreateManyArgs} args - Arguments to create many MaterialStudents.
     * @example
     * // Create many MaterialStudents
     * const materialStudent = await prisma.materialStudent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialStudentCreateManyArgs>(args?: SelectSubset<T, MaterialStudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaterialStudents and returns the data saved in the database.
     * @param {MaterialStudentCreateManyAndReturnArgs} args - Arguments to create many MaterialStudents.
     * @example
     * // Create many MaterialStudents
     * const materialStudent = await prisma.materialStudent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaterialStudents and only return the `id`
     * const materialStudentWithIdOnly = await prisma.materialStudent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialStudentCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialStudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaterialStudent.
     * @param {MaterialStudentDeleteArgs} args - Arguments to delete one MaterialStudent.
     * @example
     * // Delete one MaterialStudent
     * const MaterialStudent = await prisma.materialStudent.delete({
     *   where: {
     *     // ... filter to delete one MaterialStudent
     *   }
     * })
     * 
     */
    delete<T extends MaterialStudentDeleteArgs>(args: SelectSubset<T, MaterialStudentDeleteArgs<ExtArgs>>): Prisma__MaterialStudentClient<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaterialStudent.
     * @param {MaterialStudentUpdateArgs} args - Arguments to update one MaterialStudent.
     * @example
     * // Update one MaterialStudent
     * const materialStudent = await prisma.materialStudent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialStudentUpdateArgs>(args: SelectSubset<T, MaterialStudentUpdateArgs<ExtArgs>>): Prisma__MaterialStudentClient<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaterialStudents.
     * @param {MaterialStudentDeleteManyArgs} args - Arguments to filter MaterialStudents to delete.
     * @example
     * // Delete a few MaterialStudents
     * const { count } = await prisma.materialStudent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialStudentDeleteManyArgs>(args?: SelectSubset<T, MaterialStudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialStudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialStudents
     * const materialStudent = await prisma.materialStudent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialStudentUpdateManyArgs>(args: SelectSubset<T, MaterialStudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialStudents and returns the data updated in the database.
     * @param {MaterialStudentUpdateManyAndReturnArgs} args - Arguments to update many MaterialStudents.
     * @example
     * // Update many MaterialStudents
     * const materialStudent = await prisma.materialStudent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaterialStudents and only return the `id`
     * const materialStudentWithIdOnly = await prisma.materialStudent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialStudentUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialStudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaterialStudent.
     * @param {MaterialStudentUpsertArgs} args - Arguments to update or create a MaterialStudent.
     * @example
     * // Update or create a MaterialStudent
     * const materialStudent = await prisma.materialStudent.upsert({
     *   create: {
     *     // ... data to create a MaterialStudent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialStudent we want to update
     *   }
     * })
     */
    upsert<T extends MaterialStudentUpsertArgs>(args: SelectSubset<T, MaterialStudentUpsertArgs<ExtArgs>>): Prisma__MaterialStudentClient<$Result.GetResult<Prisma.$MaterialStudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaterialStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialStudentCountArgs} args - Arguments to filter MaterialStudents to count.
     * @example
     * // Count the number of MaterialStudents
     * const count = await prisma.materialStudent.count({
     *   where: {
     *     // ... the filter for the MaterialStudents we want to count
     *   }
     * })
    **/
    count<T extends MaterialStudentCountArgs>(
      args?: Subset<T, MaterialStudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialStudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialStudentAggregateArgs>(args: Subset<T, MaterialStudentAggregateArgs>): Prisma.PrismaPromise<GetMaterialStudentAggregateType<T>>

    /**
     * Group by MaterialStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialStudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialStudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialStudentGroupByArgs['orderBy'] }
        : { orderBy?: MaterialStudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialStudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialStudent model
   */
  readonly fields: MaterialStudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialStudent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialStudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialStudent model
   */
  interface MaterialStudentFieldRefs {
    readonly id: FieldRef<"MaterialStudent", 'String'>
    readonly materialId: FieldRef<"MaterialStudent", 'String'>
    readonly studentId: FieldRef<"MaterialStudent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaterialStudent findUnique
   */
  export type MaterialStudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialStudent to fetch.
     */
    where: MaterialStudentWhereUniqueInput
  }

  /**
   * MaterialStudent findUniqueOrThrow
   */
  export type MaterialStudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialStudent to fetch.
     */
    where: MaterialStudentWhereUniqueInput
  }

  /**
   * MaterialStudent findFirst
   */
  export type MaterialStudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialStudent to fetch.
     */
    where?: MaterialStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialStudents to fetch.
     */
    orderBy?: MaterialStudentOrderByWithRelationInput | MaterialStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialStudents.
     */
    cursor?: MaterialStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialStudents.
     */
    distinct?: MaterialStudentScalarFieldEnum | MaterialStudentScalarFieldEnum[]
  }

  /**
   * MaterialStudent findFirstOrThrow
   */
  export type MaterialStudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialStudent to fetch.
     */
    where?: MaterialStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialStudents to fetch.
     */
    orderBy?: MaterialStudentOrderByWithRelationInput | MaterialStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialStudents.
     */
    cursor?: MaterialStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialStudents.
     */
    distinct?: MaterialStudentScalarFieldEnum | MaterialStudentScalarFieldEnum[]
  }

  /**
   * MaterialStudent findMany
   */
  export type MaterialStudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialStudents to fetch.
     */
    where?: MaterialStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialStudents to fetch.
     */
    orderBy?: MaterialStudentOrderByWithRelationInput | MaterialStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialStudents.
     */
    cursor?: MaterialStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialStudents.
     */
    skip?: number
    distinct?: MaterialStudentScalarFieldEnum | MaterialStudentScalarFieldEnum[]
  }

  /**
   * MaterialStudent create
   */
  export type MaterialStudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialStudent.
     */
    data: XOR<MaterialStudentCreateInput, MaterialStudentUncheckedCreateInput>
  }

  /**
   * MaterialStudent createMany
   */
  export type MaterialStudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialStudents.
     */
    data: MaterialStudentCreateManyInput | MaterialStudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialStudent createManyAndReturn
   */
  export type MaterialStudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * The data used to create many MaterialStudents.
     */
    data: MaterialStudentCreateManyInput | MaterialStudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialStudent update
   */
  export type MaterialStudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialStudent.
     */
    data: XOR<MaterialStudentUpdateInput, MaterialStudentUncheckedUpdateInput>
    /**
     * Choose, which MaterialStudent to update.
     */
    where: MaterialStudentWhereUniqueInput
  }

  /**
   * MaterialStudent updateMany
   */
  export type MaterialStudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialStudents.
     */
    data: XOR<MaterialStudentUpdateManyMutationInput, MaterialStudentUncheckedUpdateManyInput>
    /**
     * Filter which MaterialStudents to update
     */
    where?: MaterialStudentWhereInput
    /**
     * Limit how many MaterialStudents to update.
     */
    limit?: number
  }

  /**
   * MaterialStudent updateManyAndReturn
   */
  export type MaterialStudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * The data used to update MaterialStudents.
     */
    data: XOR<MaterialStudentUpdateManyMutationInput, MaterialStudentUncheckedUpdateManyInput>
    /**
     * Filter which MaterialStudents to update
     */
    where?: MaterialStudentWhereInput
    /**
     * Limit how many MaterialStudents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialStudent upsert
   */
  export type MaterialStudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialStudent to update in case it exists.
     */
    where: MaterialStudentWhereUniqueInput
    /**
     * In case the MaterialStudent found by the `where` argument doesn't exist, create a new MaterialStudent with this data.
     */
    create: XOR<MaterialStudentCreateInput, MaterialStudentUncheckedCreateInput>
    /**
     * In case the MaterialStudent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialStudentUpdateInput, MaterialStudentUncheckedUpdateInput>
  }

  /**
   * MaterialStudent delete
   */
  export type MaterialStudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
    /**
     * Filter which MaterialStudent to delete.
     */
    where: MaterialStudentWhereUniqueInput
  }

  /**
   * MaterialStudent deleteMany
   */
  export type MaterialStudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialStudents to delete
     */
    where?: MaterialStudentWhereInput
    /**
     * Limit how many MaterialStudents to delete.
     */
    limit?: number
  }

  /**
   * MaterialStudent without action
   */
  export type MaterialStudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialStudent
     */
    select?: MaterialStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialStudent
     */
    omit?: MaterialStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialStudentInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    fileSize: number | null
    order: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    fileSize: bigint | null
    order: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    streamItemId: string | null
    type: string | null
    name: string | null
    url: string | null
    filePath: string | null
    fileSize: bigint | null
    mimeType: string | null
    order: number | null
    createdAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    streamItemId: string | null
    type: string | null
    name: string | null
    url: string | null
    filePath: string | null
    fileSize: bigint | null
    mimeType: string | null
    order: number | null
    createdAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    streamItemId: number
    type: number
    name: number
    url: number
    filePath: number
    fileSize: number
    mimeType: number
    order: number
    createdAt: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    fileSize?: true
    order?: true
  }

  export type AttachmentSumAggregateInputType = {
    fileSize?: true
    order?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    streamItemId?: true
    type?: true
    name?: true
    url?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    order?: true
    createdAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    streamItemId?: true
    type?: true
    name?: true
    url?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    order?: true
    createdAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    streamItemId?: true
    type?: true
    name?: true
    url?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    streamItemId: string
    type: string
    name: string
    url: string | null
    filePath: string | null
    fileSize: bigint | null
    mimeType: string | null
    order: number
    createdAt: Date
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    type?: boolean
    name?: boolean
    url?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    order?: boolean
    createdAt?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    type?: boolean
    name?: boolean
    url?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    order?: boolean
    createdAt?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    type?: boolean
    name?: boolean
    url?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    order?: boolean
    createdAt?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    streamItemId?: boolean
    type?: boolean
    name?: boolean
    url?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "streamItemId" | "type" | "name" | "url" | "filePath" | "fileSize" | "mimeType" | "order" | "createdAt", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      streamItem: Prisma.$StreamItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      streamItemId: string
      type: string
      name: string
      url: string | null
      filePath: string | null
      fileSize: bigint | null
      mimeType: string | null
      order: number
      createdAt: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    streamItem<T extends StreamItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StreamItemDefaultArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly streamItemId: FieldRef<"Attachment", 'String'>
    readonly type: FieldRef<"Attachment", 'String'>
    readonly name: FieldRef<"Attachment", 'String'>
    readonly url: FieldRef<"Attachment", 'String'>
    readonly filePath: FieldRef<"Attachment", 'String'>
    readonly fileSize: FieldRef<"Attachment", 'BigInt'>
    readonly mimeType: FieldRef<"Attachment", 'String'>
    readonly order: FieldRef<"Attachment", 'Int'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeAvgAggregateOutputType = {
    pointsEarned: Decimal | null
    maxPoints: Decimal | null
    percentage: Decimal | null
  }

  export type GradeSumAggregateOutputType = {
    pointsEarned: Decimal | null
    maxPoints: Decimal | null
    percentage: Decimal | null
  }

  export type GradeMinAggregateOutputType = {
    id: string | null
    classId: string | null
    assignmentId: string | null
    quizId: string | null
    studentId: string | null
    pointsEarned: Decimal | null
    maxPoints: Decimal | null
    percentage: Decimal | null
    status: string | null
    feedback: string | null
    submittedAt: Date | null
    gradedAt: Date | null
    gradedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GradeMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    assignmentId: string | null
    quizId: string | null
    studentId: string | null
    pointsEarned: Decimal | null
    maxPoints: Decimal | null
    percentage: Decimal | null
    status: string | null
    feedback: string | null
    submittedAt: Date | null
    gradedAt: Date | null
    gradedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    classId: number
    assignmentId: number
    quizId: number
    studentId: number
    pointsEarned: number
    maxPoints: number
    percentage: number
    status: number
    feedback: number
    submittedAt: number
    gradedAt: number
    gradedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GradeAvgAggregateInputType = {
    pointsEarned?: true
    maxPoints?: true
    percentage?: true
  }

  export type GradeSumAggregateInputType = {
    pointsEarned?: true
    maxPoints?: true
    percentage?: true
  }

  export type GradeMinAggregateInputType = {
    id?: true
    classId?: true
    assignmentId?: true
    quizId?: true
    studentId?: true
    pointsEarned?: true
    maxPoints?: true
    percentage?: true
    status?: true
    feedback?: true
    submittedAt?: true
    gradedAt?: true
    gradedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    classId?: true
    assignmentId?: true
    quizId?: true
    studentId?: true
    pointsEarned?: true
    maxPoints?: true
    percentage?: true
    status?: true
    feedback?: true
    submittedAt?: true
    gradedAt?: true
    gradedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    classId?: true
    assignmentId?: true
    quizId?: true
    studentId?: true
    pointsEarned?: true
    maxPoints?: true
    percentage?: true
    status?: true
    feedback?: true
    submittedAt?: true
    gradedAt?: true
    gradedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _avg?: GradeAvgAggregateInputType
    _sum?: GradeSumAggregateInputType
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: string
    classId: string
    assignmentId: string | null
    quizId: string | null
    studentId: string
    pointsEarned: Decimal | null
    maxPoints: Decimal | null
    percentage: Decimal | null
    status: string
    feedback: string | null
    submittedAt: Date | null
    gradedAt: Date | null
    gradedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    assignmentId?: boolean
    quizId?: boolean
    studentId?: boolean
    pointsEarned?: boolean
    maxPoints?: boolean
    percentage?: boolean
    status?: boolean
    feedback?: boolean
    submittedAt?: boolean
    gradedAt?: boolean
    gradedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignment?: boolean | Grade$assignmentArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    gradedBy?: boolean | Grade$gradedByArgs<ExtArgs>
    quiz?: boolean | Grade$quizArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    assignmentId?: boolean
    quizId?: boolean
    studentId?: boolean
    pointsEarned?: boolean
    maxPoints?: boolean
    percentage?: boolean
    status?: boolean
    feedback?: boolean
    submittedAt?: boolean
    gradedAt?: boolean
    gradedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignment?: boolean | Grade$assignmentArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    gradedBy?: boolean | Grade$gradedByArgs<ExtArgs>
    quiz?: boolean | Grade$quizArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    assignmentId?: boolean
    quizId?: boolean
    studentId?: boolean
    pointsEarned?: boolean
    maxPoints?: boolean
    percentage?: boolean
    status?: boolean
    feedback?: boolean
    submittedAt?: boolean
    gradedAt?: boolean
    gradedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignment?: boolean | Grade$assignmentArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    gradedBy?: boolean | Grade$gradedByArgs<ExtArgs>
    quiz?: boolean | Grade$quizArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectScalar = {
    id?: boolean
    classId?: boolean
    assignmentId?: boolean
    quizId?: boolean
    studentId?: boolean
    pointsEarned?: boolean
    maxPoints?: boolean
    percentage?: boolean
    status?: boolean
    feedback?: boolean
    submittedAt?: boolean
    gradedAt?: boolean
    gradedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "assignmentId" | "quizId" | "studentId" | "pointsEarned" | "maxPoints" | "percentage" | "status" | "feedback" | "submittedAt" | "gradedAt" | "gradedById" | "createdAt" | "updatedAt", ExtArgs["result"]["grade"]>
  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | Grade$assignmentArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    gradedBy?: boolean | Grade$gradedByArgs<ExtArgs>
    quiz?: boolean | Grade$quizArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | Grade$assignmentArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    gradedBy?: boolean | Grade$gradedByArgs<ExtArgs>
    quiz?: boolean | Grade$quizArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GradeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | Grade$assignmentArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    gradedBy?: boolean | Grade$gradedByArgs<ExtArgs>
    quiz?: boolean | Grade$quizArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      assignment: Prisma.$AssignmentPayload<ExtArgs> | null
      class: Prisma.$ClassPayload<ExtArgs>
      gradedBy: Prisma.$UserPayload<ExtArgs> | null
      quiz: Prisma.$QuizPayload<ExtArgs> | null
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      assignmentId: string | null
      quizId: string | null
      studentId: string
      pointsEarned: Prisma.Decimal | null
      maxPoints: Prisma.Decimal | null
      percentage: Prisma.Decimal | null
      status: string
      feedback: string | null
      submittedAt: Date | null
      gradedAt: Date | null
      gradedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradeCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades and returns the data updated in the database.
     * @param {GradeUpdateManyAndReturnArgs} args - Arguments to update many Grades.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends Grade$assignmentArgs<ExtArgs> = {}>(args?: Subset<T, Grade$assignmentArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gradedBy<T extends Grade$gradedByArgs<ExtArgs> = {}>(args?: Subset<T, Grade$gradedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quiz<T extends Grade$quizArgs<ExtArgs> = {}>(args?: Subset<T, Grade$quizArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'String'>
    readonly classId: FieldRef<"Grade", 'String'>
    readonly assignmentId: FieldRef<"Grade", 'String'>
    readonly quizId: FieldRef<"Grade", 'String'>
    readonly studentId: FieldRef<"Grade", 'String'>
    readonly pointsEarned: FieldRef<"Grade", 'Decimal'>
    readonly maxPoints: FieldRef<"Grade", 'Decimal'>
    readonly percentage: FieldRef<"Grade", 'Decimal'>
    readonly status: FieldRef<"Grade", 'String'>
    readonly feedback: FieldRef<"Grade", 'String'>
    readonly submittedAt: FieldRef<"Grade", 'DateTime'>
    readonly gradedAt: FieldRef<"Grade", 'DateTime'>
    readonly gradedById: FieldRef<"Grade", 'String'>
    readonly createdAt: FieldRef<"Grade", 'DateTime'>
    readonly updatedAt: FieldRef<"Grade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade createManyAndReturn
   */
  export type GradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
  }

  /**
   * Grade updateManyAndReturn
   */
  export type GradeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to delete.
     */
    limit?: number
  }

  /**
   * Grade.assignment
   */
  export type Grade$assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
  }

  /**
   * Grade.gradedBy
   */
  export type Grade$gradedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Grade.quiz
   */
  export type Grade$quizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type ModuleSumAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    category: string | null
    difficulty: string | null
    duration: number | null
    thumbnail: string | null
    instructor: string | null
    isActive: boolean | null
    isPublished: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    category: string | null
    difficulty: string | null
    duration: number | null
    thumbnail: string | null
    instructor: string | null
    isActive: boolean | null
    isPublished: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    title: number
    description: number
    url: number
    category: number
    difficulty: number
    duration: number
    thumbnail: number
    instructor: number
    isActive: number
    isPublished: number
    order: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    duration?: true
    order?: true
  }

  export type ModuleSumAggregateInputType = {
    duration?: true
    order?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    category?: true
    difficulty?: true
    duration?: true
    thumbnail?: true
    instructor?: true
    isActive?: true
    isPublished?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    category?: true
    difficulty?: true
    duration?: true
    thumbnail?: true
    instructor?: true
    isActive?: true
    isPublished?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    category?: true
    difficulty?: true
    duration?: true
    thumbnail?: true
    instructor?: true
    isActive?: true
    isPublished?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: string
    title: string
    description: string | null
    url: string | null
    category: string | null
    difficulty: string | null
    duration: number | null
    thumbnail: string | null
    instructor: string | null
    isActive: boolean
    isPublished: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    thumbnail?: boolean
    instructor?: boolean
    isActive?: boolean
    isPublished?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    classes?: boolean | Module$classesArgs<ExtArgs>
    createdBy?: boolean | Module$createdByArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    thumbnail?: boolean
    instructor?: boolean
    isActive?: boolean
    isPublished?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Module$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    thumbnail?: boolean
    instructor?: boolean
    isActive?: boolean
    isPublished?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Module$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    thumbnail?: boolean
    instructor?: boolean
    isActive?: boolean
    isPublished?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "url" | "category" | "difficulty" | "duration" | "thumbnail" | "instructor" | "isActive" | "isPublished" | "order" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | Module$classesArgs<ExtArgs>
    createdBy?: boolean | Module$createdByArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Module$createdByArgs<ExtArgs>
  }
  export type ModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Module$createdByArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      classes: Prisma.$ClassPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      url: string | null
      category: string | null
      difficulty: string | null
      duration: number | null
      thumbnail: string | null
      instructor: string | null
      isActive: boolean
      isPublished: boolean
      order: number
      createdAt: Date
      updatedAt: Date
      createdById: string | null
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules and returns the data updated in the database.
     * @param {ModuleUpdateManyAndReturnArgs} args - Arguments to update many Modules.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends Module$classesArgs<ExtArgs> = {}>(args?: Subset<T, Module$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends Module$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Module$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly title: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly url: FieldRef<"Module", 'String'>
    readonly category: FieldRef<"Module", 'String'>
    readonly difficulty: FieldRef<"Module", 'String'>
    readonly duration: FieldRef<"Module", 'Int'>
    readonly thumbnail: FieldRef<"Module", 'String'>
    readonly instructor: FieldRef<"Module", 'String'>
    readonly isActive: FieldRef<"Module", 'Boolean'>
    readonly isPublished: FieldRef<"Module", 'Boolean'>
    readonly order: FieldRef<"Module", 'Int'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
    readonly createdById: FieldRef<"Module", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module updateManyAndReturn
   */
  export type ModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.classes
   */
  export type Module$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Module.createdBy
   */
  export type Module$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model StudentParent
   */

  export type AggregateStudentParent = {
    _count: StudentParentCountAggregateOutputType | null
    _min: StudentParentMinAggregateOutputType | null
    _max: StudentParentMaxAggregateOutputType | null
  }

  export type StudentParentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    relationship: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentParentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    relationship: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentParentCountAggregateOutputType = {
    id: number
    studentId: number
    parentId: number
    relationship: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentParentMinAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relationship?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentParentMaxAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relationship?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentParentCountAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relationship?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParent to aggregate.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentParents
    **/
    _count?: true | StudentParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentParentMaxAggregateInputType
  }

  export type GetStudentParentAggregateType<T extends StudentParentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentParent[P]>
      : GetScalarType<T[P], AggregateStudentParent[P]>
  }




  export type StudentParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithAggregationInput | StudentParentOrderByWithAggregationInput[]
    by: StudentParentScalarFieldEnum[] | StudentParentScalarFieldEnum
    having?: StudentParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentParentCountAggregateInputType | true
    _min?: StudentParentMinAggregateInputType
    _max?: StudentParentMaxAggregateInputType
  }

  export type StudentParentGroupByOutputType = {
    id: string
    studentId: string
    parentId: string
    relationship: string | null
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudentParentCountAggregateOutputType | null
    _min: StudentParentMinAggregateOutputType | null
    _max: StudentParentMaxAggregateOutputType | null
  }

  type GetStudentParentGroupByPayload<T extends StudentParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentParentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentParentGroupByOutputType[P]>
        }
      >
    >


  export type StudentParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relationship?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParent"]>

  export type StudentParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relationship?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParent"]>

  export type StudentParentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relationship?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParent"]>

  export type StudentParentSelectScalar = {
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relationship?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "parentId" | "relationship" | "isPrimary" | "createdAt" | "updatedAt", ExtArgs["result"]["studentParent"]>
  export type StudentParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudentParentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudentParentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudentParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentParent"
    objects: {
      parent: Prisma.$UserPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      parentId: string
      relationship: string | null
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentParent"]>
    composites: {}
  }

  type StudentParentGetPayload<S extends boolean | null | undefined | StudentParentDefaultArgs> = $Result.GetResult<Prisma.$StudentParentPayload, S>

  type StudentParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentParentCountAggregateInputType | true
    }

  export interface StudentParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentParent'], meta: { name: 'StudentParent' } }
    /**
     * Find zero or one StudentParent that matches the filter.
     * @param {StudentParentFindUniqueArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentParentFindUniqueArgs>(args: SelectSubset<T, StudentParentFindUniqueArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentParent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentParentFindUniqueOrThrowArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentParentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindFirstArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentParentFindFirstArgs>(args?: SelectSubset<T, StudentParentFindFirstArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindFirstOrThrowArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentParentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentParents
     * const studentParents = await prisma.studentParent.findMany()
     * 
     * // Get first 10 StudentParents
     * const studentParents = await prisma.studentParent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentParentWithIdOnly = await prisma.studentParent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentParentFindManyArgs>(args?: SelectSubset<T, StudentParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentParent.
     * @param {StudentParentCreateArgs} args - Arguments to create a StudentParent.
     * @example
     * // Create one StudentParent
     * const StudentParent = await prisma.studentParent.create({
     *   data: {
     *     // ... data to create a StudentParent
     *   }
     * })
     * 
     */
    create<T extends StudentParentCreateArgs>(args: SelectSubset<T, StudentParentCreateArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentParents.
     * @param {StudentParentCreateManyArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParent = await prisma.studentParent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentParentCreateManyArgs>(args?: SelectSubset<T, StudentParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentParents and returns the data saved in the database.
     * @param {StudentParentCreateManyAndReturnArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParent = await prisma.studentParent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentParents and only return the `id`
     * const studentParentWithIdOnly = await prisma.studentParent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentParentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentParent.
     * @param {StudentParentDeleteArgs} args - Arguments to delete one StudentParent.
     * @example
     * // Delete one StudentParent
     * const StudentParent = await prisma.studentParent.delete({
     *   where: {
     *     // ... filter to delete one StudentParent
     *   }
     * })
     * 
     */
    delete<T extends StudentParentDeleteArgs>(args: SelectSubset<T, StudentParentDeleteArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentParent.
     * @param {StudentParentUpdateArgs} args - Arguments to update one StudentParent.
     * @example
     * // Update one StudentParent
     * const studentParent = await prisma.studentParent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentParentUpdateArgs>(args: SelectSubset<T, StudentParentUpdateArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentParents.
     * @param {StudentParentDeleteManyArgs} args - Arguments to filter StudentParents to delete.
     * @example
     * // Delete a few StudentParents
     * const { count } = await prisma.studentParent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentParentDeleteManyArgs>(args?: SelectSubset<T, StudentParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentParents
     * const studentParent = await prisma.studentParent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentParentUpdateManyArgs>(args: SelectSubset<T, StudentParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents and returns the data updated in the database.
     * @param {StudentParentUpdateManyAndReturnArgs} args - Arguments to update many StudentParents.
     * @example
     * // Update many StudentParents
     * const studentParent = await prisma.studentParent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentParents and only return the `id`
     * const studentParentWithIdOnly = await prisma.studentParent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentParentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentParentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentParent.
     * @param {StudentParentUpsertArgs} args - Arguments to update or create a StudentParent.
     * @example
     * // Update or create a StudentParent
     * const studentParent = await prisma.studentParent.upsert({
     *   create: {
     *     // ... data to create a StudentParent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentParent we want to update
     *   }
     * })
     */
    upsert<T extends StudentParentUpsertArgs>(args: SelectSubset<T, StudentParentUpsertArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentCountArgs} args - Arguments to filter StudentParents to count.
     * @example
     * // Count the number of StudentParents
     * const count = await prisma.studentParent.count({
     *   where: {
     *     // ... the filter for the StudentParents we want to count
     *   }
     * })
    **/
    count<T extends StudentParentCountArgs>(
      args?: Subset<T, StudentParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentParentAggregateArgs>(args: Subset<T, StudentParentAggregateArgs>): Prisma.PrismaPromise<GetStudentParentAggregateType<T>>

    /**
     * Group by StudentParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentParentGroupByArgs['orderBy'] }
        : { orderBy?: StudentParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentParent model
   */
  readonly fields: StudentParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentParent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentParent model
   */
  interface StudentParentFieldRefs {
    readonly id: FieldRef<"StudentParent", 'String'>
    readonly studentId: FieldRef<"StudentParent", 'String'>
    readonly parentId: FieldRef<"StudentParent", 'String'>
    readonly relationship: FieldRef<"StudentParent", 'String'>
    readonly isPrimary: FieldRef<"StudentParent", 'Boolean'>
    readonly createdAt: FieldRef<"StudentParent", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentParent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentParent findUnique
   */
  export type StudentParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent findUniqueOrThrow
   */
  export type StudentParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent findFirst
   */
  export type StudentParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent findFirstOrThrow
   */
  export type StudentParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent findMany
   */
  export type StudentParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent create
   */
  export type StudentParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentParent.
     */
    data: XOR<StudentParentCreateInput, StudentParentUncheckedCreateInput>
  }

  /**
   * StudentParent createMany
   */
  export type StudentParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentCreateManyInput | StudentParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentParent createManyAndReturn
   */
  export type StudentParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentCreateManyInput | StudentParentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentParent update
   */
  export type StudentParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentParent.
     */
    data: XOR<StudentParentUpdateInput, StudentParentUncheckedUpdateInput>
    /**
     * Choose, which StudentParent to update.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent updateMany
   */
  export type StudentParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentWhereInput
    /**
     * Limit how many StudentParents to update.
     */
    limit?: number
  }

  /**
   * StudentParent updateManyAndReturn
   */
  export type StudentParentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentWhereInput
    /**
     * Limit how many StudentParents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentParent upsert
   */
  export type StudentParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentParent to update in case it exists.
     */
    where: StudentParentWhereUniqueInput
    /**
     * In case the StudentParent found by the `where` argument doesn't exist, create a new StudentParent with this data.
     */
    create: XOR<StudentParentCreateInput, StudentParentUncheckedCreateInput>
    /**
     * In case the StudentParent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentParentUpdateInput, StudentParentUncheckedUpdateInput>
  }

  /**
   * StudentParent delete
   */
  export type StudentParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter which StudentParent to delete.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent deleteMany
   */
  export type StudentParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParents to delete
     */
    where?: StudentParentWhereInput
    /**
     * Limit how many StudentParents to delete.
     */
    limit?: number
  }

  /**
   * StudentParent without action
   */
  export type StudentParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
  }


  /**
   * Model AnnouncementStudent
   */

  export type AggregateAnnouncementStudent = {
    _count: AnnouncementStudentCountAggregateOutputType | null
    _min: AnnouncementStudentMinAggregateOutputType | null
    _max: AnnouncementStudentMaxAggregateOutputType | null
  }

  export type AnnouncementStudentMinAggregateOutputType = {
    id: string | null
    streamItemId: string | null
    studentId: string | null
  }

  export type AnnouncementStudentMaxAggregateOutputType = {
    id: string | null
    streamItemId: string | null
    studentId: string | null
  }

  export type AnnouncementStudentCountAggregateOutputType = {
    id: number
    streamItemId: number
    studentId: number
    _all: number
  }


  export type AnnouncementStudentMinAggregateInputType = {
    id?: true
    streamItemId?: true
    studentId?: true
  }

  export type AnnouncementStudentMaxAggregateInputType = {
    id?: true
    streamItemId?: true
    studentId?: true
  }

  export type AnnouncementStudentCountAggregateInputType = {
    id?: true
    streamItemId?: true
    studentId?: true
    _all?: true
  }

  export type AnnouncementStudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnnouncementStudent to aggregate.
     */
    where?: AnnouncementStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnouncementStudents to fetch.
     */
    orderBy?: AnnouncementStudentOrderByWithRelationInput | AnnouncementStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnouncementStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnouncementStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnnouncementStudents
    **/
    _count?: true | AnnouncementStudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementStudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementStudentMaxAggregateInputType
  }

  export type GetAnnouncementStudentAggregateType<T extends AnnouncementStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncementStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncementStudent[P]>
      : GetScalarType<T[P], AggregateAnnouncementStudent[P]>
  }




  export type AnnouncementStudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementStudentWhereInput
    orderBy?: AnnouncementStudentOrderByWithAggregationInput | AnnouncementStudentOrderByWithAggregationInput[]
    by: AnnouncementStudentScalarFieldEnum[] | AnnouncementStudentScalarFieldEnum
    having?: AnnouncementStudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementStudentCountAggregateInputType | true
    _min?: AnnouncementStudentMinAggregateInputType
    _max?: AnnouncementStudentMaxAggregateInputType
  }

  export type AnnouncementStudentGroupByOutputType = {
    id: string
    streamItemId: string
    studentId: string
    _count: AnnouncementStudentCountAggregateOutputType | null
    _min: AnnouncementStudentMinAggregateOutputType | null
    _max: AnnouncementStudentMaxAggregateOutputType | null
  }

  type GetAnnouncementStudentGroupByPayload<T extends AnnouncementStudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementStudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementStudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementStudentGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementStudentGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementStudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    studentId?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcementStudent"]>

  export type AnnouncementStudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    studentId?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcementStudent"]>

  export type AnnouncementStudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamItemId?: boolean
    studentId?: boolean
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcementStudent"]>

  export type AnnouncementStudentSelectScalar = {
    id?: boolean
    streamItemId?: boolean
    studentId?: boolean
  }

  export type AnnouncementStudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "streamItemId" | "studentId", ExtArgs["result"]["announcementStudent"]>
  export type AnnouncementStudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnouncementStudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnouncementStudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streamItem?: boolean | StreamItemDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnnouncementStudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnnouncementStudent"
    objects: {
      streamItem: Prisma.$StreamItemPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      streamItemId: string
      studentId: string
    }, ExtArgs["result"]["announcementStudent"]>
    composites: {}
  }

  type AnnouncementStudentGetPayload<S extends boolean | null | undefined | AnnouncementStudentDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementStudentPayload, S>

  type AnnouncementStudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementStudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementStudentCountAggregateInputType | true
    }

  export interface AnnouncementStudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnnouncementStudent'], meta: { name: 'AnnouncementStudent' } }
    /**
     * Find zero or one AnnouncementStudent that matches the filter.
     * @param {AnnouncementStudentFindUniqueArgs} args - Arguments to find a AnnouncementStudent
     * @example
     * // Get one AnnouncementStudent
     * const announcementStudent = await prisma.announcementStudent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementStudentFindUniqueArgs>(args: SelectSubset<T, AnnouncementStudentFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementStudentClient<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnnouncementStudent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementStudentFindUniqueOrThrowArgs} args - Arguments to find a AnnouncementStudent
     * @example
     * // Get one AnnouncementStudent
     * const announcementStudent = await prisma.announcementStudent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementStudentFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementStudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementStudentClient<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnnouncementStudent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementStudentFindFirstArgs} args - Arguments to find a AnnouncementStudent
     * @example
     * // Get one AnnouncementStudent
     * const announcementStudent = await prisma.announcementStudent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementStudentFindFirstArgs>(args?: SelectSubset<T, AnnouncementStudentFindFirstArgs<ExtArgs>>): Prisma__AnnouncementStudentClient<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnnouncementStudent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementStudentFindFirstOrThrowArgs} args - Arguments to find a AnnouncementStudent
     * @example
     * // Get one AnnouncementStudent
     * const announcementStudent = await prisma.announcementStudent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementStudentFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementStudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementStudentClient<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnnouncementStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementStudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnnouncementStudents
     * const announcementStudents = await prisma.announcementStudent.findMany()
     * 
     * // Get first 10 AnnouncementStudents
     * const announcementStudents = await prisma.announcementStudent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementStudentWithIdOnly = await prisma.announcementStudent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementStudentFindManyArgs>(args?: SelectSubset<T, AnnouncementStudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnnouncementStudent.
     * @param {AnnouncementStudentCreateArgs} args - Arguments to create a AnnouncementStudent.
     * @example
     * // Create one AnnouncementStudent
     * const AnnouncementStudent = await prisma.announcementStudent.create({
     *   data: {
     *     // ... data to create a AnnouncementStudent
     *   }
     * })
     * 
     */
    create<T extends AnnouncementStudentCreateArgs>(args: SelectSubset<T, AnnouncementStudentCreateArgs<ExtArgs>>): Prisma__AnnouncementStudentClient<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnnouncementStudents.
     * @param {AnnouncementStudentCreateManyArgs} args - Arguments to create many AnnouncementStudents.
     * @example
     * // Create many AnnouncementStudents
     * const announcementStudent = await prisma.announcementStudent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementStudentCreateManyArgs>(args?: SelectSubset<T, AnnouncementStudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnnouncementStudents and returns the data saved in the database.
     * @param {AnnouncementStudentCreateManyAndReturnArgs} args - Arguments to create many AnnouncementStudents.
     * @example
     * // Create many AnnouncementStudents
     * const announcementStudent = await prisma.announcementStudent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnnouncementStudents and only return the `id`
     * const announcementStudentWithIdOnly = await prisma.announcementStudent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementStudentCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementStudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnnouncementStudent.
     * @param {AnnouncementStudentDeleteArgs} args - Arguments to delete one AnnouncementStudent.
     * @example
     * // Delete one AnnouncementStudent
     * const AnnouncementStudent = await prisma.announcementStudent.delete({
     *   where: {
     *     // ... filter to delete one AnnouncementStudent
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementStudentDeleteArgs>(args: SelectSubset<T, AnnouncementStudentDeleteArgs<ExtArgs>>): Prisma__AnnouncementStudentClient<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnnouncementStudent.
     * @param {AnnouncementStudentUpdateArgs} args - Arguments to update one AnnouncementStudent.
     * @example
     * // Update one AnnouncementStudent
     * const announcementStudent = await prisma.announcementStudent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementStudentUpdateArgs>(args: SelectSubset<T, AnnouncementStudentUpdateArgs<ExtArgs>>): Prisma__AnnouncementStudentClient<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnnouncementStudents.
     * @param {AnnouncementStudentDeleteManyArgs} args - Arguments to filter AnnouncementStudents to delete.
     * @example
     * // Delete a few AnnouncementStudents
     * const { count } = await prisma.announcementStudent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementStudentDeleteManyArgs>(args?: SelectSubset<T, AnnouncementStudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnnouncementStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementStudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnnouncementStudents
     * const announcementStudent = await prisma.announcementStudent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementStudentUpdateManyArgs>(args: SelectSubset<T, AnnouncementStudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnnouncementStudents and returns the data updated in the database.
     * @param {AnnouncementStudentUpdateManyAndReturnArgs} args - Arguments to update many AnnouncementStudents.
     * @example
     * // Update many AnnouncementStudents
     * const announcementStudent = await prisma.announcementStudent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnnouncementStudents and only return the `id`
     * const announcementStudentWithIdOnly = await prisma.announcementStudent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementStudentUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementStudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnnouncementStudent.
     * @param {AnnouncementStudentUpsertArgs} args - Arguments to update or create a AnnouncementStudent.
     * @example
     * // Update or create a AnnouncementStudent
     * const announcementStudent = await prisma.announcementStudent.upsert({
     *   create: {
     *     // ... data to create a AnnouncementStudent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnnouncementStudent we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementStudentUpsertArgs>(args: SelectSubset<T, AnnouncementStudentUpsertArgs<ExtArgs>>): Prisma__AnnouncementStudentClient<$Result.GetResult<Prisma.$AnnouncementStudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnnouncementStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementStudentCountArgs} args - Arguments to filter AnnouncementStudents to count.
     * @example
     * // Count the number of AnnouncementStudents
     * const count = await prisma.announcementStudent.count({
     *   where: {
     *     // ... the filter for the AnnouncementStudents we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementStudentCountArgs>(
      args?: Subset<T, AnnouncementStudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementStudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnnouncementStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementStudentAggregateArgs>(args: Subset<T, AnnouncementStudentAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementStudentAggregateType<T>>

    /**
     * Group by AnnouncementStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementStudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementStudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementStudentGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementStudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementStudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnnouncementStudent model
   */
  readonly fields: AnnouncementStudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnnouncementStudent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementStudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    streamItem<T extends StreamItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StreamItemDefaultArgs<ExtArgs>>): Prisma__StreamItemClient<$Result.GetResult<Prisma.$StreamItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnnouncementStudent model
   */
  interface AnnouncementStudentFieldRefs {
    readonly id: FieldRef<"AnnouncementStudent", 'String'>
    readonly streamItemId: FieldRef<"AnnouncementStudent", 'String'>
    readonly studentId: FieldRef<"AnnouncementStudent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AnnouncementStudent findUnique
   */
  export type AnnouncementStudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    /**
     * Filter, which AnnouncementStudent to fetch.
     */
    where: AnnouncementStudentWhereUniqueInput
  }

  /**
   * AnnouncementStudent findUniqueOrThrow
   */
  export type AnnouncementStudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    /**
     * Filter, which AnnouncementStudent to fetch.
     */
    where: AnnouncementStudentWhereUniqueInput
  }

  /**
   * AnnouncementStudent findFirst
   */
  export type AnnouncementStudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    /**
     * Filter, which AnnouncementStudent to fetch.
     */
    where?: AnnouncementStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnouncementStudents to fetch.
     */
    orderBy?: AnnouncementStudentOrderByWithRelationInput | AnnouncementStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnnouncementStudents.
     */
    cursor?: AnnouncementStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnouncementStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnouncementStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnnouncementStudents.
     */
    distinct?: AnnouncementStudentScalarFieldEnum | AnnouncementStudentScalarFieldEnum[]
  }

  /**
   * AnnouncementStudent findFirstOrThrow
   */
  export type AnnouncementStudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    /**
     * Filter, which AnnouncementStudent to fetch.
     */
    where?: AnnouncementStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnouncementStudents to fetch.
     */
    orderBy?: AnnouncementStudentOrderByWithRelationInput | AnnouncementStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnnouncementStudents.
     */
    cursor?: AnnouncementStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnouncementStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnouncementStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnnouncementStudents.
     */
    distinct?: AnnouncementStudentScalarFieldEnum | AnnouncementStudentScalarFieldEnum[]
  }

  /**
   * AnnouncementStudent findMany
   */
  export type AnnouncementStudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    /**
     * Filter, which AnnouncementStudents to fetch.
     */
    where?: AnnouncementStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnouncementStudents to fetch.
     */
    orderBy?: AnnouncementStudentOrderByWithRelationInput | AnnouncementStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnnouncementStudents.
     */
    cursor?: AnnouncementStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnouncementStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnouncementStudents.
     */
    skip?: number
    distinct?: AnnouncementStudentScalarFieldEnum | AnnouncementStudentScalarFieldEnum[]
  }

  /**
   * AnnouncementStudent create
   */
  export type AnnouncementStudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    /**
     * The data needed to create a AnnouncementStudent.
     */
    data: XOR<AnnouncementStudentCreateInput, AnnouncementStudentUncheckedCreateInput>
  }

  /**
   * AnnouncementStudent createMany
   */
  export type AnnouncementStudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnnouncementStudents.
     */
    data: AnnouncementStudentCreateManyInput | AnnouncementStudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnnouncementStudent createManyAndReturn
   */
  export type AnnouncementStudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * The data used to create many AnnouncementStudents.
     */
    data: AnnouncementStudentCreateManyInput | AnnouncementStudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnnouncementStudent update
   */
  export type AnnouncementStudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    /**
     * The data needed to update a AnnouncementStudent.
     */
    data: XOR<AnnouncementStudentUpdateInput, AnnouncementStudentUncheckedUpdateInput>
    /**
     * Choose, which AnnouncementStudent to update.
     */
    where: AnnouncementStudentWhereUniqueInput
  }

  /**
   * AnnouncementStudent updateMany
   */
  export type AnnouncementStudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnnouncementStudents.
     */
    data: XOR<AnnouncementStudentUpdateManyMutationInput, AnnouncementStudentUncheckedUpdateManyInput>
    /**
     * Filter which AnnouncementStudents to update
     */
    where?: AnnouncementStudentWhereInput
    /**
     * Limit how many AnnouncementStudents to update.
     */
    limit?: number
  }

  /**
   * AnnouncementStudent updateManyAndReturn
   */
  export type AnnouncementStudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * The data used to update AnnouncementStudents.
     */
    data: XOR<AnnouncementStudentUpdateManyMutationInput, AnnouncementStudentUncheckedUpdateManyInput>
    /**
     * Filter which AnnouncementStudents to update
     */
    where?: AnnouncementStudentWhereInput
    /**
     * Limit how many AnnouncementStudents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnnouncementStudent upsert
   */
  export type AnnouncementStudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    /**
     * The filter to search for the AnnouncementStudent to update in case it exists.
     */
    where: AnnouncementStudentWhereUniqueInput
    /**
     * In case the AnnouncementStudent found by the `where` argument doesn't exist, create a new AnnouncementStudent with this data.
     */
    create: XOR<AnnouncementStudentCreateInput, AnnouncementStudentUncheckedCreateInput>
    /**
     * In case the AnnouncementStudent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementStudentUpdateInput, AnnouncementStudentUncheckedUpdateInput>
  }

  /**
   * AnnouncementStudent delete
   */
  export type AnnouncementStudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
    /**
     * Filter which AnnouncementStudent to delete.
     */
    where: AnnouncementStudentWhereUniqueInput
  }

  /**
   * AnnouncementStudent deleteMany
   */
  export type AnnouncementStudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnnouncementStudents to delete
     */
    where?: AnnouncementStudentWhereInput
    /**
     * Limit how many AnnouncementStudents to delete.
     */
    limit?: number
  }

  /**
   * AnnouncementStudent without action
   */
  export type AnnouncementStudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementStudent
     */
    select?: AnnouncementStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementStudent
     */
    omit?: AnnouncementStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementStudentInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    totalProjects: number | null
    totalRevenue: Decimal | null
  }

  export type ClientSumAggregateOutputType = {
    totalProjects: number | null
    totalRevenue: Decimal | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    contactName: string | null
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    status: string | null
    source: string | null
    totalProjects: number | null
    totalRevenue: Decimal | null
    lastContact: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    contactName: string | null
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    status: string | null
    source: string | null
    totalProjects: number | null
    totalRevenue: Decimal | null
    lastContact: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    companyName: number
    contactName: number
    email: number
    phone: number
    address: number
    website: number
    status: number
    source: number
    totalProjects: number
    totalRevenue: number
    lastContact: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    totalProjects?: true
    totalRevenue?: true
  }

  export type ClientSumAggregateInputType = {
    totalProjects?: true
    totalRevenue?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    companyName?: true
    contactName?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    status?: true
    source?: true
    totalProjects?: true
    totalRevenue?: true
    lastContact?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    companyName?: true
    contactName?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    status?: true
    source?: true
    totalProjects?: true
    totalRevenue?: true
    lastContact?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    companyName?: true
    contactName?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    status?: true
    source?: true
    totalProjects?: true
    totalRevenue?: true
    lastContact?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    companyName: string
    contactName: string | null
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    status: string
    source: string | null
    totalProjects: number
    totalRevenue: Decimal
    lastContact: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    status?: boolean
    source?: boolean
    totalProjects?: boolean
    totalRevenue?: boolean
    lastContact?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eventos?: boolean | Client$eventosArgs<ExtArgs>
    ordenes?: boolean | Client$ordenesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    status?: boolean
    source?: boolean
    totalProjects?: boolean
    totalRevenue?: boolean
    lastContact?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    status?: boolean
    source?: boolean
    totalProjects?: boolean
    totalRevenue?: boolean
    lastContact?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    companyName?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    status?: boolean
    source?: boolean
    totalProjects?: boolean
    totalRevenue?: boolean
    lastContact?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "contactName" | "email" | "phone" | "address" | "website" | "status" | "source" | "totalProjects" | "totalRevenue" | "lastContact" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventos?: boolean | Client$eventosArgs<ExtArgs>
    ordenes?: boolean | Client$ordenesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      eventos: Prisma.$EventoPayload<ExtArgs>[]
      ordenes: Prisma.$OrdenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyName: string
      contactName: string | null
      email: string | null
      phone: string | null
      address: string | null
      website: string | null
      status: string
      source: string | null
      totalProjects: number
      totalRevenue: Prisma.Decimal
      lastContact: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eventos<T extends Client$eventosArgs<ExtArgs> = {}>(args?: Subset<T, Client$eventosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordenes<T extends Client$ordenesArgs<ExtArgs> = {}>(args?: Subset<T, Client$ordenesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly companyName: FieldRef<"Client", 'String'>
    readonly contactName: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly website: FieldRef<"Client", 'String'>
    readonly status: FieldRef<"Client", 'String'>
    readonly source: FieldRef<"Client", 'String'>
    readonly totalProjects: FieldRef<"Client", 'Int'>
    readonly totalRevenue: FieldRef<"Client", 'Decimal'>
    readonly lastContact: FieldRef<"Client", 'DateTime'>
    readonly notes: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.eventos
   */
  export type Client$eventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    where?: EventoWhereInput
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    cursor?: EventoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Client.ordenes
   */
  export type Client$ordenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    where?: OrdenWhereInput
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[]
    cursor?: OrdenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Evento
   */

  export type AggregateEvento = {
    _count: EventoCountAggregateOutputType | null
    _avg: EventoAvgAggregateOutputType | null
    _sum: EventoSumAggregateOutputType | null
    _min: EventoMinAggregateOutputType | null
    _max: EventoMaxAggregateOutputType | null
  }

  export type EventoAvgAggregateOutputType = {
    attendees: number | null
  }

  export type EventoSumAggregateOutputType = {
    attendees: number | null
  }

  export type EventoMinAggregateOutputType = {
    id: string | null
    name: string | null
    date: Date | null
    time: Date | null
    location: string | null
    type: string | null
    status: string | null
    attendees: number | null
    description: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventoMaxAggregateOutputType = {
    id: string | null
    name: string | null
    date: Date | null
    time: Date | null
    location: string | null
    type: string | null
    status: string | null
    attendees: number | null
    description: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventoCountAggregateOutputType = {
    id: number
    name: number
    date: number
    time: number
    location: number
    type: number
    status: number
    attendees: number
    description: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventoAvgAggregateInputType = {
    attendees?: true
  }

  export type EventoSumAggregateInputType = {
    attendees?: true
  }

  export type EventoMinAggregateInputType = {
    id?: true
    name?: true
    date?: true
    time?: true
    location?: true
    type?: true
    status?: true
    attendees?: true
    description?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventoMaxAggregateInputType = {
    id?: true
    name?: true
    date?: true
    time?: true
    location?: true
    type?: true
    status?: true
    attendees?: true
    description?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventoCountAggregateInputType = {
    id?: true
    name?: true
    date?: true
    time?: true
    location?: true
    type?: true
    status?: true
    attendees?: true
    description?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evento to aggregate.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Eventos
    **/
    _count?: true | EventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventoMaxAggregateInputType
  }

  export type GetEventoAggregateType<T extends EventoAggregateArgs> = {
        [P in keyof T & keyof AggregateEvento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvento[P]>
      : GetScalarType<T[P], AggregateEvento[P]>
  }




  export type EventoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoWhereInput
    orderBy?: EventoOrderByWithAggregationInput | EventoOrderByWithAggregationInput[]
    by: EventoScalarFieldEnum[] | EventoScalarFieldEnum
    having?: EventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventoCountAggregateInputType | true
    _avg?: EventoAvgAggregateInputType
    _sum?: EventoSumAggregateInputType
    _min?: EventoMinAggregateInputType
    _max?: EventoMaxAggregateInputType
  }

  export type EventoGroupByOutputType = {
    id: string
    name: string
    date: Date
    time: Date | null
    location: string | null
    type: string
    status: string
    attendees: number
    description: string | null
    clientId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EventoCountAggregateOutputType | null
    _avg: EventoAvgAggregateOutputType | null
    _sum: EventoSumAggregateOutputType | null
    _min: EventoMinAggregateOutputType | null
    _max: EventoMaxAggregateOutputType | null
  }

  type GetEventoGroupByPayload<T extends EventoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventoGroupByOutputType[P]>
            : GetScalarType<T[P], EventoGroupByOutputType[P]>
        }
      >
    >


  export type EventoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    type?: boolean
    status?: boolean
    attendees?: boolean
    description?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Evento$clientArgs<ExtArgs>
  }, ExtArgs["result"]["evento"]>

  export type EventoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    type?: boolean
    status?: boolean
    attendees?: boolean
    description?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Evento$clientArgs<ExtArgs>
  }, ExtArgs["result"]["evento"]>

  export type EventoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    type?: boolean
    status?: boolean
    attendees?: boolean
    description?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Evento$clientArgs<ExtArgs>
  }, ExtArgs["result"]["evento"]>

  export type EventoSelectScalar = {
    id?: boolean
    name?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    type?: boolean
    status?: boolean
    attendees?: boolean
    description?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "date" | "time" | "location" | "type" | "status" | "attendees" | "description" | "clientId" | "createdAt" | "updatedAt", ExtArgs["result"]["evento"]>
  export type EventoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Evento$clientArgs<ExtArgs>
  }
  export type EventoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Evento$clientArgs<ExtArgs>
  }
  export type EventoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Evento$clientArgs<ExtArgs>
  }

  export type $EventoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evento"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      date: Date
      time: Date | null
      location: string | null
      type: string
      status: string
      attendees: number
      description: string | null
      clientId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evento"]>
    composites: {}
  }

  type EventoGetPayload<S extends boolean | null | undefined | EventoDefaultArgs> = $Result.GetResult<Prisma.$EventoPayload, S>

  type EventoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventoCountAggregateInputType | true
    }

  export interface EventoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evento'], meta: { name: 'Evento' } }
    /**
     * Find zero or one Evento that matches the filter.
     * @param {EventoFindUniqueArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventoFindUniqueArgs>(args: SelectSubset<T, EventoFindUniqueArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventoFindUniqueOrThrowArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventoFindUniqueOrThrowArgs>(args: SelectSubset<T, EventoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindFirstArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventoFindFirstArgs>(args?: SelectSubset<T, EventoFindFirstArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindFirstOrThrowArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventoFindFirstOrThrowArgs>(args?: SelectSubset<T, EventoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Eventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eventos
     * const eventos = await prisma.evento.findMany()
     * 
     * // Get first 10 Eventos
     * const eventos = await prisma.evento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventoWithIdOnly = await prisma.evento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventoFindManyArgs>(args?: SelectSubset<T, EventoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evento.
     * @param {EventoCreateArgs} args - Arguments to create a Evento.
     * @example
     * // Create one Evento
     * const Evento = await prisma.evento.create({
     *   data: {
     *     // ... data to create a Evento
     *   }
     * })
     * 
     */
    create<T extends EventoCreateArgs>(args: SelectSubset<T, EventoCreateArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Eventos.
     * @param {EventoCreateManyArgs} args - Arguments to create many Eventos.
     * @example
     * // Create many Eventos
     * const evento = await prisma.evento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventoCreateManyArgs>(args?: SelectSubset<T, EventoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Eventos and returns the data saved in the database.
     * @param {EventoCreateManyAndReturnArgs} args - Arguments to create many Eventos.
     * @example
     * // Create many Eventos
     * const evento = await prisma.evento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Eventos and only return the `id`
     * const eventoWithIdOnly = await prisma.evento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventoCreateManyAndReturnArgs>(args?: SelectSubset<T, EventoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Evento.
     * @param {EventoDeleteArgs} args - Arguments to delete one Evento.
     * @example
     * // Delete one Evento
     * const Evento = await prisma.evento.delete({
     *   where: {
     *     // ... filter to delete one Evento
     *   }
     * })
     * 
     */
    delete<T extends EventoDeleteArgs>(args: SelectSubset<T, EventoDeleteArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evento.
     * @param {EventoUpdateArgs} args - Arguments to update one Evento.
     * @example
     * // Update one Evento
     * const evento = await prisma.evento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventoUpdateArgs>(args: SelectSubset<T, EventoUpdateArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Eventos.
     * @param {EventoDeleteManyArgs} args - Arguments to filter Eventos to delete.
     * @example
     * // Delete a few Eventos
     * const { count } = await prisma.evento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventoDeleteManyArgs>(args?: SelectSubset<T, EventoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eventos
     * const evento = await prisma.evento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventoUpdateManyArgs>(args: SelectSubset<T, EventoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventos and returns the data updated in the database.
     * @param {EventoUpdateManyAndReturnArgs} args - Arguments to update many Eventos.
     * @example
     * // Update many Eventos
     * const evento = await prisma.evento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Eventos and only return the `id`
     * const eventoWithIdOnly = await prisma.evento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventoUpdateManyAndReturnArgs>(args: SelectSubset<T, EventoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Evento.
     * @param {EventoUpsertArgs} args - Arguments to update or create a Evento.
     * @example
     * // Update or create a Evento
     * const evento = await prisma.evento.upsert({
     *   create: {
     *     // ... data to create a Evento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evento we want to update
     *   }
     * })
     */
    upsert<T extends EventoUpsertArgs>(args: SelectSubset<T, EventoUpsertArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoCountArgs} args - Arguments to filter Eventos to count.
     * @example
     * // Count the number of Eventos
     * const count = await prisma.evento.count({
     *   where: {
     *     // ... the filter for the Eventos we want to count
     *   }
     * })
    **/
    count<T extends EventoCountArgs>(
      args?: Subset<T, EventoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventoAggregateArgs>(args: Subset<T, EventoAggregateArgs>): Prisma.PrismaPromise<GetEventoAggregateType<T>>

    /**
     * Group by Evento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventoGroupByArgs['orderBy'] }
        : { orderBy?: EventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evento model
   */
  readonly fields: EventoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Evento$clientArgs<ExtArgs> = {}>(args?: Subset<T, Evento$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evento model
   */
  interface EventoFieldRefs {
    readonly id: FieldRef<"Evento", 'String'>
    readonly name: FieldRef<"Evento", 'String'>
    readonly date: FieldRef<"Evento", 'DateTime'>
    readonly time: FieldRef<"Evento", 'DateTime'>
    readonly location: FieldRef<"Evento", 'String'>
    readonly type: FieldRef<"Evento", 'String'>
    readonly status: FieldRef<"Evento", 'String'>
    readonly attendees: FieldRef<"Evento", 'Int'>
    readonly description: FieldRef<"Evento", 'String'>
    readonly clientId: FieldRef<"Evento", 'String'>
    readonly createdAt: FieldRef<"Evento", 'DateTime'>
    readonly updatedAt: FieldRef<"Evento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evento findUnique
   */
  export type EventoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento findUniqueOrThrow
   */
  export type EventoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento findFirst
   */
  export type EventoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eventos.
     */
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento findFirstOrThrow
   */
  export type EventoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eventos.
     */
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento findMany
   */
  export type EventoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Eventos to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento create
   */
  export type EventoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The data needed to create a Evento.
     */
    data: XOR<EventoCreateInput, EventoUncheckedCreateInput>
  }

  /**
   * Evento createMany
   */
  export type EventoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Eventos.
     */
    data: EventoCreateManyInput | EventoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evento createManyAndReturn
   */
  export type EventoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * The data used to create many Eventos.
     */
    data: EventoCreateManyInput | EventoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evento update
   */
  export type EventoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The data needed to update a Evento.
     */
    data: XOR<EventoUpdateInput, EventoUncheckedUpdateInput>
    /**
     * Choose, which Evento to update.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento updateMany
   */
  export type EventoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Eventos.
     */
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyInput>
    /**
     * Filter which Eventos to update
     */
    where?: EventoWhereInput
    /**
     * Limit how many Eventos to update.
     */
    limit?: number
  }

  /**
   * Evento updateManyAndReturn
   */
  export type EventoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * The data used to update Eventos.
     */
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyInput>
    /**
     * Filter which Eventos to update
     */
    where?: EventoWhereInput
    /**
     * Limit how many Eventos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evento upsert
   */
  export type EventoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The filter to search for the Evento to update in case it exists.
     */
    where: EventoWhereUniqueInput
    /**
     * In case the Evento found by the `where` argument doesn't exist, create a new Evento with this data.
     */
    create: XOR<EventoCreateInput, EventoUncheckedCreateInput>
    /**
     * In case the Evento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventoUpdateInput, EventoUncheckedUpdateInput>
  }

  /**
   * Evento delete
   */
  export type EventoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter which Evento to delete.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento deleteMany
   */
  export type EventoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eventos to delete
     */
    where?: EventoWhereInput
    /**
     * Limit how many Eventos to delete.
     */
    limit?: number
  }

  /**
   * Evento.client
   */
  export type Evento$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Evento without action
   */
  export type EventoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
  }


  /**
   * Model Orden
   */

  export type AggregateOrden = {
    _count: OrdenCountAggregateOutputType | null
    _avg: OrdenAvgAggregateOutputType | null
    _sum: OrdenSumAggregateOutputType | null
    _min: OrdenMinAggregateOutputType | null
    _max: OrdenMaxAggregateOutputType | null
  }

  export type OrdenAvgAggregateOutputType = {
    subtotal: Decimal | null
    discount: Decimal | null
    total: Decimal | null
  }

  export type OrdenSumAggregateOutputType = {
    subtotal: Decimal | null
    discount: Decimal | null
    total: Decimal | null
  }

  export type OrdenMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    clientId: string | null
    clientName: string | null
    clientEmail: string | null
    subtotal: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    status: string | null
    notes: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrdenMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    clientId: string | null
    clientName: string | null
    clientEmail: string | null
    subtotal: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    status: string | null
    notes: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrdenCountAggregateOutputType = {
    id: number
    orderNumber: number
    clientId: number
    clientName: number
    clientEmail: number
    subtotal: number
    discount: number
    total: number
    status: number
    notes: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrdenAvgAggregateInputType = {
    subtotal?: true
    discount?: true
    total?: true
  }

  export type OrdenSumAggregateInputType = {
    subtotal?: true
    discount?: true
    total?: true
  }

  export type OrdenMinAggregateInputType = {
    id?: true
    orderNumber?: true
    clientId?: true
    clientName?: true
    clientEmail?: true
    subtotal?: true
    discount?: true
    total?: true
    status?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrdenMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    clientId?: true
    clientName?: true
    clientEmail?: true
    subtotal?: true
    discount?: true
    total?: true
    status?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrdenCountAggregateInputType = {
    id?: true
    orderNumber?: true
    clientId?: true
    clientName?: true
    clientEmail?: true
    subtotal?: true
    discount?: true
    total?: true
    status?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrdenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orden to aggregate.
     */
    where?: OrdenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ordens to fetch.
     */
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ordens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ordens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ordens
    **/
    _count?: true | OrdenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdenMaxAggregateInputType
  }

  export type GetOrdenAggregateType<T extends OrdenAggregateArgs> = {
        [P in keyof T & keyof AggregateOrden]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrden[P]>
      : GetScalarType<T[P], AggregateOrden[P]>
  }




  export type OrdenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdenWhereInput
    orderBy?: OrdenOrderByWithAggregationInput | OrdenOrderByWithAggregationInput[]
    by: OrdenScalarFieldEnum[] | OrdenScalarFieldEnum
    having?: OrdenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdenCountAggregateInputType | true
    _avg?: OrdenAvgAggregateInputType
    _sum?: OrdenSumAggregateInputType
    _min?: OrdenMinAggregateInputType
    _max?: OrdenMaxAggregateInputType
  }

  export type OrdenGroupByOutputType = {
    id: string
    orderNumber: string
    clientId: string | null
    clientName: string
    clientEmail: string | null
    subtotal: Decimal
    discount: Decimal
    total: Decimal
    status: string
    notes: string | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: OrdenCountAggregateOutputType | null
    _avg: OrdenAvgAggregateOutputType | null
    _sum: OrdenSumAggregateOutputType | null
    _min: OrdenMinAggregateOutputType | null
    _max: OrdenMaxAggregateOutputType | null
  }

  type GetOrdenGroupByPayload<T extends OrdenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdenGroupByOutputType[P]>
            : GetScalarType<T[P], OrdenGroupByOutputType[P]>
        }
      >
    >


  export type OrdenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientId?: boolean
    clientName?: boolean
    clientEmail?: boolean
    subtotal?: boolean
    discount?: boolean
    total?: boolean
    status?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ordenItems?: boolean | Orden$ordenItemsArgs<ExtArgs>
    client?: boolean | Orden$clientArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OrdenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orden"]>

  export type OrdenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientId?: boolean
    clientName?: boolean
    clientEmail?: boolean
    subtotal?: boolean
    discount?: boolean
    total?: boolean
    status?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Orden$clientArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orden"]>

  export type OrdenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientId?: boolean
    clientName?: boolean
    clientEmail?: boolean
    subtotal?: boolean
    discount?: boolean
    total?: boolean
    status?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Orden$clientArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orden"]>

  export type OrdenSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    clientId?: boolean
    clientName?: boolean
    clientEmail?: boolean
    subtotal?: boolean
    discount?: boolean
    total?: boolean
    status?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrdenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "clientId" | "clientName" | "clientEmail" | "subtotal" | "discount" | "total" | "status" | "notes" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["orden"]>
  export type OrdenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordenItems?: boolean | Orden$ordenItemsArgs<ExtArgs>
    client?: boolean | Orden$clientArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OrdenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrdenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Orden$clientArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrdenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Orden$clientArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrdenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Orden"
    objects: {
      ordenItems: Prisma.$OrdenItemPayload<ExtArgs>[]
      client: Prisma.$ClientPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      clientId: string | null
      clientName: string
      clientEmail: string | null
      subtotal: Prisma.Decimal
      discount: Prisma.Decimal
      total: Prisma.Decimal
      status: string
      notes: string | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orden"]>
    composites: {}
  }

  type OrdenGetPayload<S extends boolean | null | undefined | OrdenDefaultArgs> = $Result.GetResult<Prisma.$OrdenPayload, S>

  type OrdenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrdenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdenCountAggregateInputType | true
    }

  export interface OrdenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Orden'], meta: { name: 'Orden' } }
    /**
     * Find zero or one Orden that matches the filter.
     * @param {OrdenFindUniqueArgs} args - Arguments to find a Orden
     * @example
     * // Get one Orden
     * const orden = await prisma.orden.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdenFindUniqueArgs>(args: SelectSubset<T, OrdenFindUniqueArgs<ExtArgs>>): Prisma__OrdenClient<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Orden that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrdenFindUniqueOrThrowArgs} args - Arguments to find a Orden
     * @example
     * // Get one Orden
     * const orden = await prisma.orden.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdenFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdenClient<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orden that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenFindFirstArgs} args - Arguments to find a Orden
     * @example
     * // Get one Orden
     * const orden = await prisma.orden.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdenFindFirstArgs>(args?: SelectSubset<T, OrdenFindFirstArgs<ExtArgs>>): Prisma__OrdenClient<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orden that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenFindFirstOrThrowArgs} args - Arguments to find a Orden
     * @example
     * // Get one Orden
     * const orden = await prisma.orden.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdenFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdenFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdenClient<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ordens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ordens
     * const ordens = await prisma.orden.findMany()
     * 
     * // Get first 10 Ordens
     * const ordens = await prisma.orden.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordenWithIdOnly = await prisma.orden.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrdenFindManyArgs>(args?: SelectSubset<T, OrdenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Orden.
     * @param {OrdenCreateArgs} args - Arguments to create a Orden.
     * @example
     * // Create one Orden
     * const Orden = await prisma.orden.create({
     *   data: {
     *     // ... data to create a Orden
     *   }
     * })
     * 
     */
    create<T extends OrdenCreateArgs>(args: SelectSubset<T, OrdenCreateArgs<ExtArgs>>): Prisma__OrdenClient<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ordens.
     * @param {OrdenCreateManyArgs} args - Arguments to create many Ordens.
     * @example
     * // Create many Ordens
     * const orden = await prisma.orden.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdenCreateManyArgs>(args?: SelectSubset<T, OrdenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ordens and returns the data saved in the database.
     * @param {OrdenCreateManyAndReturnArgs} args - Arguments to create many Ordens.
     * @example
     * // Create many Ordens
     * const orden = await prisma.orden.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ordens and only return the `id`
     * const ordenWithIdOnly = await prisma.orden.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrdenCreateManyAndReturnArgs>(args?: SelectSubset<T, OrdenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Orden.
     * @param {OrdenDeleteArgs} args - Arguments to delete one Orden.
     * @example
     * // Delete one Orden
     * const Orden = await prisma.orden.delete({
     *   where: {
     *     // ... filter to delete one Orden
     *   }
     * })
     * 
     */
    delete<T extends OrdenDeleteArgs>(args: SelectSubset<T, OrdenDeleteArgs<ExtArgs>>): Prisma__OrdenClient<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Orden.
     * @param {OrdenUpdateArgs} args - Arguments to update one Orden.
     * @example
     * // Update one Orden
     * const orden = await prisma.orden.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdenUpdateArgs>(args: SelectSubset<T, OrdenUpdateArgs<ExtArgs>>): Prisma__OrdenClient<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ordens.
     * @param {OrdenDeleteManyArgs} args - Arguments to filter Ordens to delete.
     * @example
     * // Delete a few Ordens
     * const { count } = await prisma.orden.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdenDeleteManyArgs>(args?: SelectSubset<T, OrdenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ordens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ordens
     * const orden = await prisma.orden.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdenUpdateManyArgs>(args: SelectSubset<T, OrdenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ordens and returns the data updated in the database.
     * @param {OrdenUpdateManyAndReturnArgs} args - Arguments to update many Ordens.
     * @example
     * // Update many Ordens
     * const orden = await prisma.orden.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ordens and only return the `id`
     * const ordenWithIdOnly = await prisma.orden.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrdenUpdateManyAndReturnArgs>(args: SelectSubset<T, OrdenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Orden.
     * @param {OrdenUpsertArgs} args - Arguments to update or create a Orden.
     * @example
     * // Update or create a Orden
     * const orden = await prisma.orden.upsert({
     *   create: {
     *     // ... data to create a Orden
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orden we want to update
     *   }
     * })
     */
    upsert<T extends OrdenUpsertArgs>(args: SelectSubset<T, OrdenUpsertArgs<ExtArgs>>): Prisma__OrdenClient<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ordens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenCountArgs} args - Arguments to filter Ordens to count.
     * @example
     * // Count the number of Ordens
     * const count = await prisma.orden.count({
     *   where: {
     *     // ... the filter for the Ordens we want to count
     *   }
     * })
    **/
    count<T extends OrdenCountArgs>(
      args?: Subset<T, OrdenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orden.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdenAggregateArgs>(args: Subset<T, OrdenAggregateArgs>): Prisma.PrismaPromise<GetOrdenAggregateType<T>>

    /**
     * Group by Orden.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdenGroupByArgs['orderBy'] }
        : { orderBy?: OrdenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Orden model
   */
  readonly fields: OrdenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Orden.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ordenItems<T extends Orden$ordenItemsArgs<ExtArgs> = {}>(args?: Subset<T, Orden$ordenItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client<T extends Orden$clientArgs<ExtArgs> = {}>(args?: Subset<T, Orden$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Orden model
   */
  interface OrdenFieldRefs {
    readonly id: FieldRef<"Orden", 'String'>
    readonly orderNumber: FieldRef<"Orden", 'String'>
    readonly clientId: FieldRef<"Orden", 'String'>
    readonly clientName: FieldRef<"Orden", 'String'>
    readonly clientEmail: FieldRef<"Orden", 'String'>
    readonly subtotal: FieldRef<"Orden", 'Decimal'>
    readonly discount: FieldRef<"Orden", 'Decimal'>
    readonly total: FieldRef<"Orden", 'Decimal'>
    readonly status: FieldRef<"Orden", 'String'>
    readonly notes: FieldRef<"Orden", 'String'>
    readonly createdById: FieldRef<"Orden", 'String'>
    readonly createdAt: FieldRef<"Orden", 'DateTime'>
    readonly updatedAt: FieldRef<"Orden", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Orden findUnique
   */
  export type OrdenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    /**
     * Filter, which Orden to fetch.
     */
    where: OrdenWhereUniqueInput
  }

  /**
   * Orden findUniqueOrThrow
   */
  export type OrdenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    /**
     * Filter, which Orden to fetch.
     */
    where: OrdenWhereUniqueInput
  }

  /**
   * Orden findFirst
   */
  export type OrdenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    /**
     * Filter, which Orden to fetch.
     */
    where?: OrdenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ordens to fetch.
     */
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ordens.
     */
    cursor?: OrdenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ordens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ordens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ordens.
     */
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[]
  }

  /**
   * Orden findFirstOrThrow
   */
  export type OrdenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    /**
     * Filter, which Orden to fetch.
     */
    where?: OrdenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ordens to fetch.
     */
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ordens.
     */
    cursor?: OrdenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ordens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ordens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ordens.
     */
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[]
  }

  /**
   * Orden findMany
   */
  export type OrdenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    /**
     * Filter, which Ordens to fetch.
     */
    where?: OrdenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ordens to fetch.
     */
    orderBy?: OrdenOrderByWithRelationInput | OrdenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ordens.
     */
    cursor?: OrdenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ordens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ordens.
     */
    skip?: number
    distinct?: OrdenScalarFieldEnum | OrdenScalarFieldEnum[]
  }

  /**
   * Orden create
   */
  export type OrdenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    /**
     * The data needed to create a Orden.
     */
    data: XOR<OrdenCreateInput, OrdenUncheckedCreateInput>
  }

  /**
   * Orden createMany
   */
  export type OrdenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ordens.
     */
    data: OrdenCreateManyInput | OrdenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Orden createManyAndReturn
   */
  export type OrdenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * The data used to create many Ordens.
     */
    data: OrdenCreateManyInput | OrdenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Orden update
   */
  export type OrdenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    /**
     * The data needed to update a Orden.
     */
    data: XOR<OrdenUpdateInput, OrdenUncheckedUpdateInput>
    /**
     * Choose, which Orden to update.
     */
    where: OrdenWhereUniqueInput
  }

  /**
   * Orden updateMany
   */
  export type OrdenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ordens.
     */
    data: XOR<OrdenUpdateManyMutationInput, OrdenUncheckedUpdateManyInput>
    /**
     * Filter which Ordens to update
     */
    where?: OrdenWhereInput
    /**
     * Limit how many Ordens to update.
     */
    limit?: number
  }

  /**
   * Orden updateManyAndReturn
   */
  export type OrdenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * The data used to update Ordens.
     */
    data: XOR<OrdenUpdateManyMutationInput, OrdenUncheckedUpdateManyInput>
    /**
     * Filter which Ordens to update
     */
    where?: OrdenWhereInput
    /**
     * Limit how many Ordens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Orden upsert
   */
  export type OrdenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    /**
     * The filter to search for the Orden to update in case it exists.
     */
    where: OrdenWhereUniqueInput
    /**
     * In case the Orden found by the `where` argument doesn't exist, create a new Orden with this data.
     */
    create: XOR<OrdenCreateInput, OrdenUncheckedCreateInput>
    /**
     * In case the Orden was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdenUpdateInput, OrdenUncheckedUpdateInput>
  }

  /**
   * Orden delete
   */
  export type OrdenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
    /**
     * Filter which Orden to delete.
     */
    where: OrdenWhereUniqueInput
  }

  /**
   * Orden deleteMany
   */
  export type OrdenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ordens to delete
     */
    where?: OrdenWhereInput
    /**
     * Limit how many Ordens to delete.
     */
    limit?: number
  }

  /**
   * Orden.ordenItems
   */
  export type Orden$ordenItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
    where?: OrdenItemWhereInput
    orderBy?: OrdenItemOrderByWithRelationInput | OrdenItemOrderByWithRelationInput[]
    cursor?: OrdenItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdenItemScalarFieldEnum | OrdenItemScalarFieldEnum[]
  }

  /**
   * Orden.client
   */
  export type Orden$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Orden without action
   */
  export type OrdenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden
     */
    select?: OrdenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orden
     */
    omit?: OrdenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenInclude<ExtArgs> | null
  }


  /**
   * Model OrdenItem
   */

  export type AggregateOrdenItem = {
    _count: OrdenItemCountAggregateOutputType | null
    _avg: OrdenItemAvgAggregateOutputType | null
    _sum: OrdenItemSumAggregateOutputType | null
    _min: OrdenItemMinAggregateOutputType | null
    _max: OrdenItemMaxAggregateOutputType | null
  }

  export type OrdenItemAvgAggregateOutputType = {
    price: Decimal | null
    quantity: number | null
    total: Decimal | null
    order: number | null
  }

  export type OrdenItemSumAggregateOutputType = {
    price: Decimal | null
    quantity: number | null
    total: Decimal | null
    order: number | null
  }

  export type OrdenItemMinAggregateOutputType = {
    id: string | null
    ordenId: string | null
    code: string | null
    title: string | null
    price: Decimal | null
    quantity: number | null
    total: Decimal | null
    order: number | null
    createdAt: Date | null
  }

  export type OrdenItemMaxAggregateOutputType = {
    id: string | null
    ordenId: string | null
    code: string | null
    title: string | null
    price: Decimal | null
    quantity: number | null
    total: Decimal | null
    order: number | null
    createdAt: Date | null
  }

  export type OrdenItemCountAggregateOutputType = {
    id: number
    ordenId: number
    code: number
    title: number
    price: number
    quantity: number
    total: number
    order: number
    createdAt: number
    _all: number
  }


  export type OrdenItemAvgAggregateInputType = {
    price?: true
    quantity?: true
    total?: true
    order?: true
  }

  export type OrdenItemSumAggregateInputType = {
    price?: true
    quantity?: true
    total?: true
    order?: true
  }

  export type OrdenItemMinAggregateInputType = {
    id?: true
    ordenId?: true
    code?: true
    title?: true
    price?: true
    quantity?: true
    total?: true
    order?: true
    createdAt?: true
  }

  export type OrdenItemMaxAggregateInputType = {
    id?: true
    ordenId?: true
    code?: true
    title?: true
    price?: true
    quantity?: true
    total?: true
    order?: true
    createdAt?: true
  }

  export type OrdenItemCountAggregateInputType = {
    id?: true
    ordenId?: true
    code?: true
    title?: true
    price?: true
    quantity?: true
    total?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type OrdenItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdenItem to aggregate.
     */
    where?: OrdenItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdenItems to fetch.
     */
    orderBy?: OrdenItemOrderByWithRelationInput | OrdenItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdenItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdenItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdenItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrdenItems
    **/
    _count?: true | OrdenItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdenItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdenItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdenItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdenItemMaxAggregateInputType
  }

  export type GetOrdenItemAggregateType<T extends OrdenItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrdenItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrdenItem[P]>
      : GetScalarType<T[P], AggregateOrdenItem[P]>
  }




  export type OrdenItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdenItemWhereInput
    orderBy?: OrdenItemOrderByWithAggregationInput | OrdenItemOrderByWithAggregationInput[]
    by: OrdenItemScalarFieldEnum[] | OrdenItemScalarFieldEnum
    having?: OrdenItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdenItemCountAggregateInputType | true
    _avg?: OrdenItemAvgAggregateInputType
    _sum?: OrdenItemSumAggregateInputType
    _min?: OrdenItemMinAggregateInputType
    _max?: OrdenItemMaxAggregateInputType
  }

  export type OrdenItemGroupByOutputType = {
    id: string
    ordenId: string
    code: string | null
    title: string
    price: Decimal
    quantity: number
    total: Decimal
    order: number
    createdAt: Date
    _count: OrdenItemCountAggregateOutputType | null
    _avg: OrdenItemAvgAggregateOutputType | null
    _sum: OrdenItemSumAggregateOutputType | null
    _min: OrdenItemMinAggregateOutputType | null
    _max: OrdenItemMaxAggregateOutputType | null
  }

  type GetOrdenItemGroupByPayload<T extends OrdenItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdenItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdenItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdenItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrdenItemGroupByOutputType[P]>
        }
      >
    >


  export type OrdenItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordenId?: boolean
    code?: boolean
    title?: boolean
    price?: boolean
    quantity?: boolean
    total?: boolean
    order?: boolean
    createdAt?: boolean
    orden?: boolean | OrdenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordenItem"]>

  export type OrdenItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordenId?: boolean
    code?: boolean
    title?: boolean
    price?: boolean
    quantity?: boolean
    total?: boolean
    order?: boolean
    createdAt?: boolean
    orden?: boolean | OrdenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordenItem"]>

  export type OrdenItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordenId?: boolean
    code?: boolean
    title?: boolean
    price?: boolean
    quantity?: boolean
    total?: boolean
    order?: boolean
    createdAt?: boolean
    orden?: boolean | OrdenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordenItem"]>

  export type OrdenItemSelectScalar = {
    id?: boolean
    ordenId?: boolean
    code?: boolean
    title?: boolean
    price?: boolean
    quantity?: boolean
    total?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type OrdenItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ordenId" | "code" | "title" | "price" | "quantity" | "total" | "order" | "createdAt", ExtArgs["result"]["ordenItem"]>
  export type OrdenItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden?: boolean | OrdenDefaultArgs<ExtArgs>
  }
  export type OrdenItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden?: boolean | OrdenDefaultArgs<ExtArgs>
  }
  export type OrdenItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden?: boolean | OrdenDefaultArgs<ExtArgs>
  }

  export type $OrdenItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrdenItem"
    objects: {
      orden: Prisma.$OrdenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ordenId: string
      code: string | null
      title: string
      price: Prisma.Decimal
      quantity: number
      total: Prisma.Decimal
      order: number
      createdAt: Date
    }, ExtArgs["result"]["ordenItem"]>
    composites: {}
  }

  type OrdenItemGetPayload<S extends boolean | null | undefined | OrdenItemDefaultArgs> = $Result.GetResult<Prisma.$OrdenItemPayload, S>

  type OrdenItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrdenItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdenItemCountAggregateInputType | true
    }

  export interface OrdenItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrdenItem'], meta: { name: 'OrdenItem' } }
    /**
     * Find zero or one OrdenItem that matches the filter.
     * @param {OrdenItemFindUniqueArgs} args - Arguments to find a OrdenItem
     * @example
     * // Get one OrdenItem
     * const ordenItem = await prisma.ordenItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdenItemFindUniqueArgs>(args: SelectSubset<T, OrdenItemFindUniqueArgs<ExtArgs>>): Prisma__OrdenItemClient<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrdenItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrdenItemFindUniqueOrThrowArgs} args - Arguments to find a OrdenItem
     * @example
     * // Get one OrdenItem
     * const ordenItem = await prisma.ordenItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdenItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdenItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdenItemClient<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrdenItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenItemFindFirstArgs} args - Arguments to find a OrdenItem
     * @example
     * // Get one OrdenItem
     * const ordenItem = await prisma.ordenItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdenItemFindFirstArgs>(args?: SelectSubset<T, OrdenItemFindFirstArgs<ExtArgs>>): Prisma__OrdenItemClient<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrdenItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenItemFindFirstOrThrowArgs} args - Arguments to find a OrdenItem
     * @example
     * // Get one OrdenItem
     * const ordenItem = await prisma.ordenItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdenItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdenItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdenItemClient<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrdenItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrdenItems
     * const ordenItems = await prisma.ordenItem.findMany()
     * 
     * // Get first 10 OrdenItems
     * const ordenItems = await prisma.ordenItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordenItemWithIdOnly = await prisma.ordenItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrdenItemFindManyArgs>(args?: SelectSubset<T, OrdenItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrdenItem.
     * @param {OrdenItemCreateArgs} args - Arguments to create a OrdenItem.
     * @example
     * // Create one OrdenItem
     * const OrdenItem = await prisma.ordenItem.create({
     *   data: {
     *     // ... data to create a OrdenItem
     *   }
     * })
     * 
     */
    create<T extends OrdenItemCreateArgs>(args: SelectSubset<T, OrdenItemCreateArgs<ExtArgs>>): Prisma__OrdenItemClient<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrdenItems.
     * @param {OrdenItemCreateManyArgs} args - Arguments to create many OrdenItems.
     * @example
     * // Create many OrdenItems
     * const ordenItem = await prisma.ordenItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdenItemCreateManyArgs>(args?: SelectSubset<T, OrdenItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrdenItems and returns the data saved in the database.
     * @param {OrdenItemCreateManyAndReturnArgs} args - Arguments to create many OrdenItems.
     * @example
     * // Create many OrdenItems
     * const ordenItem = await prisma.ordenItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrdenItems and only return the `id`
     * const ordenItemWithIdOnly = await prisma.ordenItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrdenItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrdenItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrdenItem.
     * @param {OrdenItemDeleteArgs} args - Arguments to delete one OrdenItem.
     * @example
     * // Delete one OrdenItem
     * const OrdenItem = await prisma.ordenItem.delete({
     *   where: {
     *     // ... filter to delete one OrdenItem
     *   }
     * })
     * 
     */
    delete<T extends OrdenItemDeleteArgs>(args: SelectSubset<T, OrdenItemDeleteArgs<ExtArgs>>): Prisma__OrdenItemClient<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrdenItem.
     * @param {OrdenItemUpdateArgs} args - Arguments to update one OrdenItem.
     * @example
     * // Update one OrdenItem
     * const ordenItem = await prisma.ordenItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdenItemUpdateArgs>(args: SelectSubset<T, OrdenItemUpdateArgs<ExtArgs>>): Prisma__OrdenItemClient<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrdenItems.
     * @param {OrdenItemDeleteManyArgs} args - Arguments to filter OrdenItems to delete.
     * @example
     * // Delete a few OrdenItems
     * const { count } = await prisma.ordenItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdenItemDeleteManyArgs>(args?: SelectSubset<T, OrdenItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrdenItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrdenItems
     * const ordenItem = await prisma.ordenItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdenItemUpdateManyArgs>(args: SelectSubset<T, OrdenItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrdenItems and returns the data updated in the database.
     * @param {OrdenItemUpdateManyAndReturnArgs} args - Arguments to update many OrdenItems.
     * @example
     * // Update many OrdenItems
     * const ordenItem = await prisma.ordenItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrdenItems and only return the `id`
     * const ordenItemWithIdOnly = await prisma.ordenItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrdenItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrdenItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrdenItem.
     * @param {OrdenItemUpsertArgs} args - Arguments to update or create a OrdenItem.
     * @example
     * // Update or create a OrdenItem
     * const ordenItem = await prisma.ordenItem.upsert({
     *   create: {
     *     // ... data to create a OrdenItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrdenItem we want to update
     *   }
     * })
     */
    upsert<T extends OrdenItemUpsertArgs>(args: SelectSubset<T, OrdenItemUpsertArgs<ExtArgs>>): Prisma__OrdenItemClient<$Result.GetResult<Prisma.$OrdenItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrdenItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenItemCountArgs} args - Arguments to filter OrdenItems to count.
     * @example
     * // Count the number of OrdenItems
     * const count = await prisma.ordenItem.count({
     *   where: {
     *     // ... the filter for the OrdenItems we want to count
     *   }
     * })
    **/
    count<T extends OrdenItemCountArgs>(
      args?: Subset<T, OrdenItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdenItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrdenItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdenItemAggregateArgs>(args: Subset<T, OrdenItemAggregateArgs>): Prisma.PrismaPromise<GetOrdenItemAggregateType<T>>

    /**
     * Group by OrdenItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdenItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdenItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdenItemGroupByArgs['orderBy'] }
        : { orderBy?: OrdenItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdenItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdenItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrdenItem model
   */
  readonly fields: OrdenItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrdenItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdenItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orden<T extends OrdenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdenDefaultArgs<ExtArgs>>): Prisma__OrdenClient<$Result.GetResult<Prisma.$OrdenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrdenItem model
   */
  interface OrdenItemFieldRefs {
    readonly id: FieldRef<"OrdenItem", 'String'>
    readonly ordenId: FieldRef<"OrdenItem", 'String'>
    readonly code: FieldRef<"OrdenItem", 'String'>
    readonly title: FieldRef<"OrdenItem", 'String'>
    readonly price: FieldRef<"OrdenItem", 'Decimal'>
    readonly quantity: FieldRef<"OrdenItem", 'Int'>
    readonly total: FieldRef<"OrdenItem", 'Decimal'>
    readonly order: FieldRef<"OrdenItem", 'Int'>
    readonly createdAt: FieldRef<"OrdenItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrdenItem findUnique
   */
  export type OrdenItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdenItem to fetch.
     */
    where: OrdenItemWhereUniqueInput
  }

  /**
   * OrdenItem findUniqueOrThrow
   */
  export type OrdenItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdenItem to fetch.
     */
    where: OrdenItemWhereUniqueInput
  }

  /**
   * OrdenItem findFirst
   */
  export type OrdenItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdenItem to fetch.
     */
    where?: OrdenItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdenItems to fetch.
     */
    orderBy?: OrdenItemOrderByWithRelationInput | OrdenItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdenItems.
     */
    cursor?: OrdenItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdenItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdenItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdenItems.
     */
    distinct?: OrdenItemScalarFieldEnum | OrdenItemScalarFieldEnum[]
  }

  /**
   * OrdenItem findFirstOrThrow
   */
  export type OrdenItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdenItem to fetch.
     */
    where?: OrdenItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdenItems to fetch.
     */
    orderBy?: OrdenItemOrderByWithRelationInput | OrdenItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdenItems.
     */
    cursor?: OrdenItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdenItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdenItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdenItems.
     */
    distinct?: OrdenItemScalarFieldEnum | OrdenItemScalarFieldEnum[]
  }

  /**
   * OrdenItem findMany
   */
  export type OrdenItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdenItems to fetch.
     */
    where?: OrdenItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdenItems to fetch.
     */
    orderBy?: OrdenItemOrderByWithRelationInput | OrdenItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrdenItems.
     */
    cursor?: OrdenItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdenItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdenItems.
     */
    skip?: number
    distinct?: OrdenItemScalarFieldEnum | OrdenItemScalarFieldEnum[]
  }

  /**
   * OrdenItem create
   */
  export type OrdenItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrdenItem.
     */
    data: XOR<OrdenItemCreateInput, OrdenItemUncheckedCreateInput>
  }

  /**
   * OrdenItem createMany
   */
  export type OrdenItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrdenItems.
     */
    data: OrdenItemCreateManyInput | OrdenItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrdenItem createManyAndReturn
   */
  export type OrdenItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrdenItems.
     */
    data: OrdenItemCreateManyInput | OrdenItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrdenItem update
   */
  export type OrdenItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrdenItem.
     */
    data: XOR<OrdenItemUpdateInput, OrdenItemUncheckedUpdateInput>
    /**
     * Choose, which OrdenItem to update.
     */
    where: OrdenItemWhereUniqueInput
  }

  /**
   * OrdenItem updateMany
   */
  export type OrdenItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrdenItems.
     */
    data: XOR<OrdenItemUpdateManyMutationInput, OrdenItemUncheckedUpdateManyInput>
    /**
     * Filter which OrdenItems to update
     */
    where?: OrdenItemWhereInput
    /**
     * Limit how many OrdenItems to update.
     */
    limit?: number
  }

  /**
   * OrdenItem updateManyAndReturn
   */
  export type OrdenItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * The data used to update OrdenItems.
     */
    data: XOR<OrdenItemUpdateManyMutationInput, OrdenItemUncheckedUpdateManyInput>
    /**
     * Filter which OrdenItems to update
     */
    where?: OrdenItemWhereInput
    /**
     * Limit how many OrdenItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrdenItem upsert
   */
  export type OrdenItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrdenItem to update in case it exists.
     */
    where: OrdenItemWhereUniqueInput
    /**
     * In case the OrdenItem found by the `where` argument doesn't exist, create a new OrdenItem with this data.
     */
    create: XOR<OrdenItemCreateInput, OrdenItemUncheckedCreateInput>
    /**
     * In case the OrdenItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdenItemUpdateInput, OrdenItemUncheckedUpdateInput>
  }

  /**
   * OrdenItem delete
   */
  export type OrdenItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
    /**
     * Filter which OrdenItem to delete.
     */
    where: OrdenItemWhereUniqueInput
  }

  /**
   * OrdenItem deleteMany
   */
  export type OrdenItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdenItems to delete
     */
    where?: OrdenItemWhereInput
    /**
     * Limit how many OrdenItems to delete.
     */
    limit?: number
  }

  /**
   * OrdenItem without action
   */
  export type OrdenItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdenItem
     */
    select?: OrdenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdenItem
     */
    omit?: OrdenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdenItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    avatar: 'avatar',
    passwordHash: 'passwordHash',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    grupoAsignado: 'grupoAsignado'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BugReportScalarFieldEnum: {
    id: 'id',
    description: 'description',
    userId: 'userId',
    status: 'status',
    type: 'type',
    errorHash: 'errorHash',
    createdAt: 'createdAt'
  };

  export type BugReportScalarFieldEnum = (typeof BugReportScalarFieldEnum)[keyof typeof BugReportScalarFieldEnum]


  export const ResidentScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    roomNumber: 'roomNumber',
    status: 'status',
    emergencyContact: 'emergencyContact',
    allergies: 'allergies',
    conditions: 'conditions',
    carePlanSummary: 'carePlanSummary',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResidentScalarFieldEnum = (typeof ResidentScalarFieldEnum)[keyof typeof ResidentScalarFieldEnum]


  export const MedicationOrderScalarFieldEnum: {
    id: 'id',
    residentId: 'residentId',
    medicationName: 'medicationName',
    dosage: 'dosage',
    frequency: 'frequency',
    route: 'route',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    instructions: 'instructions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicationOrderScalarFieldEnum = (typeof MedicationOrderScalarFieldEnum)[keyof typeof MedicationOrderScalarFieldEnum]


  export const MedicationLogScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    administeredBy: 'administeredBy',
    administeredAt: 'administeredAt',
    status: 'status',
    notes: 'notes',
    shift: 'shift'
  };

  export type MedicationLogScalarFieldEnum = (typeof MedicationLogScalarFieldEnum)[keyof typeof MedicationLogScalarFieldEnum]


  export const VitalSignScalarFieldEnum: {
    id: 'id',
    residentId: 'residentId',
    recordedBy: 'recordedBy',
    recordedAt: 'recordedAt',
    bloodPressureSystolic: 'bloodPressureSystolic',
    bloodPressureDiastolic: 'bloodPressureDiastolic',
    heartRate: 'heartRate',
    temperature: 'temperature',
    oxygenSaturation: 'oxygenSaturation',
    glucose: 'glucose',
    weight: 'weight',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VitalSignScalarFieldEnum = (typeof VitalSignScalarFieldEnum)[keyof typeof VitalSignScalarFieldEnum]


  export const NursingNoteScalarFieldEnum: {
    id: 'id',
    residentId: 'residentId',
    authorId: 'authorId',
    createdAt: 'createdAt',
    shift: 'shift',
    category: 'category',
    content: 'content',
    severity: 'severity',
    updatedAt: 'updatedAt'
  };

  export type NursingNoteScalarFieldEnum = (typeof NursingNoteScalarFieldEnum)[keyof typeof NursingNoteScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    classCode: 'classCode',
    section: 'section',
    subject: 'subject',
    room: 'room',
    teacherId: 'teacherId',
    moduleId: 'moduleId',
    backgroundImage: 'backgroundImage',
    isArchived: 'isArchived',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const ClassMemberScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    status: 'status'
  };

  export type ClassMemberScalarFieldEnum = (typeof ClassMemberScalarFieldEnum)[keyof typeof ClassMemberScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    name: 'name',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const StreamItemScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    type: 'type',
    title: 'title',
    content: 'content',
    authorId: 'authorId',
    topicId: 'topicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isArchived: 'isArchived'
  };

  export type StreamItemScalarFieldEnum = (typeof StreamItemScalarFieldEnum)[keyof typeof StreamItemScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    streamItemId: 'streamItemId',
    points: 'points',
    dueDate: 'dueDate',
    dueTime: 'dueTime',
    instructions: 'instructions',
    assignToAll: 'assignToAll',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedGroups: 'assignedGroups',
    deletedAt: 'deletedAt',
    isDeleted: 'isDeleted'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const AssignmentStudentScalarFieldEnum: {
    id: 'id',
    assignmentId: 'assignmentId',
    studentId: 'studentId'
  };

  export type AssignmentStudentScalarFieldEnum = (typeof AssignmentStudentScalarFieldEnum)[keyof typeof AssignmentStudentScalarFieldEnum]


  export const AssignmentSubmissionScalarFieldEnum: {
    id: 'id',
    assignmentId: 'assignmentId',
    studentId: 'studentId',
    content: 'content',
    attachments: 'attachments',
    status: 'status',
    submittedAt: 'submittedAt',
    returnedAt: 'returnedAt',
    gradedAt: 'gradedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    grade: 'grade',
    studentComments: 'studentComments',
    teacherComments: 'teacherComments',
    reviewedAt: 'reviewedAt'
  };

  export type AssignmentSubmissionScalarFieldEnum = (typeof AssignmentSubmissionScalarFieldEnum)[keyof typeof AssignmentSubmissionScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    streamItemId: 'streamItemId',
    points: 'points',
    dueDate: 'dueDate',
    dueTime: 'dueTime',
    description: 'description',
    assignToAll: 'assignToAll',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedGroups: 'assignedGroups'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    title: 'title',
    description: 'description',
    type: 'type',
    required: 'required',
    points: 'points',
    correctAnswer: 'correctAnswer',
    options: 'options',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const QuizStudentScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    studentId: 'studentId'
  };

  export type QuizStudentScalarFieldEnum = (typeof QuizStudentScalarFieldEnum)[keyof typeof QuizStudentScalarFieldEnum]


  export const QuizSubmissionScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    studentId: 'studentId',
    answers: 'answers',
    status: 'status',
    grade: 'grade',
    studentComments: 'studentComments',
    teacherComments: 'teacherComments',
    submittedAt: 'submittedAt',
    gradedAt: 'gradedAt',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizSubmissionScalarFieldEnum = (typeof QuizSubmissionScalarFieldEnum)[keyof typeof QuizSubmissionScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    streamItemId: 'streamItemId',
    description: 'description',
    assignToAll: 'assignToAll',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedGroups: 'assignedGroups'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const MaterialStudentScalarFieldEnum: {
    id: 'id',
    materialId: 'materialId',
    studentId: 'studentId'
  };

  export type MaterialStudentScalarFieldEnum = (typeof MaterialStudentScalarFieldEnum)[keyof typeof MaterialStudentScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    streamItemId: 'streamItemId',
    type: 'type',
    name: 'name',
    url: 'url',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const GradeScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    assignmentId: 'assignmentId',
    quizId: 'quizId',
    studentId: 'studentId',
    pointsEarned: 'pointsEarned',
    maxPoints: 'maxPoints',
    percentage: 'percentage',
    status: 'status',
    feedback: 'feedback',
    submittedAt: 'submittedAt',
    gradedAt: 'gradedAt',
    gradedById: 'gradedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    url: 'url',
    category: 'category',
    difficulty: 'difficulty',
    duration: 'duration',
    thumbnail: 'thumbnail',
    instructor: 'instructor',
    isActive: 'isActive',
    isPublished: 'isPublished',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const StudentParentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    parentId: 'parentId',
    relationship: 'relationship',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentParentScalarFieldEnum = (typeof StudentParentScalarFieldEnum)[keyof typeof StudentParentScalarFieldEnum]


  export const AnnouncementStudentScalarFieldEnum: {
    id: 'id',
    streamItemId: 'streamItemId',
    studentId: 'studentId'
  };

  export type AnnouncementStudentScalarFieldEnum = (typeof AnnouncementStudentScalarFieldEnum)[keyof typeof AnnouncementStudentScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    contactName: 'contactName',
    email: 'email',
    phone: 'phone',
    address: 'address',
    website: 'website',
    status: 'status',
    source: 'source',
    totalProjects: 'totalProjects',
    totalRevenue: 'totalRevenue',
    lastContact: 'lastContact',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const EventoScalarFieldEnum: {
    id: 'id',
    name: 'name',
    date: 'date',
    time: 'time',
    location: 'location',
    type: 'type',
    status: 'status',
    attendees: 'attendees',
    description: 'description',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventoScalarFieldEnum = (typeof EventoScalarFieldEnum)[keyof typeof EventoScalarFieldEnum]


  export const OrdenScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    clientId: 'clientId',
    clientName: 'clientName',
    clientEmail: 'clientEmail',
    subtotal: 'subtotal',
    discount: 'discount',
    total: 'total',
    status: 'status',
    notes: 'notes',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrdenScalarFieldEnum = (typeof OrdenScalarFieldEnum)[keyof typeof OrdenScalarFieldEnum]


  export const OrdenItemScalarFieldEnum: {
    id: 'id',
    ordenId: 'ordenId',
    code: 'code',
    title: 'title',
    price: 'price',
    quantity: 'quantity',
    total: 'total',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type OrdenItemScalarFieldEnum = (typeof OrdenItemScalarFieldEnum)[keyof typeof OrdenItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    grupoAsignado?: StringNullableFilter<"User"> | string | null
    announcementStudents?: AnnouncementStudentListRelationFilter
    assignmentStudents?: AssignmentStudentListRelationFilter
    assignmentSubmissions?: AssignmentSubmissionListRelationFilter
    classMemberships?: ClassMemberListRelationFilter
    classesAsTeacher?: ClassListRelationFilter
    gradesAsGrader?: GradeListRelationFilter
    gradesAsStudent?: GradeListRelationFilter
    materialStudents?: MaterialStudentListRelationFilter
    modulesCreated?: ModuleListRelationFilter
    ordersCreated?: OrdenListRelationFilter
    quizStudents?: QuizStudentListRelationFilter
    quizSubmissions?: QuizSubmissionListRelationFilter
    streamItems?: StreamItemListRelationFilter
    parentRelations?: StudentParentListRelationFilter
    studentParents?: StudentParentListRelationFilter
    bugReports?: BugReportListRelationFilter
    resident?: XOR<ResidentNullableScalarRelationFilter, ResidentWhereInput> | null
    medicationLogs?: MedicationLogListRelationFilter
    recordedVitals?: VitalSignListRelationFilter
    authoredNotes?: NursingNoteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grupoAsignado?: SortOrderInput | SortOrder
    announcementStudents?: AnnouncementStudentOrderByRelationAggregateInput
    assignmentStudents?: AssignmentStudentOrderByRelationAggregateInput
    assignmentSubmissions?: AssignmentSubmissionOrderByRelationAggregateInput
    classMemberships?: ClassMemberOrderByRelationAggregateInput
    classesAsTeacher?: ClassOrderByRelationAggregateInput
    gradesAsGrader?: GradeOrderByRelationAggregateInput
    gradesAsStudent?: GradeOrderByRelationAggregateInput
    materialStudents?: MaterialStudentOrderByRelationAggregateInput
    modulesCreated?: ModuleOrderByRelationAggregateInput
    ordersCreated?: OrdenOrderByRelationAggregateInput
    quizStudents?: QuizStudentOrderByRelationAggregateInput
    quizSubmissions?: QuizSubmissionOrderByRelationAggregateInput
    streamItems?: StreamItemOrderByRelationAggregateInput
    parentRelations?: StudentParentOrderByRelationAggregateInput
    studentParents?: StudentParentOrderByRelationAggregateInput
    bugReports?: BugReportOrderByRelationAggregateInput
    resident?: ResidentOrderByWithRelationInput
    medicationLogs?: MedicationLogOrderByRelationAggregateInput
    recordedVitals?: VitalSignOrderByRelationAggregateInput
    authoredNotes?: NursingNoteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    grupoAsignado?: StringNullableFilter<"User"> | string | null
    announcementStudents?: AnnouncementStudentListRelationFilter
    assignmentStudents?: AssignmentStudentListRelationFilter
    assignmentSubmissions?: AssignmentSubmissionListRelationFilter
    classMemberships?: ClassMemberListRelationFilter
    classesAsTeacher?: ClassListRelationFilter
    gradesAsGrader?: GradeListRelationFilter
    gradesAsStudent?: GradeListRelationFilter
    materialStudents?: MaterialStudentListRelationFilter
    modulesCreated?: ModuleListRelationFilter
    ordersCreated?: OrdenListRelationFilter
    quizStudents?: QuizStudentListRelationFilter
    quizSubmissions?: QuizSubmissionListRelationFilter
    streamItems?: StreamItemListRelationFilter
    parentRelations?: StudentParentListRelationFilter
    studentParents?: StudentParentListRelationFilter
    bugReports?: BugReportListRelationFilter
    resident?: XOR<ResidentNullableScalarRelationFilter, ResidentWhereInput> | null
    medicationLogs?: MedicationLogListRelationFilter
    recordedVitals?: VitalSignListRelationFilter
    authoredNotes?: NursingNoteListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grupoAsignado?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    grupoAsignado?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type BugReportWhereInput = {
    AND?: BugReportWhereInput | BugReportWhereInput[]
    OR?: BugReportWhereInput[]
    NOT?: BugReportWhereInput | BugReportWhereInput[]
    id?: StringFilter<"BugReport"> | string
    description?: StringFilter<"BugReport"> | string
    userId?: StringNullableFilter<"BugReport"> | string | null
    status?: StringFilter<"BugReport"> | string
    type?: StringFilter<"BugReport"> | string
    errorHash?: StringNullableFilter<"BugReport"> | string | null
    createdAt?: DateTimeFilter<"BugReport"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type BugReportOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    errorHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BugReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BugReportWhereInput | BugReportWhereInput[]
    OR?: BugReportWhereInput[]
    NOT?: BugReportWhereInput | BugReportWhereInput[]
    description?: StringFilter<"BugReport"> | string
    userId?: StringNullableFilter<"BugReport"> | string | null
    status?: StringFilter<"BugReport"> | string
    type?: StringFilter<"BugReport"> | string
    errorHash?: StringNullableFilter<"BugReport"> | string | null
    createdAt?: DateTimeFilter<"BugReport"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type BugReportOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    errorHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BugReportCountOrderByAggregateInput
    _max?: BugReportMaxOrderByAggregateInput
    _min?: BugReportMinOrderByAggregateInput
  }

  export type BugReportScalarWhereWithAggregatesInput = {
    AND?: BugReportScalarWhereWithAggregatesInput | BugReportScalarWhereWithAggregatesInput[]
    OR?: BugReportScalarWhereWithAggregatesInput[]
    NOT?: BugReportScalarWhereWithAggregatesInput | BugReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BugReport"> | string
    description?: StringWithAggregatesFilter<"BugReport"> | string
    userId?: StringNullableWithAggregatesFilter<"BugReport"> | string | null
    status?: StringWithAggregatesFilter<"BugReport"> | string
    type?: StringWithAggregatesFilter<"BugReport"> | string
    errorHash?: StringNullableWithAggregatesFilter<"BugReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BugReport"> | Date | string
  }

  export type ResidentWhereInput = {
    AND?: ResidentWhereInput | ResidentWhereInput[]
    OR?: ResidentWhereInput[]
    NOT?: ResidentWhereInput | ResidentWhereInput[]
    id?: StringFilter<"Resident"> | string
    firstName?: StringFilter<"Resident"> | string
    lastName?: StringFilter<"Resident"> | string
    dateOfBirth?: DateTimeFilter<"Resident"> | Date | string
    roomNumber?: StringNullableFilter<"Resident"> | string | null
    status?: StringFilter<"Resident"> | string
    emergencyContact?: JsonNullableFilter<"Resident">
    allergies?: StringNullableFilter<"Resident"> | string | null
    conditions?: StringNullableFilter<"Resident"> | string | null
    carePlanSummary?: StringNullableFilter<"Resident"> | string | null
    userId?: StringNullableFilter<"Resident"> | string | null
    createdAt?: DateTimeFilter<"Resident"> | Date | string
    updatedAt?: DateTimeFilter<"Resident"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    medications?: MedicationOrderListRelationFilter
    vitalSigns?: VitalSignListRelationFilter
    nursingNotes?: NursingNoteListRelationFilter
  }

  export type ResidentOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    roomNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    carePlanSummary?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    medications?: MedicationOrderOrderByRelationAggregateInput
    vitalSigns?: VitalSignOrderByRelationAggregateInput
    nursingNotes?: NursingNoteOrderByRelationAggregateInput
  }

  export type ResidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ResidentWhereInput | ResidentWhereInput[]
    OR?: ResidentWhereInput[]
    NOT?: ResidentWhereInput | ResidentWhereInput[]
    firstName?: StringFilter<"Resident"> | string
    lastName?: StringFilter<"Resident"> | string
    dateOfBirth?: DateTimeFilter<"Resident"> | Date | string
    roomNumber?: StringNullableFilter<"Resident"> | string | null
    status?: StringFilter<"Resident"> | string
    emergencyContact?: JsonNullableFilter<"Resident">
    allergies?: StringNullableFilter<"Resident"> | string | null
    conditions?: StringNullableFilter<"Resident"> | string | null
    carePlanSummary?: StringNullableFilter<"Resident"> | string | null
    createdAt?: DateTimeFilter<"Resident"> | Date | string
    updatedAt?: DateTimeFilter<"Resident"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    medications?: MedicationOrderListRelationFilter
    vitalSigns?: VitalSignListRelationFilter
    nursingNotes?: NursingNoteListRelationFilter
  }, "id" | "userId">

  export type ResidentOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    roomNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    carePlanSummary?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResidentCountOrderByAggregateInput
    _max?: ResidentMaxOrderByAggregateInput
    _min?: ResidentMinOrderByAggregateInput
  }

  export type ResidentScalarWhereWithAggregatesInput = {
    AND?: ResidentScalarWhereWithAggregatesInput | ResidentScalarWhereWithAggregatesInput[]
    OR?: ResidentScalarWhereWithAggregatesInput[]
    NOT?: ResidentScalarWhereWithAggregatesInput | ResidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resident"> | string
    firstName?: StringWithAggregatesFilter<"Resident"> | string
    lastName?: StringWithAggregatesFilter<"Resident"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"Resident"> | Date | string
    roomNumber?: StringNullableWithAggregatesFilter<"Resident"> | string | null
    status?: StringWithAggregatesFilter<"Resident"> | string
    emergencyContact?: JsonNullableWithAggregatesFilter<"Resident">
    allergies?: StringNullableWithAggregatesFilter<"Resident"> | string | null
    conditions?: StringNullableWithAggregatesFilter<"Resident"> | string | null
    carePlanSummary?: StringNullableWithAggregatesFilter<"Resident"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Resident"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Resident"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resident"> | Date | string
  }

  export type MedicationOrderWhereInput = {
    AND?: MedicationOrderWhereInput | MedicationOrderWhereInput[]
    OR?: MedicationOrderWhereInput[]
    NOT?: MedicationOrderWhereInput | MedicationOrderWhereInput[]
    id?: StringFilter<"MedicationOrder"> | string
    residentId?: StringFilter<"MedicationOrder"> | string
    medicationName?: StringFilter<"MedicationOrder"> | string
    dosage?: StringFilter<"MedicationOrder"> | string
    frequency?: StringFilter<"MedicationOrder"> | string
    route?: StringFilter<"MedicationOrder"> | string
    startDate?: DateTimeFilter<"MedicationOrder"> | Date | string
    endDate?: DateTimeNullableFilter<"MedicationOrder"> | Date | string | null
    isActive?: BoolFilter<"MedicationOrder"> | boolean
    instructions?: StringNullableFilter<"MedicationOrder"> | string | null
    createdAt?: DateTimeFilter<"MedicationOrder"> | Date | string
    updatedAt?: DateTimeFilter<"MedicationOrder"> | Date | string
    resident?: XOR<ResidentScalarRelationFilter, ResidentWhereInput>
    logs?: MedicationLogListRelationFilter
  }

  export type MedicationOrderOrderByWithRelationInput = {
    id?: SortOrder
    residentId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    instructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resident?: ResidentOrderByWithRelationInput
    logs?: MedicationLogOrderByRelationAggregateInput
  }

  export type MedicationOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationOrderWhereInput | MedicationOrderWhereInput[]
    OR?: MedicationOrderWhereInput[]
    NOT?: MedicationOrderWhereInput | MedicationOrderWhereInput[]
    residentId?: StringFilter<"MedicationOrder"> | string
    medicationName?: StringFilter<"MedicationOrder"> | string
    dosage?: StringFilter<"MedicationOrder"> | string
    frequency?: StringFilter<"MedicationOrder"> | string
    route?: StringFilter<"MedicationOrder"> | string
    startDate?: DateTimeFilter<"MedicationOrder"> | Date | string
    endDate?: DateTimeNullableFilter<"MedicationOrder"> | Date | string | null
    isActive?: BoolFilter<"MedicationOrder"> | boolean
    instructions?: StringNullableFilter<"MedicationOrder"> | string | null
    createdAt?: DateTimeFilter<"MedicationOrder"> | Date | string
    updatedAt?: DateTimeFilter<"MedicationOrder"> | Date | string
    resident?: XOR<ResidentScalarRelationFilter, ResidentWhereInput>
    logs?: MedicationLogListRelationFilter
  }, "id">

  export type MedicationOrderOrderByWithAggregationInput = {
    id?: SortOrder
    residentId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    instructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicationOrderCountOrderByAggregateInput
    _max?: MedicationOrderMaxOrderByAggregateInput
    _min?: MedicationOrderMinOrderByAggregateInput
  }

  export type MedicationOrderScalarWhereWithAggregatesInput = {
    AND?: MedicationOrderScalarWhereWithAggregatesInput | MedicationOrderScalarWhereWithAggregatesInput[]
    OR?: MedicationOrderScalarWhereWithAggregatesInput[]
    NOT?: MedicationOrderScalarWhereWithAggregatesInput | MedicationOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicationOrder"> | string
    residentId?: StringWithAggregatesFilter<"MedicationOrder"> | string
    medicationName?: StringWithAggregatesFilter<"MedicationOrder"> | string
    dosage?: StringWithAggregatesFilter<"MedicationOrder"> | string
    frequency?: StringWithAggregatesFilter<"MedicationOrder"> | string
    route?: StringWithAggregatesFilter<"MedicationOrder"> | string
    startDate?: DateTimeWithAggregatesFilter<"MedicationOrder"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"MedicationOrder"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"MedicationOrder"> | boolean
    instructions?: StringNullableWithAggregatesFilter<"MedicationOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MedicationOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicationOrder"> | Date | string
  }

  export type MedicationLogWhereInput = {
    AND?: MedicationLogWhereInput | MedicationLogWhereInput[]
    OR?: MedicationLogWhereInput[]
    NOT?: MedicationLogWhereInput | MedicationLogWhereInput[]
    id?: StringFilter<"MedicationLog"> | string
    orderId?: StringFilter<"MedicationLog"> | string
    administeredBy?: StringFilter<"MedicationLog"> | string
    administeredAt?: DateTimeFilter<"MedicationLog"> | Date | string
    status?: StringFilter<"MedicationLog"> | string
    notes?: StringNullableFilter<"MedicationLog"> | string | null
    shift?: StringNullableFilter<"MedicationLog"> | string | null
    order?: XOR<MedicationOrderScalarRelationFilter, MedicationOrderWhereInput>
    administrator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MedicationLogOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    administeredBy?: SortOrder
    administeredAt?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    shift?: SortOrderInput | SortOrder
    order?: MedicationOrderOrderByWithRelationInput
    administrator?: UserOrderByWithRelationInput
  }

  export type MedicationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationLogWhereInput | MedicationLogWhereInput[]
    OR?: MedicationLogWhereInput[]
    NOT?: MedicationLogWhereInput | MedicationLogWhereInput[]
    orderId?: StringFilter<"MedicationLog"> | string
    administeredBy?: StringFilter<"MedicationLog"> | string
    administeredAt?: DateTimeFilter<"MedicationLog"> | Date | string
    status?: StringFilter<"MedicationLog"> | string
    notes?: StringNullableFilter<"MedicationLog"> | string | null
    shift?: StringNullableFilter<"MedicationLog"> | string | null
    order?: XOR<MedicationOrderScalarRelationFilter, MedicationOrderWhereInput>
    administrator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MedicationLogOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    administeredBy?: SortOrder
    administeredAt?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    shift?: SortOrderInput | SortOrder
    _count?: MedicationLogCountOrderByAggregateInput
    _max?: MedicationLogMaxOrderByAggregateInput
    _min?: MedicationLogMinOrderByAggregateInput
  }

  export type MedicationLogScalarWhereWithAggregatesInput = {
    AND?: MedicationLogScalarWhereWithAggregatesInput | MedicationLogScalarWhereWithAggregatesInput[]
    OR?: MedicationLogScalarWhereWithAggregatesInput[]
    NOT?: MedicationLogScalarWhereWithAggregatesInput | MedicationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicationLog"> | string
    orderId?: StringWithAggregatesFilter<"MedicationLog"> | string
    administeredBy?: StringWithAggregatesFilter<"MedicationLog"> | string
    administeredAt?: DateTimeWithAggregatesFilter<"MedicationLog"> | Date | string
    status?: StringWithAggregatesFilter<"MedicationLog"> | string
    notes?: StringNullableWithAggregatesFilter<"MedicationLog"> | string | null
    shift?: StringNullableWithAggregatesFilter<"MedicationLog"> | string | null
  }

  export type VitalSignWhereInput = {
    AND?: VitalSignWhereInput | VitalSignWhereInput[]
    OR?: VitalSignWhereInput[]
    NOT?: VitalSignWhereInput | VitalSignWhereInput[]
    id?: StringFilter<"VitalSign"> | string
    residentId?: StringFilter<"VitalSign"> | string
    recordedBy?: StringFilter<"VitalSign"> | string
    recordedAt?: DateTimeFilter<"VitalSign"> | Date | string
    bloodPressureSystolic?: IntNullableFilter<"VitalSign"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"VitalSign"> | number | null
    heartRate?: IntNullableFilter<"VitalSign"> | number | null
    temperature?: FloatNullableFilter<"VitalSign"> | number | null
    oxygenSaturation?: IntNullableFilter<"VitalSign"> | number | null
    glucose?: IntNullableFilter<"VitalSign"> | number | null
    weight?: FloatNullableFilter<"VitalSign"> | number | null
    notes?: StringNullableFilter<"VitalSign"> | string | null
    createdAt?: DateTimeFilter<"VitalSign"> | Date | string
    updatedAt?: DateTimeFilter<"VitalSign"> | Date | string
    resident?: XOR<ResidentScalarRelationFilter, ResidentWhereInput>
    recorder?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VitalSignOrderByWithRelationInput = {
    id?: SortOrder
    residentId?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    heartRate?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    glucose?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resident?: ResidentOrderByWithRelationInput
    recorder?: UserOrderByWithRelationInput
  }

  export type VitalSignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VitalSignWhereInput | VitalSignWhereInput[]
    OR?: VitalSignWhereInput[]
    NOT?: VitalSignWhereInput | VitalSignWhereInput[]
    residentId?: StringFilter<"VitalSign"> | string
    recordedBy?: StringFilter<"VitalSign"> | string
    recordedAt?: DateTimeFilter<"VitalSign"> | Date | string
    bloodPressureSystolic?: IntNullableFilter<"VitalSign"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"VitalSign"> | number | null
    heartRate?: IntNullableFilter<"VitalSign"> | number | null
    temperature?: FloatNullableFilter<"VitalSign"> | number | null
    oxygenSaturation?: IntNullableFilter<"VitalSign"> | number | null
    glucose?: IntNullableFilter<"VitalSign"> | number | null
    weight?: FloatNullableFilter<"VitalSign"> | number | null
    notes?: StringNullableFilter<"VitalSign"> | string | null
    createdAt?: DateTimeFilter<"VitalSign"> | Date | string
    updatedAt?: DateTimeFilter<"VitalSign"> | Date | string
    resident?: XOR<ResidentScalarRelationFilter, ResidentWhereInput>
    recorder?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VitalSignOrderByWithAggregationInput = {
    id?: SortOrder
    residentId?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    heartRate?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    glucose?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VitalSignCountOrderByAggregateInput
    _avg?: VitalSignAvgOrderByAggregateInput
    _max?: VitalSignMaxOrderByAggregateInput
    _min?: VitalSignMinOrderByAggregateInput
    _sum?: VitalSignSumOrderByAggregateInput
  }

  export type VitalSignScalarWhereWithAggregatesInput = {
    AND?: VitalSignScalarWhereWithAggregatesInput | VitalSignScalarWhereWithAggregatesInput[]
    OR?: VitalSignScalarWhereWithAggregatesInput[]
    NOT?: VitalSignScalarWhereWithAggregatesInput | VitalSignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VitalSign"> | string
    residentId?: StringWithAggregatesFilter<"VitalSign"> | string
    recordedBy?: StringWithAggregatesFilter<"VitalSign"> | string
    recordedAt?: DateTimeWithAggregatesFilter<"VitalSign"> | Date | string
    bloodPressureSystolic?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    bloodPressureDiastolic?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    heartRate?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    temperature?: FloatNullableWithAggregatesFilter<"VitalSign"> | number | null
    oxygenSaturation?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    glucose?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"VitalSign"> | number | null
    notes?: StringNullableWithAggregatesFilter<"VitalSign"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VitalSign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VitalSign"> | Date | string
  }

  export type NursingNoteWhereInput = {
    AND?: NursingNoteWhereInput | NursingNoteWhereInput[]
    OR?: NursingNoteWhereInput[]
    NOT?: NursingNoteWhereInput | NursingNoteWhereInput[]
    id?: StringFilter<"NursingNote"> | string
    residentId?: StringFilter<"NursingNote"> | string
    authorId?: StringFilter<"NursingNote"> | string
    createdAt?: DateTimeFilter<"NursingNote"> | Date | string
    shift?: StringFilter<"NursingNote"> | string
    category?: StringFilter<"NursingNote"> | string
    content?: StringFilter<"NursingNote"> | string
    severity?: StringFilter<"NursingNote"> | string
    updatedAt?: DateTimeFilter<"NursingNote"> | Date | string
    resident?: XOR<ResidentScalarRelationFilter, ResidentWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NursingNoteOrderByWithRelationInput = {
    id?: SortOrder
    residentId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    shift?: SortOrder
    category?: SortOrder
    content?: SortOrder
    severity?: SortOrder
    updatedAt?: SortOrder
    resident?: ResidentOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type NursingNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NursingNoteWhereInput | NursingNoteWhereInput[]
    OR?: NursingNoteWhereInput[]
    NOT?: NursingNoteWhereInput | NursingNoteWhereInput[]
    residentId?: StringFilter<"NursingNote"> | string
    authorId?: StringFilter<"NursingNote"> | string
    createdAt?: DateTimeFilter<"NursingNote"> | Date | string
    shift?: StringFilter<"NursingNote"> | string
    category?: StringFilter<"NursingNote"> | string
    content?: StringFilter<"NursingNote"> | string
    severity?: StringFilter<"NursingNote"> | string
    updatedAt?: DateTimeFilter<"NursingNote"> | Date | string
    resident?: XOR<ResidentScalarRelationFilter, ResidentWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NursingNoteOrderByWithAggregationInput = {
    id?: SortOrder
    residentId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    shift?: SortOrder
    category?: SortOrder
    content?: SortOrder
    severity?: SortOrder
    updatedAt?: SortOrder
    _count?: NursingNoteCountOrderByAggregateInput
    _max?: NursingNoteMaxOrderByAggregateInput
    _min?: NursingNoteMinOrderByAggregateInput
  }

  export type NursingNoteScalarWhereWithAggregatesInput = {
    AND?: NursingNoteScalarWhereWithAggregatesInput | NursingNoteScalarWhereWithAggregatesInput[]
    OR?: NursingNoteScalarWhereWithAggregatesInput[]
    NOT?: NursingNoteScalarWhereWithAggregatesInput | NursingNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NursingNote"> | string
    residentId?: StringWithAggregatesFilter<"NursingNote"> | string
    authorId?: StringWithAggregatesFilter<"NursingNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NursingNote"> | Date | string
    shift?: StringWithAggregatesFilter<"NursingNote"> | string
    category?: StringWithAggregatesFilter<"NursingNote"> | string
    content?: StringWithAggregatesFilter<"NursingNote"> | string
    severity?: StringWithAggregatesFilter<"NursingNote"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"NursingNote"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    title?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    classCode?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    subject?: StringNullableFilter<"Class"> | string | null
    room?: StringNullableFilter<"Class"> | string | null
    teacherId?: StringFilter<"Class"> | string
    moduleId?: StringNullableFilter<"Class"> | string | null
    backgroundImage?: StringNullableFilter<"Class"> | string | null
    isArchived?: BoolFilter<"Class"> | boolean
    status?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    members?: ClassMemberListRelationFilter
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    teacher?: XOR<UserScalarRelationFilter, UserWhereInput>
    grades?: GradeListRelationFilter
    streamItems?: StreamItemListRelationFilter
    topics?: TopicListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    classCode?: SortOrder
    section?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    teacherId?: SortOrder
    moduleId?: SortOrderInput | SortOrder
    backgroundImage?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: ClassMemberOrderByRelationAggregateInput
    module?: ModuleOrderByWithRelationInput
    teacher?: UserOrderByWithRelationInput
    grades?: GradeOrderByRelationAggregateInput
    streamItems?: StreamItemOrderByRelationAggregateInput
    topics?: TopicOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    classCode?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    title?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    section?: StringNullableFilter<"Class"> | string | null
    subject?: StringNullableFilter<"Class"> | string | null
    room?: StringNullableFilter<"Class"> | string | null
    teacherId?: StringFilter<"Class"> | string
    moduleId?: StringNullableFilter<"Class"> | string | null
    backgroundImage?: StringNullableFilter<"Class"> | string | null
    isArchived?: BoolFilter<"Class"> | boolean
    status?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    members?: ClassMemberListRelationFilter
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    teacher?: XOR<UserScalarRelationFilter, UserWhereInput>
    grades?: GradeListRelationFilter
    streamItems?: StreamItemListRelationFilter
    topics?: TopicListRelationFilter
  }, "id" | "classCode">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    classCode?: SortOrder
    section?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    teacherId?: SortOrder
    moduleId?: SortOrderInput | SortOrder
    backgroundImage?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    title?: StringWithAggregatesFilter<"Class"> | string
    description?: StringNullableWithAggregatesFilter<"Class"> | string | null
    classCode?: StringWithAggregatesFilter<"Class"> | string
    section?: StringNullableWithAggregatesFilter<"Class"> | string | null
    subject?: StringNullableWithAggregatesFilter<"Class"> | string | null
    room?: StringNullableWithAggregatesFilter<"Class"> | string | null
    teacherId?: StringWithAggregatesFilter<"Class"> | string
    moduleId?: StringNullableWithAggregatesFilter<"Class"> | string | null
    backgroundImage?: StringNullableWithAggregatesFilter<"Class"> | string | null
    isArchived?: BoolWithAggregatesFilter<"Class"> | boolean
    status?: StringWithAggregatesFilter<"Class"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type ClassMemberWhereInput = {
    AND?: ClassMemberWhereInput | ClassMemberWhereInput[]
    OR?: ClassMemberWhereInput[]
    NOT?: ClassMemberWhereInput | ClassMemberWhereInput[]
    id?: StringFilter<"ClassMember"> | string
    classId?: StringFilter<"ClassMember"> | string
    userId?: StringFilter<"ClassMember"> | string
    role?: StringFilter<"ClassMember"> | string
    joinedAt?: DateTimeFilter<"ClassMember"> | Date | string
    status?: StringFilter<"ClassMember"> | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClassMemberOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    class?: ClassOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ClassMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    classId_userId?: ClassMemberClassIdUserIdCompoundUniqueInput
    AND?: ClassMemberWhereInput | ClassMemberWhereInput[]
    OR?: ClassMemberWhereInput[]
    NOT?: ClassMemberWhereInput | ClassMemberWhereInput[]
    classId?: StringFilter<"ClassMember"> | string
    userId?: StringFilter<"ClassMember"> | string
    role?: StringFilter<"ClassMember"> | string
    joinedAt?: DateTimeFilter<"ClassMember"> | Date | string
    status?: StringFilter<"ClassMember"> | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "classId_userId">

  export type ClassMemberOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    _count?: ClassMemberCountOrderByAggregateInput
    _max?: ClassMemberMaxOrderByAggregateInput
    _min?: ClassMemberMinOrderByAggregateInput
  }

  export type ClassMemberScalarWhereWithAggregatesInput = {
    AND?: ClassMemberScalarWhereWithAggregatesInput | ClassMemberScalarWhereWithAggregatesInput[]
    OR?: ClassMemberScalarWhereWithAggregatesInput[]
    NOT?: ClassMemberScalarWhereWithAggregatesInput | ClassMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassMember"> | string
    classId?: StringWithAggregatesFilter<"ClassMember"> | string
    userId?: StringWithAggregatesFilter<"ClassMember"> | string
    role?: StringWithAggregatesFilter<"ClassMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ClassMember"> | Date | string
    status?: StringWithAggregatesFilter<"ClassMember"> | string
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: StringFilter<"Topic"> | string
    classId?: StringFilter<"Topic"> | string
    name?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    order?: IntFilter<"Topic"> | number
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    streamItems?: StreamItemListRelationFilter
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    streamItems?: StreamItemOrderByRelationAggregateInput
    class?: ClassOrderByWithRelationInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    classId?: StringFilter<"Topic"> | string
    name?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    order?: IntFilter<"Topic"> | number
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    streamItems?: StreamItemListRelationFilter
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _avg?: TopicAvgOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
    _sum?: TopicSumOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Topic"> | string
    classId?: StringWithAggregatesFilter<"Topic"> | string
    name?: StringWithAggregatesFilter<"Topic"> | string
    description?: StringNullableWithAggregatesFilter<"Topic"> | string | null
    order?: IntWithAggregatesFilter<"Topic"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
  }

  export type StreamItemWhereInput = {
    AND?: StreamItemWhereInput | StreamItemWhereInput[]
    OR?: StreamItemWhereInput[]
    NOT?: StreamItemWhereInput | StreamItemWhereInput[]
    id?: StringFilter<"StreamItem"> | string
    classId?: StringNullableFilter<"StreamItem"> | string | null
    type?: StringFilter<"StreamItem"> | string
    title?: StringFilter<"StreamItem"> | string
    content?: StringNullableFilter<"StreamItem"> | string | null
    authorId?: StringFilter<"StreamItem"> | string
    topicId?: StringNullableFilter<"StreamItem"> | string | null
    createdAt?: DateTimeFilter<"StreamItem"> | Date | string
    updatedAt?: DateTimeFilter<"StreamItem"> | Date | string
    isArchived?: BoolFilter<"StreamItem"> | boolean
    announcementStudents?: AnnouncementStudentListRelationFilter
    assignment?: XOR<AssignmentNullableScalarRelationFilter, AssignmentWhereInput> | null
    attachments?: AttachmentListRelationFilter
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    quiz?: XOR<QuizNullableScalarRelationFilter, QuizWhereInput> | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    topic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
  }

  export type StreamItemOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    authorId?: SortOrder
    topicId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isArchived?: SortOrder
    announcementStudents?: AnnouncementStudentOrderByRelationAggregateInput
    assignment?: AssignmentOrderByWithRelationInput
    attachments?: AttachmentOrderByRelationAggregateInput
    material?: MaterialOrderByWithRelationInput
    quiz?: QuizOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
  }

  export type StreamItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StreamItemWhereInput | StreamItemWhereInput[]
    OR?: StreamItemWhereInput[]
    NOT?: StreamItemWhereInput | StreamItemWhereInput[]
    classId?: StringNullableFilter<"StreamItem"> | string | null
    type?: StringFilter<"StreamItem"> | string
    title?: StringFilter<"StreamItem"> | string
    content?: StringNullableFilter<"StreamItem"> | string | null
    authorId?: StringFilter<"StreamItem"> | string
    topicId?: StringNullableFilter<"StreamItem"> | string | null
    createdAt?: DateTimeFilter<"StreamItem"> | Date | string
    updatedAt?: DateTimeFilter<"StreamItem"> | Date | string
    isArchived?: BoolFilter<"StreamItem"> | boolean
    announcementStudents?: AnnouncementStudentListRelationFilter
    assignment?: XOR<AssignmentNullableScalarRelationFilter, AssignmentWhereInput> | null
    attachments?: AttachmentListRelationFilter
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    quiz?: XOR<QuizNullableScalarRelationFilter, QuizWhereInput> | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    topic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
  }, "id">

  export type StreamItemOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    authorId?: SortOrder
    topicId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isArchived?: SortOrder
    _count?: StreamItemCountOrderByAggregateInput
    _max?: StreamItemMaxOrderByAggregateInput
    _min?: StreamItemMinOrderByAggregateInput
  }

  export type StreamItemScalarWhereWithAggregatesInput = {
    AND?: StreamItemScalarWhereWithAggregatesInput | StreamItemScalarWhereWithAggregatesInput[]
    OR?: StreamItemScalarWhereWithAggregatesInput[]
    NOT?: StreamItemScalarWhereWithAggregatesInput | StreamItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StreamItem"> | string
    classId?: StringNullableWithAggregatesFilter<"StreamItem"> | string | null
    type?: StringWithAggregatesFilter<"StreamItem"> | string
    title?: StringWithAggregatesFilter<"StreamItem"> | string
    content?: StringNullableWithAggregatesFilter<"StreamItem"> | string | null
    authorId?: StringWithAggregatesFilter<"StreamItem"> | string
    topicId?: StringNullableWithAggregatesFilter<"StreamItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StreamItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StreamItem"> | Date | string
    isArchived?: BoolWithAggregatesFilter<"StreamItem"> | boolean
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: StringFilter<"Assignment"> | string
    streamItemId?: StringFilter<"Assignment"> | string
    points?: IntNullableFilter<"Assignment"> | number | null
    dueDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    dueTime?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    instructions?: StringNullableFilter<"Assignment"> | string | null
    assignToAll?: BoolFilter<"Assignment"> | boolean
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    assignedGroups?: StringNullableListFilter<"Assignment">
    deletedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    isDeleted?: BoolFilter<"Assignment"> | boolean
    assignmentStudents?: AssignmentStudentListRelationFilter
    assignmentSubmissions?: AssignmentSubmissionListRelationFilter
    streamItem?: XOR<StreamItemScalarRelationFilter, StreamItemWhereInput>
    grades?: GradeListRelationFilter
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    points?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    dueTime?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedGroups?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    assignmentStudents?: AssignmentStudentOrderByRelationAggregateInput
    assignmentSubmissions?: AssignmentSubmissionOrderByRelationAggregateInput
    streamItem?: StreamItemOrderByWithRelationInput
    grades?: GradeOrderByRelationAggregateInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    streamItemId?: string
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    points?: IntNullableFilter<"Assignment"> | number | null
    dueDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    dueTime?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    instructions?: StringNullableFilter<"Assignment"> | string | null
    assignToAll?: BoolFilter<"Assignment"> | boolean
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    assignedGroups?: StringNullableListFilter<"Assignment">
    deletedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    isDeleted?: BoolFilter<"Assignment"> | boolean
    assignmentStudents?: AssignmentStudentListRelationFilter
    assignmentSubmissions?: AssignmentSubmissionListRelationFilter
    streamItem?: XOR<StreamItemScalarRelationFilter, StreamItemWhereInput>
    grades?: GradeListRelationFilter
  }, "id" | "streamItemId">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    points?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    dueTime?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedGroups?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assignment"> | string
    streamItemId?: StringWithAggregatesFilter<"Assignment"> | string
    points?: IntNullableWithAggregatesFilter<"Assignment"> | number | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    dueTime?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    instructions?: StringNullableWithAggregatesFilter<"Assignment"> | string | null
    assignToAll?: BoolWithAggregatesFilter<"Assignment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    assignedGroups?: StringNullableListFilter<"Assignment">
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Assignment"> | boolean
  }

  export type AssignmentStudentWhereInput = {
    AND?: AssignmentStudentWhereInput | AssignmentStudentWhereInput[]
    OR?: AssignmentStudentWhereInput[]
    NOT?: AssignmentStudentWhereInput | AssignmentStudentWhereInput[]
    id?: StringFilter<"AssignmentStudent"> | string
    assignmentId?: StringFilter<"AssignmentStudent"> | string
    studentId?: StringFilter<"AssignmentStudent"> | string
    assignment?: XOR<AssignmentScalarRelationFilter, AssignmentWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AssignmentStudentOrderByWithRelationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    assignment?: AssignmentOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type AssignmentStudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    assignmentId_studentId?: AssignmentStudentAssignmentIdStudentIdCompoundUniqueInput
    AND?: AssignmentStudentWhereInput | AssignmentStudentWhereInput[]
    OR?: AssignmentStudentWhereInput[]
    NOT?: AssignmentStudentWhereInput | AssignmentStudentWhereInput[]
    assignmentId?: StringFilter<"AssignmentStudent"> | string
    studentId?: StringFilter<"AssignmentStudent"> | string
    assignment?: XOR<AssignmentScalarRelationFilter, AssignmentWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "assignmentId_studentId">

  export type AssignmentStudentOrderByWithAggregationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    _count?: AssignmentStudentCountOrderByAggregateInput
    _max?: AssignmentStudentMaxOrderByAggregateInput
    _min?: AssignmentStudentMinOrderByAggregateInput
  }

  export type AssignmentStudentScalarWhereWithAggregatesInput = {
    AND?: AssignmentStudentScalarWhereWithAggregatesInput | AssignmentStudentScalarWhereWithAggregatesInput[]
    OR?: AssignmentStudentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentStudentScalarWhereWithAggregatesInput | AssignmentStudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssignmentStudent"> | string
    assignmentId?: StringWithAggregatesFilter<"AssignmentStudent"> | string
    studentId?: StringWithAggregatesFilter<"AssignmentStudent"> | string
  }

  export type AssignmentSubmissionWhereInput = {
    AND?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    OR?: AssignmentSubmissionWhereInput[]
    NOT?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    id?: StringFilter<"AssignmentSubmission"> | string
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    studentId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    attachments?: JsonNullableFilter<"AssignmentSubmission">
    status?: StringFilter<"AssignmentSubmission"> | string
    submittedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    returnedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    gradedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    createdAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    grade?: DecimalNullableFilter<"AssignmentSubmission"> | Decimal | DecimalJsLike | number | string | null
    studentComments?: StringNullableFilter<"AssignmentSubmission"> | string | null
    teacherComments?: StringNullableFilter<"AssignmentSubmission"> | string | null
    reviewedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    assignment?: XOR<AssignmentScalarRelationFilter, AssignmentWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AssignmentSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    content?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    returnedAt?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grade?: SortOrderInput | SortOrder
    studentComments?: SortOrderInput | SortOrder
    teacherComments?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    assignment?: AssignmentOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type AssignmentSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    assignmentId_studentId?: AssignmentSubmissionAssignmentIdStudentIdCompoundUniqueInput
    AND?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    OR?: AssignmentSubmissionWhereInput[]
    NOT?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    studentId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    attachments?: JsonNullableFilter<"AssignmentSubmission">
    status?: StringFilter<"AssignmentSubmission"> | string
    submittedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    returnedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    gradedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    createdAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    grade?: DecimalNullableFilter<"AssignmentSubmission"> | Decimal | DecimalJsLike | number | string | null
    studentComments?: StringNullableFilter<"AssignmentSubmission"> | string | null
    teacherComments?: StringNullableFilter<"AssignmentSubmission"> | string | null
    reviewedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    assignment?: XOR<AssignmentScalarRelationFilter, AssignmentWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "assignmentId_studentId">

  export type AssignmentSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    content?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    returnedAt?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grade?: SortOrderInput | SortOrder
    studentComments?: SortOrderInput | SortOrder
    teacherComments?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    _count?: AssignmentSubmissionCountOrderByAggregateInput
    _avg?: AssignmentSubmissionAvgOrderByAggregateInput
    _max?: AssignmentSubmissionMaxOrderByAggregateInput
    _min?: AssignmentSubmissionMinOrderByAggregateInput
    _sum?: AssignmentSubmissionSumOrderByAggregateInput
  }

  export type AssignmentSubmissionScalarWhereWithAggregatesInput = {
    AND?: AssignmentSubmissionScalarWhereWithAggregatesInput | AssignmentSubmissionScalarWhereWithAggregatesInput[]
    OR?: AssignmentSubmissionScalarWhereWithAggregatesInput[]
    NOT?: AssignmentSubmissionScalarWhereWithAggregatesInput | AssignmentSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    assignmentId?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    studentId?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    content?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    attachments?: JsonNullableWithAggregatesFilter<"AssignmentSubmission">
    status?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"AssignmentSubmission"> | Date | string | null
    returnedAt?: DateTimeNullableWithAggregatesFilter<"AssignmentSubmission"> | Date | string | null
    gradedAt?: DateTimeNullableWithAggregatesFilter<"AssignmentSubmission"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssignmentSubmission"> | Date | string
    grade?: DecimalNullableWithAggregatesFilter<"AssignmentSubmission"> | Decimal | DecimalJsLike | number | string | null
    studentComments?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    teacherComments?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"AssignmentSubmission"> | Date | string | null
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: StringFilter<"Quiz"> | string
    streamItemId?: StringFilter<"Quiz"> | string
    points?: IntNullableFilter<"Quiz"> | number | null
    dueDate?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    dueTime?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    description?: StringNullableFilter<"Quiz"> | string | null
    assignToAll?: BoolFilter<"Quiz"> | boolean
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    assignedGroups?: StringNullableListFilter<"Quiz">
    grades?: GradeListRelationFilter
    questions?: QuizQuestionListRelationFilter
    quizStudents?: QuizStudentListRelationFilter
    quizSubmissions?: QuizSubmissionListRelationFilter
    streamItem?: XOR<StreamItemScalarRelationFilter, StreamItemWhereInput>
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    points?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    dueTime?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedGroups?: SortOrder
    grades?: GradeOrderByRelationAggregateInput
    questions?: QuizQuestionOrderByRelationAggregateInput
    quizStudents?: QuizStudentOrderByRelationAggregateInput
    quizSubmissions?: QuizSubmissionOrderByRelationAggregateInput
    streamItem?: StreamItemOrderByWithRelationInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    streamItemId?: string
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    points?: IntNullableFilter<"Quiz"> | number | null
    dueDate?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    dueTime?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    description?: StringNullableFilter<"Quiz"> | string | null
    assignToAll?: BoolFilter<"Quiz"> | boolean
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    assignedGroups?: StringNullableListFilter<"Quiz">
    grades?: GradeListRelationFilter
    questions?: QuizQuestionListRelationFilter
    quizStudents?: QuizStudentListRelationFilter
    quizSubmissions?: QuizSubmissionListRelationFilter
    streamItem?: XOR<StreamItemScalarRelationFilter, StreamItemWhereInput>
  }, "id" | "streamItemId">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    points?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    dueTime?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedGroups?: SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quiz"> | string
    streamItemId?: StringWithAggregatesFilter<"Quiz"> | string
    points?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Quiz"> | Date | string | null
    dueTime?: DateTimeNullableWithAggregatesFilter<"Quiz"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    assignToAll?: BoolWithAggregatesFilter<"Quiz"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    assignedGroups?: StringNullableListFilter<"Quiz">
  }

  export type QuizQuestionWhereInput = {
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    id?: StringFilter<"QuizQuestion"> | string
    quizId?: StringFilter<"QuizQuestion"> | string
    title?: StringFilter<"QuizQuestion"> | string
    description?: StringNullableFilter<"QuizQuestion"> | string | null
    type?: StringFilter<"QuizQuestion"> | string
    required?: BoolFilter<"QuizQuestion"> | boolean
    points?: IntFilter<"QuizQuestion"> | number
    correctAnswer?: JsonNullableFilter<"QuizQuestion">
    options?: JsonNullableFilter<"QuizQuestion">
    order?: IntFilter<"QuizQuestion"> | number
    createdAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    required?: SortOrder
    points?: SortOrder
    correctAnswer?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quiz?: QuizOrderByWithRelationInput
  }

  export type QuizQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    quizId?: StringFilter<"QuizQuestion"> | string
    title?: StringFilter<"QuizQuestion"> | string
    description?: StringNullableFilter<"QuizQuestion"> | string | null
    type?: StringFilter<"QuizQuestion"> | string
    required?: BoolFilter<"QuizQuestion"> | boolean
    points?: IntFilter<"QuizQuestion"> | number
    correctAnswer?: JsonNullableFilter<"QuizQuestion">
    options?: JsonNullableFilter<"QuizQuestion">
    order?: IntFilter<"QuizQuestion"> | number
    createdAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }, "id">

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    required?: SortOrder
    points?: SortOrder
    correctAnswer?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _avg?: QuizQuestionAvgOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
    _sum?: QuizQuestionSumOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizQuestion"> | string
    quizId?: StringWithAggregatesFilter<"QuizQuestion"> | string
    title?: StringWithAggregatesFilter<"QuizQuestion"> | string
    description?: StringNullableWithAggregatesFilter<"QuizQuestion"> | string | null
    type?: StringWithAggregatesFilter<"QuizQuestion"> | string
    required?: BoolWithAggregatesFilter<"QuizQuestion"> | boolean
    points?: IntWithAggregatesFilter<"QuizQuestion"> | number
    correctAnswer?: JsonNullableWithAggregatesFilter<"QuizQuestion">
    options?: JsonNullableWithAggregatesFilter<"QuizQuestion">
    order?: IntWithAggregatesFilter<"QuizQuestion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuizQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuizQuestion"> | Date | string
  }

  export type QuizStudentWhereInput = {
    AND?: QuizStudentWhereInput | QuizStudentWhereInput[]
    OR?: QuizStudentWhereInput[]
    NOT?: QuizStudentWhereInput | QuizStudentWhereInput[]
    id?: StringFilter<"QuizStudent"> | string
    quizId?: StringFilter<"QuizStudent"> | string
    studentId?: StringFilter<"QuizStudent"> | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type QuizStudentOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    quiz?: QuizOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type QuizStudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quizId_studentId?: QuizStudentQuizIdStudentIdCompoundUniqueInput
    AND?: QuizStudentWhereInput | QuizStudentWhereInput[]
    OR?: QuizStudentWhereInput[]
    NOT?: QuizStudentWhereInput | QuizStudentWhereInput[]
    quizId?: StringFilter<"QuizStudent"> | string
    studentId?: StringFilter<"QuizStudent"> | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "quizId_studentId">

  export type QuizStudentOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    _count?: QuizStudentCountOrderByAggregateInput
    _max?: QuizStudentMaxOrderByAggregateInput
    _min?: QuizStudentMinOrderByAggregateInput
  }

  export type QuizStudentScalarWhereWithAggregatesInput = {
    AND?: QuizStudentScalarWhereWithAggregatesInput | QuizStudentScalarWhereWithAggregatesInput[]
    OR?: QuizStudentScalarWhereWithAggregatesInput[]
    NOT?: QuizStudentScalarWhereWithAggregatesInput | QuizStudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizStudent"> | string
    quizId?: StringWithAggregatesFilter<"QuizStudent"> | string
    studentId?: StringWithAggregatesFilter<"QuizStudent"> | string
  }

  export type QuizSubmissionWhereInput = {
    AND?: QuizSubmissionWhereInput | QuizSubmissionWhereInput[]
    OR?: QuizSubmissionWhereInput[]
    NOT?: QuizSubmissionWhereInput | QuizSubmissionWhereInput[]
    id?: StringFilter<"QuizSubmission"> | string
    quizId?: StringFilter<"QuizSubmission"> | string
    studentId?: StringFilter<"QuizSubmission"> | string
    answers?: JsonNullableFilter<"QuizSubmission">
    status?: StringFilter<"QuizSubmission"> | string
    grade?: DecimalNullableFilter<"QuizSubmission"> | Decimal | DecimalJsLike | number | string | null
    studentComments?: StringNullableFilter<"QuizSubmission"> | string | null
    teacherComments?: StringNullableFilter<"QuizSubmission"> | string | null
    submittedAt?: DateTimeNullableFilter<"QuizSubmission"> | Date | string | null
    gradedAt?: DateTimeNullableFilter<"QuizSubmission"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"QuizSubmission"> | Date | string | null
    createdAt?: DateTimeFilter<"QuizSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"QuizSubmission"> | Date | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type QuizSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    answers?: SortOrderInput | SortOrder
    status?: SortOrder
    grade?: SortOrderInput | SortOrder
    studentComments?: SortOrderInput | SortOrder
    teacherComments?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quiz?: QuizOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type QuizSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quizId_studentId?: QuizSubmissionQuizIdStudentIdCompoundUniqueInput
    AND?: QuizSubmissionWhereInput | QuizSubmissionWhereInput[]
    OR?: QuizSubmissionWhereInput[]
    NOT?: QuizSubmissionWhereInput | QuizSubmissionWhereInput[]
    quizId?: StringFilter<"QuizSubmission"> | string
    studentId?: StringFilter<"QuizSubmission"> | string
    answers?: JsonNullableFilter<"QuizSubmission">
    status?: StringFilter<"QuizSubmission"> | string
    grade?: DecimalNullableFilter<"QuizSubmission"> | Decimal | DecimalJsLike | number | string | null
    studentComments?: StringNullableFilter<"QuizSubmission"> | string | null
    teacherComments?: StringNullableFilter<"QuizSubmission"> | string | null
    submittedAt?: DateTimeNullableFilter<"QuizSubmission"> | Date | string | null
    gradedAt?: DateTimeNullableFilter<"QuizSubmission"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"QuizSubmission"> | Date | string | null
    createdAt?: DateTimeFilter<"QuizSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"QuizSubmission"> | Date | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "quizId_studentId">

  export type QuizSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    answers?: SortOrderInput | SortOrder
    status?: SortOrder
    grade?: SortOrderInput | SortOrder
    studentComments?: SortOrderInput | SortOrder
    teacherComments?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizSubmissionCountOrderByAggregateInput
    _avg?: QuizSubmissionAvgOrderByAggregateInput
    _max?: QuizSubmissionMaxOrderByAggregateInput
    _min?: QuizSubmissionMinOrderByAggregateInput
    _sum?: QuizSubmissionSumOrderByAggregateInput
  }

  export type QuizSubmissionScalarWhereWithAggregatesInput = {
    AND?: QuizSubmissionScalarWhereWithAggregatesInput | QuizSubmissionScalarWhereWithAggregatesInput[]
    OR?: QuizSubmissionScalarWhereWithAggregatesInput[]
    NOT?: QuizSubmissionScalarWhereWithAggregatesInput | QuizSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizSubmission"> | string
    quizId?: StringWithAggregatesFilter<"QuizSubmission"> | string
    studentId?: StringWithAggregatesFilter<"QuizSubmission"> | string
    answers?: JsonNullableWithAggregatesFilter<"QuizSubmission">
    status?: StringWithAggregatesFilter<"QuizSubmission"> | string
    grade?: DecimalNullableWithAggregatesFilter<"QuizSubmission"> | Decimal | DecimalJsLike | number | string | null
    studentComments?: StringNullableWithAggregatesFilter<"QuizSubmission"> | string | null
    teacherComments?: StringNullableWithAggregatesFilter<"QuizSubmission"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"QuizSubmission"> | Date | string | null
    gradedAt?: DateTimeNullableWithAggregatesFilter<"QuizSubmission"> | Date | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"QuizSubmission"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuizSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuizSubmission"> | Date | string
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: StringFilter<"Material"> | string
    streamItemId?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    assignToAll?: BoolFilter<"Material"> | boolean
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    assignedGroups?: StringNullableListFilter<"Material">
    materialStudents?: MaterialStudentListRelationFilter
    streamItem?: XOR<StreamItemScalarRelationFilter, StreamItemWhereInput>
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    description?: SortOrderInput | SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedGroups?: SortOrder
    materialStudents?: MaterialStudentOrderByRelationAggregateInput
    streamItem?: StreamItemOrderByWithRelationInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    streamItemId?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    description?: StringNullableFilter<"Material"> | string | null
    assignToAll?: BoolFilter<"Material"> | boolean
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    assignedGroups?: StringNullableListFilter<"Material">
    materialStudents?: MaterialStudentListRelationFilter
    streamItem?: XOR<StreamItemScalarRelationFilter, StreamItemWhereInput>
  }, "id" | "streamItemId">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    description?: SortOrderInput | SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedGroups?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Material"> | string
    streamItemId?: StringWithAggregatesFilter<"Material"> | string
    description?: StringNullableWithAggregatesFilter<"Material"> | string | null
    assignToAll?: BoolWithAggregatesFilter<"Material"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    assignedGroups?: StringNullableListFilter<"Material">
  }

  export type MaterialStudentWhereInput = {
    AND?: MaterialStudentWhereInput | MaterialStudentWhereInput[]
    OR?: MaterialStudentWhereInput[]
    NOT?: MaterialStudentWhereInput | MaterialStudentWhereInput[]
    id?: StringFilter<"MaterialStudent"> | string
    materialId?: StringFilter<"MaterialStudent"> | string
    studentId?: StringFilter<"MaterialStudent"> | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MaterialStudentOrderByWithRelationInput = {
    id?: SortOrder
    materialId?: SortOrder
    studentId?: SortOrder
    material?: MaterialOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type MaterialStudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    materialId_studentId?: MaterialStudentMaterialIdStudentIdCompoundUniqueInput
    AND?: MaterialStudentWhereInput | MaterialStudentWhereInput[]
    OR?: MaterialStudentWhereInput[]
    NOT?: MaterialStudentWhereInput | MaterialStudentWhereInput[]
    materialId?: StringFilter<"MaterialStudent"> | string
    studentId?: StringFilter<"MaterialStudent"> | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "materialId_studentId">

  export type MaterialStudentOrderByWithAggregationInput = {
    id?: SortOrder
    materialId?: SortOrder
    studentId?: SortOrder
    _count?: MaterialStudentCountOrderByAggregateInput
    _max?: MaterialStudentMaxOrderByAggregateInput
    _min?: MaterialStudentMinOrderByAggregateInput
  }

  export type MaterialStudentScalarWhereWithAggregatesInput = {
    AND?: MaterialStudentScalarWhereWithAggregatesInput | MaterialStudentScalarWhereWithAggregatesInput[]
    OR?: MaterialStudentScalarWhereWithAggregatesInput[]
    NOT?: MaterialStudentScalarWhereWithAggregatesInput | MaterialStudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaterialStudent"> | string
    materialId?: StringWithAggregatesFilter<"MaterialStudent"> | string
    studentId?: StringWithAggregatesFilter<"MaterialStudent"> | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    streamItemId?: StringFilter<"Attachment"> | string
    type?: StringFilter<"Attachment"> | string
    name?: StringFilter<"Attachment"> | string
    url?: StringNullableFilter<"Attachment"> | string | null
    filePath?: StringNullableFilter<"Attachment"> | string | null
    fileSize?: BigIntNullableFilter<"Attachment"> | bigint | number | null
    mimeType?: StringNullableFilter<"Attachment"> | string | null
    order?: IntFilter<"Attachment"> | number
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    streamItem?: XOR<StreamItemScalarRelationFilter, StreamItemWhereInput>
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    streamItem?: StreamItemOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    streamItemId?: StringFilter<"Attachment"> | string
    type?: StringFilter<"Attachment"> | string
    name?: StringFilter<"Attachment"> | string
    url?: StringNullableFilter<"Attachment"> | string | null
    filePath?: StringNullableFilter<"Attachment"> | string | null
    fileSize?: BigIntNullableFilter<"Attachment"> | bigint | number | null
    mimeType?: StringNullableFilter<"Attachment"> | string | null
    order?: IntFilter<"Attachment"> | number
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    streamItem?: XOR<StreamItemScalarRelationFilter, StreamItemWhereInput>
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    streamItemId?: StringWithAggregatesFilter<"Attachment"> | string
    type?: StringWithAggregatesFilter<"Attachment"> | string
    name?: StringWithAggregatesFilter<"Attachment"> | string
    url?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    filePath?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    fileSize?: BigIntNullableWithAggregatesFilter<"Attachment"> | bigint | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    order?: IntWithAggregatesFilter<"Attachment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: StringFilter<"Grade"> | string
    classId?: StringFilter<"Grade"> | string
    assignmentId?: StringNullableFilter<"Grade"> | string | null
    quizId?: StringNullableFilter<"Grade"> | string | null
    studentId?: StringFilter<"Grade"> | string
    pointsEarned?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    maxPoints?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    percentage?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"Grade"> | string
    feedback?: StringNullableFilter<"Grade"> | string | null
    submittedAt?: DateTimeNullableFilter<"Grade"> | Date | string | null
    gradedAt?: DateTimeNullableFilter<"Grade"> | Date | string | null
    gradedById?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
    assignment?: XOR<AssignmentNullableScalarRelationFilter, AssignmentWhereInput> | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    gradedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    quiz?: XOR<QuizNullableScalarRelationFilter, QuizWhereInput> | null
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    assignmentId?: SortOrderInput | SortOrder
    quizId?: SortOrderInput | SortOrder
    studentId?: SortOrder
    pointsEarned?: SortOrderInput | SortOrder
    maxPoints?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    gradedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignment?: AssignmentOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    gradedBy?: UserOrderByWithRelationInput
    quiz?: QuizOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    classId?: StringFilter<"Grade"> | string
    assignmentId?: StringNullableFilter<"Grade"> | string | null
    quizId?: StringNullableFilter<"Grade"> | string | null
    studentId?: StringFilter<"Grade"> | string
    pointsEarned?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    maxPoints?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    percentage?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"Grade"> | string
    feedback?: StringNullableFilter<"Grade"> | string | null
    submittedAt?: DateTimeNullableFilter<"Grade"> | Date | string | null
    gradedAt?: DateTimeNullableFilter<"Grade"> | Date | string | null
    gradedById?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
    assignment?: XOR<AssignmentNullableScalarRelationFilter, AssignmentWhereInput> | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    gradedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    quiz?: XOR<QuizNullableScalarRelationFilter, QuizWhereInput> | null
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    assignmentId?: SortOrderInput | SortOrder
    quizId?: SortOrderInput | SortOrder
    studentId?: SortOrder
    pointsEarned?: SortOrderInput | SortOrder
    maxPoints?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    gradedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GradeCountOrderByAggregateInput
    _avg?: GradeAvgOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
    _sum?: GradeSumOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grade"> | string
    classId?: StringWithAggregatesFilter<"Grade"> | string
    assignmentId?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    quizId?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    studentId?: StringWithAggregatesFilter<"Grade"> | string
    pointsEarned?: DecimalNullableWithAggregatesFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    maxPoints?: DecimalNullableWithAggregatesFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    percentage?: DecimalNullableWithAggregatesFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    status?: StringWithAggregatesFilter<"Grade"> | string
    feedback?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Grade"> | Date | string | null
    gradedAt?: DateTimeNullableWithAggregatesFilter<"Grade"> | Date | string | null
    gradedById?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: StringFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    url?: StringNullableFilter<"Module"> | string | null
    category?: StringNullableFilter<"Module"> | string | null
    difficulty?: StringNullableFilter<"Module"> | string | null
    duration?: IntNullableFilter<"Module"> | number | null
    thumbnail?: StringNullableFilter<"Module"> | string | null
    instructor?: StringNullableFilter<"Module"> | string | null
    isActive?: BoolFilter<"Module"> | boolean
    isPublished?: BoolFilter<"Module"> | boolean
    order?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    createdById?: StringNullableFilter<"Module"> | string | null
    classes?: ClassListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    instructor?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    classes?: ClassOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    url?: StringNullableFilter<"Module"> | string | null
    category?: StringNullableFilter<"Module"> | string | null
    difficulty?: StringNullableFilter<"Module"> | string | null
    duration?: IntNullableFilter<"Module"> | number | null
    thumbnail?: StringNullableFilter<"Module"> | string | null
    instructor?: StringNullableFilter<"Module"> | string | null
    isActive?: BoolFilter<"Module"> | boolean
    isPublished?: BoolFilter<"Module"> | boolean
    order?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    createdById?: StringNullableFilter<"Module"> | string | null
    classes?: ClassListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    instructor?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Module"> | string
    title?: StringWithAggregatesFilter<"Module"> | string
    description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    url?: StringNullableWithAggregatesFilter<"Module"> | string | null
    category?: StringNullableWithAggregatesFilter<"Module"> | string | null
    difficulty?: StringNullableWithAggregatesFilter<"Module"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Module"> | number | null
    thumbnail?: StringNullableWithAggregatesFilter<"Module"> | string | null
    instructor?: StringNullableWithAggregatesFilter<"Module"> | string | null
    isActive?: BoolWithAggregatesFilter<"Module"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Module"> | boolean
    order?: IntWithAggregatesFilter<"Module"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Module"> | string | null
  }

  export type StudentParentWhereInput = {
    AND?: StudentParentWhereInput | StudentParentWhereInput[]
    OR?: StudentParentWhereInput[]
    NOT?: StudentParentWhereInput | StudentParentWhereInput[]
    id?: StringFilter<"StudentParent"> | string
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    relationship?: StringNullableFilter<"StudentParent"> | string | null
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    createdAt?: DateTimeFilter<"StudentParent"> | Date | string
    updatedAt?: DateTimeFilter<"StudentParent"> | Date | string
    parent?: XOR<UserScalarRelationFilter, UserWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StudentParentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationship?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: UserOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type StudentParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_parentId?: StudentParentStudentIdParentIdCompoundUniqueInput
    AND?: StudentParentWhereInput | StudentParentWhereInput[]
    OR?: StudentParentWhereInput[]
    NOT?: StudentParentWhereInput | StudentParentWhereInput[]
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    relationship?: StringNullableFilter<"StudentParent"> | string | null
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    createdAt?: DateTimeFilter<"StudentParent"> | Date | string
    updatedAt?: DateTimeFilter<"StudentParent"> | Date | string
    parent?: XOR<UserScalarRelationFilter, UserWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "studentId_parentId">

  export type StudentParentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationship?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentParentCountOrderByAggregateInput
    _max?: StudentParentMaxOrderByAggregateInput
    _min?: StudentParentMinOrderByAggregateInput
  }

  export type StudentParentScalarWhereWithAggregatesInput = {
    AND?: StudentParentScalarWhereWithAggregatesInput | StudentParentScalarWhereWithAggregatesInput[]
    OR?: StudentParentScalarWhereWithAggregatesInput[]
    NOT?: StudentParentScalarWhereWithAggregatesInput | StudentParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentParent"> | string
    studentId?: StringWithAggregatesFilter<"StudentParent"> | string
    parentId?: StringWithAggregatesFilter<"StudentParent"> | string
    relationship?: StringNullableWithAggregatesFilter<"StudentParent"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"StudentParent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudentParent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentParent"> | Date | string
  }

  export type AnnouncementStudentWhereInput = {
    AND?: AnnouncementStudentWhereInput | AnnouncementStudentWhereInput[]
    OR?: AnnouncementStudentWhereInput[]
    NOT?: AnnouncementStudentWhereInput | AnnouncementStudentWhereInput[]
    id?: StringFilter<"AnnouncementStudent"> | string
    streamItemId?: StringFilter<"AnnouncementStudent"> | string
    studentId?: StringFilter<"AnnouncementStudent"> | string
    streamItem?: XOR<StreamItemScalarRelationFilter, StreamItemWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AnnouncementStudentOrderByWithRelationInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    studentId?: SortOrder
    streamItem?: StreamItemOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type AnnouncementStudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    streamItemId_studentId?: AnnouncementStudentStreamItemIdStudentIdCompoundUniqueInput
    AND?: AnnouncementStudentWhereInput | AnnouncementStudentWhereInput[]
    OR?: AnnouncementStudentWhereInput[]
    NOT?: AnnouncementStudentWhereInput | AnnouncementStudentWhereInput[]
    streamItemId?: StringFilter<"AnnouncementStudent"> | string
    studentId?: StringFilter<"AnnouncementStudent"> | string
    streamItem?: XOR<StreamItemScalarRelationFilter, StreamItemWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "streamItemId_studentId">

  export type AnnouncementStudentOrderByWithAggregationInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    studentId?: SortOrder
    _count?: AnnouncementStudentCountOrderByAggregateInput
    _max?: AnnouncementStudentMaxOrderByAggregateInput
    _min?: AnnouncementStudentMinOrderByAggregateInput
  }

  export type AnnouncementStudentScalarWhereWithAggregatesInput = {
    AND?: AnnouncementStudentScalarWhereWithAggregatesInput | AnnouncementStudentScalarWhereWithAggregatesInput[]
    OR?: AnnouncementStudentScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementStudentScalarWhereWithAggregatesInput | AnnouncementStudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnnouncementStudent"> | string
    streamItemId?: StringWithAggregatesFilter<"AnnouncementStudent"> | string
    studentId?: StringWithAggregatesFilter<"AnnouncementStudent"> | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    companyName?: StringFilter<"Client"> | string
    contactName?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    status?: StringFilter<"Client"> | string
    source?: StringNullableFilter<"Client"> | string | null
    totalProjects?: IntFilter<"Client"> | number
    totalRevenue?: DecimalFilter<"Client"> | Decimal | DecimalJsLike | number | string
    lastContact?: DateTimeNullableFilter<"Client"> | Date | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    eventos?: EventoListRelationFilter
    ordenes?: OrdenListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    status?: SortOrder
    source?: SortOrderInput | SortOrder
    totalProjects?: SortOrder
    totalRevenue?: SortOrder
    lastContact?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eventos?: EventoOrderByRelationAggregateInput
    ordenes?: OrdenOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    companyName?: StringFilter<"Client"> | string
    contactName?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    status?: StringFilter<"Client"> | string
    source?: StringNullableFilter<"Client"> | string | null
    totalProjects?: IntFilter<"Client"> | number
    totalRevenue?: DecimalFilter<"Client"> | Decimal | DecimalJsLike | number | string
    lastContact?: DateTimeNullableFilter<"Client"> | Date | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    eventos?: EventoListRelationFilter
    ordenes?: OrdenListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    status?: SortOrder
    source?: SortOrderInput | SortOrder
    totalProjects?: SortOrder
    totalRevenue?: SortOrder
    lastContact?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    companyName?: StringWithAggregatesFilter<"Client"> | string
    contactName?: StringNullableWithAggregatesFilter<"Client"> | string | null
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    website?: StringNullableWithAggregatesFilter<"Client"> | string | null
    status?: StringWithAggregatesFilter<"Client"> | string
    source?: StringNullableWithAggregatesFilter<"Client"> | string | null
    totalProjects?: IntWithAggregatesFilter<"Client"> | number
    totalRevenue?: DecimalWithAggregatesFilter<"Client"> | Decimal | DecimalJsLike | number | string
    lastContact?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Client"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type EventoWhereInput = {
    AND?: EventoWhereInput | EventoWhereInput[]
    OR?: EventoWhereInput[]
    NOT?: EventoWhereInput | EventoWhereInput[]
    id?: StringFilter<"Evento"> | string
    name?: StringFilter<"Evento"> | string
    date?: DateTimeFilter<"Evento"> | Date | string
    time?: DateTimeNullableFilter<"Evento"> | Date | string | null
    location?: StringNullableFilter<"Evento"> | string | null
    type?: StringFilter<"Evento"> | string
    status?: StringFilter<"Evento"> | string
    attendees?: IntFilter<"Evento"> | number
    description?: StringNullableFilter<"Evento"> | string | null
    clientId?: StringNullableFilter<"Evento"> | string | null
    createdAt?: DateTimeFilter<"Evento"> | Date | string
    updatedAt?: DateTimeFilter<"Evento"> | Date | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type EventoOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    attendees?: SortOrder
    description?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type EventoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventoWhereInput | EventoWhereInput[]
    OR?: EventoWhereInput[]
    NOT?: EventoWhereInput | EventoWhereInput[]
    name?: StringFilter<"Evento"> | string
    date?: DateTimeFilter<"Evento"> | Date | string
    time?: DateTimeNullableFilter<"Evento"> | Date | string | null
    location?: StringNullableFilter<"Evento"> | string | null
    type?: StringFilter<"Evento"> | string
    status?: StringFilter<"Evento"> | string
    attendees?: IntFilter<"Evento"> | number
    description?: StringNullableFilter<"Evento"> | string | null
    clientId?: StringNullableFilter<"Evento"> | string | null
    createdAt?: DateTimeFilter<"Evento"> | Date | string
    updatedAt?: DateTimeFilter<"Evento"> | Date | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type EventoOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    attendees?: SortOrder
    description?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventoCountOrderByAggregateInput
    _avg?: EventoAvgOrderByAggregateInput
    _max?: EventoMaxOrderByAggregateInput
    _min?: EventoMinOrderByAggregateInput
    _sum?: EventoSumOrderByAggregateInput
  }

  export type EventoScalarWhereWithAggregatesInput = {
    AND?: EventoScalarWhereWithAggregatesInput | EventoScalarWhereWithAggregatesInput[]
    OR?: EventoScalarWhereWithAggregatesInput[]
    NOT?: EventoScalarWhereWithAggregatesInput | EventoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evento"> | string
    name?: StringWithAggregatesFilter<"Evento"> | string
    date?: DateTimeWithAggregatesFilter<"Evento"> | Date | string
    time?: DateTimeNullableWithAggregatesFilter<"Evento"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"Evento"> | string | null
    type?: StringWithAggregatesFilter<"Evento"> | string
    status?: StringWithAggregatesFilter<"Evento"> | string
    attendees?: IntWithAggregatesFilter<"Evento"> | number
    description?: StringNullableWithAggregatesFilter<"Evento"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"Evento"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Evento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evento"> | Date | string
  }

  export type OrdenWhereInput = {
    AND?: OrdenWhereInput | OrdenWhereInput[]
    OR?: OrdenWhereInput[]
    NOT?: OrdenWhereInput | OrdenWhereInput[]
    id?: StringFilter<"Orden"> | string
    orderNumber?: StringFilter<"Orden"> | string
    clientId?: StringNullableFilter<"Orden"> | string | null
    clientName?: StringFilter<"Orden"> | string
    clientEmail?: StringNullableFilter<"Orden"> | string | null
    subtotal?: DecimalFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Orden"> | string
    notes?: StringNullableFilter<"Orden"> | string | null
    createdById?: StringFilter<"Orden"> | string
    createdAt?: DateTimeFilter<"Orden"> | Date | string
    updatedAt?: DateTimeFilter<"Orden"> | Date | string
    ordenItems?: OrdenItemListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrdenOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientId?: SortOrderInput | SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ordenItems?: OrdenItemOrderByRelationAggregateInput
    client?: ClientOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type OrdenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: OrdenWhereInput | OrdenWhereInput[]
    OR?: OrdenWhereInput[]
    NOT?: OrdenWhereInput | OrdenWhereInput[]
    clientId?: StringNullableFilter<"Orden"> | string | null
    clientName?: StringFilter<"Orden"> | string
    clientEmail?: StringNullableFilter<"Orden"> | string | null
    subtotal?: DecimalFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Orden"> | string
    notes?: StringNullableFilter<"Orden"> | string | null
    createdById?: StringFilter<"Orden"> | string
    createdAt?: DateTimeFilter<"Orden"> | Date | string
    updatedAt?: DateTimeFilter<"Orden"> | Date | string
    ordenItems?: OrdenItemListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "orderNumber">

  export type OrdenOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientId?: SortOrderInput | SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrdenCountOrderByAggregateInput
    _avg?: OrdenAvgOrderByAggregateInput
    _max?: OrdenMaxOrderByAggregateInput
    _min?: OrdenMinOrderByAggregateInput
    _sum?: OrdenSumOrderByAggregateInput
  }

  export type OrdenScalarWhereWithAggregatesInput = {
    AND?: OrdenScalarWhereWithAggregatesInput | OrdenScalarWhereWithAggregatesInput[]
    OR?: OrdenScalarWhereWithAggregatesInput[]
    NOT?: OrdenScalarWhereWithAggregatesInput | OrdenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Orden"> | string
    orderNumber?: StringWithAggregatesFilter<"Orden"> | string
    clientId?: StringNullableWithAggregatesFilter<"Orden"> | string | null
    clientName?: StringWithAggregatesFilter<"Orden"> | string
    clientEmail?: StringNullableWithAggregatesFilter<"Orden"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Orden"> | string
    notes?: StringNullableWithAggregatesFilter<"Orden"> | string | null
    createdById?: StringWithAggregatesFilter<"Orden"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Orden"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Orden"> | Date | string
  }

  export type OrdenItemWhereInput = {
    AND?: OrdenItemWhereInput | OrdenItemWhereInput[]
    OR?: OrdenItemWhereInput[]
    NOT?: OrdenItemWhereInput | OrdenItemWhereInput[]
    id?: StringFilter<"OrdenItem"> | string
    ordenId?: StringFilter<"OrdenItem"> | string
    code?: StringNullableFilter<"OrdenItem"> | string | null
    title?: StringFilter<"OrdenItem"> | string
    price?: DecimalFilter<"OrdenItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"OrdenItem"> | number
    total?: DecimalFilter<"OrdenItem"> | Decimal | DecimalJsLike | number | string
    order?: IntFilter<"OrdenItem"> | number
    createdAt?: DateTimeFilter<"OrdenItem"> | Date | string
    orden?: XOR<OrdenScalarRelationFilter, OrdenWhereInput>
  }

  export type OrdenItemOrderByWithRelationInput = {
    id?: SortOrder
    ordenId?: SortOrder
    code?: SortOrderInput | SortOrder
    title?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    orden?: OrdenOrderByWithRelationInput
  }

  export type OrdenItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrdenItemWhereInput | OrdenItemWhereInput[]
    OR?: OrdenItemWhereInput[]
    NOT?: OrdenItemWhereInput | OrdenItemWhereInput[]
    ordenId?: StringFilter<"OrdenItem"> | string
    code?: StringNullableFilter<"OrdenItem"> | string | null
    title?: StringFilter<"OrdenItem"> | string
    price?: DecimalFilter<"OrdenItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"OrdenItem"> | number
    total?: DecimalFilter<"OrdenItem"> | Decimal | DecimalJsLike | number | string
    order?: IntFilter<"OrdenItem"> | number
    createdAt?: DateTimeFilter<"OrdenItem"> | Date | string
    orden?: XOR<OrdenScalarRelationFilter, OrdenWhereInput>
  }, "id">

  export type OrdenItemOrderByWithAggregationInput = {
    id?: SortOrder
    ordenId?: SortOrder
    code?: SortOrderInput | SortOrder
    title?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: OrdenItemCountOrderByAggregateInput
    _avg?: OrdenItemAvgOrderByAggregateInput
    _max?: OrdenItemMaxOrderByAggregateInput
    _min?: OrdenItemMinOrderByAggregateInput
    _sum?: OrdenItemSumOrderByAggregateInput
  }

  export type OrdenItemScalarWhereWithAggregatesInput = {
    AND?: OrdenItemScalarWhereWithAggregatesInput | OrdenItemScalarWhereWithAggregatesInput[]
    OR?: OrdenItemScalarWhereWithAggregatesInput[]
    NOT?: OrdenItemScalarWhereWithAggregatesInput | OrdenItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrdenItem"> | string
    ordenId?: StringWithAggregatesFilter<"OrdenItem"> | string
    code?: StringNullableWithAggregatesFilter<"OrdenItem"> | string | null
    title?: StringWithAggregatesFilter<"OrdenItem"> | string
    price?: DecimalWithAggregatesFilter<"OrdenItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter<"OrdenItem"> | number
    total?: DecimalWithAggregatesFilter<"OrdenItem"> | Decimal | DecimalJsLike | number | string
    order?: IntWithAggregatesFilter<"OrdenItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrdenItem"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BugReportCreateInput = {
    id?: string
    description: string
    status?: string
    type?: string
    errorHash?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutBugReportsInput
  }

  export type BugReportUncheckedCreateInput = {
    id?: string
    description: string
    userId?: string | null
    status?: string
    type?: string
    errorHash?: string | null
    createdAt?: Date | string
  }

  export type BugReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    errorHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutBugReportsNestedInput
  }

  export type BugReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    errorHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BugReportCreateManyInput = {
    id?: string
    description: string
    userId?: string | null
    status?: string
    type?: string
    errorHash?: string | null
    createdAt?: Date | string
  }

  export type BugReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    errorHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BugReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    errorHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResidentCreateInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutResidentInput
    medications?: MedicationOrderCreateNestedManyWithoutResidentInput
    vitalSigns?: VitalSignCreateNestedManyWithoutResidentInput
    nursingNotes?: NursingNoteCreateNestedManyWithoutResidentInput
  }

  export type ResidentUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medications?: MedicationOrderUncheckedCreateNestedManyWithoutResidentInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutResidentInput
    nursingNotes?: NursingNoteUncheckedCreateNestedManyWithoutResidentInput
  }

  export type ResidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResidentNestedInput
    medications?: MedicationOrderUpdateManyWithoutResidentNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutResidentNestedInput
    nursingNotes?: NursingNoteUpdateManyWithoutResidentNestedInput
  }

  export type ResidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationOrderUncheckedUpdateManyWithoutResidentNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutResidentNestedInput
    nursingNotes?: NursingNoteUncheckedUpdateManyWithoutResidentNestedInput
  }

  export type ResidentCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationOrderCreateInput = {
    id?: string
    medicationName: string
    dosage: string
    frequency: string
    route: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentCreateNestedOneWithoutMedicationsInput
    logs?: MedicationLogCreateNestedManyWithoutOrderInput
  }

  export type MedicationOrderUncheckedCreateInput = {
    id?: string
    residentId: string
    medicationName: string
    dosage: string
    frequency: string
    route: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: MedicationLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type MedicationOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentUpdateOneRequiredWithoutMedicationsNestedInput
    logs?: MedicationLogUpdateManyWithoutOrderNestedInput
  }

  export type MedicationOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: MedicationLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type MedicationOrderCreateManyInput = {
    id?: string
    residentId: string
    medicationName: string
    dosage: string
    frequency: string
    route: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationLogCreateInput = {
    id?: string
    administeredAt?: Date | string
    status: string
    notes?: string | null
    shift?: string | null
    order: MedicationOrderCreateNestedOneWithoutLogsInput
    administrator: UserCreateNestedOneWithoutMedicationLogsInput
  }

  export type MedicationLogUncheckedCreateInput = {
    id?: string
    orderId: string
    administeredBy: string
    administeredAt?: Date | string
    status: string
    notes?: string | null
    shift?: string | null
  }

  export type MedicationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    order?: MedicationOrderUpdateOneRequiredWithoutLogsNestedInput
    administrator?: UserUpdateOneRequiredWithoutMedicationLogsNestedInput
  }

  export type MedicationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    administeredBy?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationLogCreateManyInput = {
    id?: string
    orderId: string
    administeredBy: string
    administeredAt?: Date | string
    status: string
    notes?: string | null
    shift?: string | null
  }

  export type MedicationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    administeredBy?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VitalSignCreateInput = {
    id?: string
    recordedAt?: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    temperature?: number | null
    oxygenSaturation?: number | null
    glucose?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentCreateNestedOneWithoutVitalSignsInput
    recorder: UserCreateNestedOneWithoutRecordedVitalsInput
  }

  export type VitalSignUncheckedCreateInput = {
    id?: string
    residentId: string
    recordedBy: string
    recordedAt?: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    temperature?: number | null
    oxygenSaturation?: number | null
    glucose?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    glucose?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentUpdateOneRequiredWithoutVitalSignsNestedInput
    recorder?: UserUpdateOneRequiredWithoutRecordedVitalsNestedInput
  }

  export type VitalSignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    glucose?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignCreateManyInput = {
    id?: string
    residentId: string
    recordedBy: string
    recordedAt?: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    temperature?: number | null
    oxygenSaturation?: number | null
    glucose?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    glucose?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    glucose?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NursingNoteCreateInput = {
    id?: string
    createdAt?: Date | string
    shift: string
    category: string
    content: string
    severity?: string
    updatedAt?: Date | string
    resident: ResidentCreateNestedOneWithoutNursingNotesInput
    author: UserCreateNestedOneWithoutAuthoredNotesInput
  }

  export type NursingNoteUncheckedCreateInput = {
    id?: string
    residentId: string
    authorId: string
    createdAt?: Date | string
    shift: string
    category: string
    content: string
    severity?: string
    updatedAt?: Date | string
  }

  export type NursingNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentUpdateOneRequiredWithoutNursingNotesNestedInput
    author?: UserUpdateOneRequiredWithoutAuthoredNotesNestedInput
  }

  export type NursingNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NursingNoteCreateManyInput = {
    id?: string
    residentId: string
    authorId: string
    createdAt?: Date | string
    shift: string
    category: string
    content: string
    severity?: string
    updatedAt?: Date | string
  }

  export type NursingNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NursingNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberCreateNestedManyWithoutClassInput
    module?: ModuleCreateNestedOneWithoutClassesInput
    teacher: UserCreateNestedOneWithoutClassesAsTeacherInput
    grades?: GradeCreateNestedManyWithoutClassInput
    streamItems?: StreamItemCreateNestedManyWithoutClassInput
    topics?: TopicCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    teacherId: string
    moduleId?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberUncheckedCreateNestedManyWithoutClassInput
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutClassInput
    topics?: TopicUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUpdateManyWithoutClassNestedInput
    module?: ModuleUpdateOneWithoutClassesNestedInput
    teacher?: UserUpdateOneRequiredWithoutClassesAsTeacherNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUpdateManyWithoutClassNestedInput
    topics?: TopicUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUncheckedUpdateManyWithoutClassNestedInput
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutClassNestedInput
    topics?: TopicUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    teacherId: string
    moduleId?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassMemberCreateInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    status?: string
    class: ClassCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutClassMembershipsInput
  }

  export type ClassMemberUncheckedCreateInput = {
    id?: string
    classId: string
    userId: string
    role?: string
    joinedAt?: Date | string
    status?: string
  }

  export type ClassMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutClassMembershipsNestedInput
  }

  export type ClassMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClassMemberCreateManyInput = {
    id?: string
    classId: string
    userId: string
    role?: string
    joinedAt?: Date | string
    status?: string
  }

  export type ClassMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClassMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TopicCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    streamItems?: StreamItemCreateNestedManyWithoutTopicInput
    class: ClassCreateNestedOneWithoutTopicsInput
  }

  export type TopicUncheckedCreateInput = {
    id?: string
    classId: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streamItems?: StreamItemUpdateManyWithoutTopicNestedInput
    class?: ClassUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streamItems?: StreamItemUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicCreateManyInput = {
    id?: string
    classId: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamItemCreateInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentCreateNestedManyWithoutStreamItemInput
    material?: MaterialCreateNestedOneWithoutStreamItemInput
    quiz?: QuizCreateNestedOneWithoutStreamItemInput
    author: UserCreateNestedOneWithoutStreamItemsInput
    class?: ClassCreateNestedOneWithoutStreamItemsInput
    topic?: TopicCreateNestedOneWithoutStreamItemsInput
  }

  export type StreamItemUncheckedCreateInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    authorId: string
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStreamItemInput
    material?: MaterialUncheckedCreateNestedOneWithoutStreamItemInput
    quiz?: QuizUncheckedCreateNestedOneWithoutStreamItemInput
  }

  export type StreamItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUpdateOneWithoutStreamItemNestedInput
    author?: UserUpdateOneRequiredWithoutStreamItemsNestedInput
    class?: ClassUpdateOneWithoutStreamItemsNestedInput
    topic?: TopicUpdateOneWithoutStreamItemsNestedInput
  }

  export type StreamItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUncheckedUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUncheckedUpdateOneWithoutStreamItemNestedInput
  }

  export type StreamItemCreateManyInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    authorId: string
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
  }

  export type StreamItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StreamItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssignmentCreateInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutAssignmentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
    streamItem: StreamItemCreateNestedOneWithoutAssignmentInput
    grades?: GradeCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutAssignmentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
    grades?: GradeUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentStudents?: AssignmentStudentUpdateManyWithoutAssignmentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
    streamItem?: StreamItemUpdateOneRequiredWithoutAssignmentNestedInput
    grades?: GradeUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutAssignmentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentCreateManyInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type AssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssignmentStudentCreateInput = {
    id?: string
    assignment: AssignmentCreateNestedOneWithoutAssignmentStudentsInput
    student: UserCreateNestedOneWithoutAssignmentStudentsInput
  }

  export type AssignmentStudentUncheckedCreateInput = {
    id?: string
    assignmentId: string
    studentId: string
  }

  export type AssignmentStudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignment?: AssignmentUpdateOneRequiredWithoutAssignmentStudentsNestedInput
    student?: UserUpdateOneRequiredWithoutAssignmentStudentsNestedInput
  }

  export type AssignmentStudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentStudentCreateManyInput = {
    id?: string
    assignmentId: string
    studentId: string
  }

  export type AssignmentStudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentStudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentSubmissionCreateInput = {
    id?: string
    content?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    submittedAt?: Date | string | null
    returnedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    reviewedAt?: Date | string | null
    assignment: AssignmentCreateNestedOneWithoutAssignmentSubmissionsInput
    student: UserCreateNestedOneWithoutAssignmentSubmissionsInput
  }

  export type AssignmentSubmissionUncheckedCreateInput = {
    id?: string
    assignmentId: string
    studentId: string
    content?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    submittedAt?: Date | string | null
    returnedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    reviewedAt?: Date | string | null
  }

  export type AssignmentSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment?: AssignmentUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput
    student?: UserUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignmentSubmissionCreateManyInput = {
    id?: string
    assignmentId: string
    studentId: string
    content?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    submittedAt?: Date | string | null
    returnedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    reviewedAt?: Date | string | null
  }

  export type AssignmentSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignmentSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizCreateInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    grades?: GradeCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    quizStudents?: QuizStudentCreateNestedManyWithoutQuizInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutQuizInput
    streamItem: StreamItemCreateNestedOneWithoutQuizInput
  }

  export type QuizUncheckedCreateInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    grades?: GradeUncheckedCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutQuizInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    grades?: GradeUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutQuizNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutQuizNestedInput
    streamItem?: StreamItemUpdateOneRequiredWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    grades?: GradeUncheckedUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutQuizNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateManyInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
  }

  export type QuizUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
  }

  export type QuizQuestionCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    required?: boolean
    points?: number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz: QuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: string
    quizId: string
    title: string
    description?: string | null
    type: string
    required?: boolean
    points?: number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateManyInput = {
    id?: string
    quizId: string
    title: string
    description?: string | null
    type: string
    required?: boolean
    points?: number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizStudentCreateInput = {
    id?: string
    quiz: QuizCreateNestedOneWithoutQuizStudentsInput
    student: UserCreateNestedOneWithoutQuizStudentsInput
  }

  export type QuizStudentUncheckedCreateInput = {
    id?: string
    quizId: string
    studentId: string
  }

  export type QuizStudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz?: QuizUpdateOneRequiredWithoutQuizStudentsNestedInput
    student?: UserUpdateOneRequiredWithoutQuizStudentsNestedInput
  }

  export type QuizStudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type QuizStudentCreateManyInput = {
    id?: string
    quizId: string
    studentId: string
  }

  export type QuizStudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type QuizStudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type QuizSubmissionCreateInput = {
    id?: string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz: QuizCreateNestedOneWithoutQuizSubmissionsInput
    student: UserCreateNestedOneWithoutQuizSubmissionsInput
  }

  export type QuizSubmissionUncheckedCreateInput = {
    id?: string
    quizId: string
    studentId: string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutQuizSubmissionsNestedInput
    student?: UserUpdateOneRequiredWithoutQuizSubmissionsNestedInput
  }

  export type QuizSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSubmissionCreateManyInput = {
    id?: string
    quizId: string
    studentId: string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateInput = {
    id?: string
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: MaterialCreateassignedGroupsInput | string[]
    materialStudents?: MaterialStudentCreateNestedManyWithoutMaterialInput
    streamItem: StreamItemCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: string
    streamItemId: string
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: MaterialCreateassignedGroupsInput | string[]
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: MaterialUpdateassignedGroupsInput | string[]
    materialStudents?: MaterialStudentUpdateManyWithoutMaterialNestedInput
    streamItem?: StreamItemUpdateOneRequiredWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: MaterialUpdateassignedGroupsInput | string[]
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: string
    streamItemId: string
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: MaterialCreateassignedGroupsInput | string[]
  }

  export type MaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: MaterialUpdateassignedGroupsInput | string[]
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: MaterialUpdateassignedGroupsInput | string[]
  }

  export type MaterialStudentCreateInput = {
    id?: string
    material: MaterialCreateNestedOneWithoutMaterialStudentsInput
    student: UserCreateNestedOneWithoutMaterialStudentsInput
  }

  export type MaterialStudentUncheckedCreateInput = {
    id?: string
    materialId: string
    studentId: string
  }

  export type MaterialStudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    material?: MaterialUpdateOneRequiredWithoutMaterialStudentsNestedInput
    student?: UserUpdateOneRequiredWithoutMaterialStudentsNestedInput
  }

  export type MaterialStudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialStudentCreateManyInput = {
    id?: string
    materialId: string
    studentId: string
  }

  export type MaterialStudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialStudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentCreateInput = {
    id?: string
    type: string
    name: string
    url?: string | null
    filePath?: string | null
    fileSize?: bigint | number | null
    mimeType?: string | null
    order?: number
    createdAt?: Date | string
    streamItem: StreamItemCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    streamItemId: string
    type: string
    name: string
    url?: string | null
    filePath?: string | null
    fileSize?: bigint | number | null
    mimeType?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streamItem?: StreamItemUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyInput = {
    id?: string
    streamItemId: string
    type: string
    name: string
    url?: string | null
    filePath?: string | null
    fileSize?: bigint | number | null
    mimeType?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateInput = {
    id?: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment?: AssignmentCreateNestedOneWithoutGradesInput
    class: ClassCreateNestedOneWithoutGradesInput
    gradedBy?: UserCreateNestedOneWithoutGradesAsGraderInput
    quiz?: QuizCreateNestedOneWithoutGradesInput
    student: UserCreateNestedOneWithoutGradesAsStudentInput
  }

  export type GradeUncheckedCreateInput = {
    id?: string
    classId: string
    assignmentId?: string | null
    quizId?: string | null
    studentId: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneWithoutGradesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradesNestedInput
    gradedBy?: UserUpdateOneWithoutGradesAsGraderNestedInput
    quiz?: QuizUpdateOneWithoutGradesNestedInput
    student?: UserUpdateOneRequiredWithoutGradesAsStudentNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateManyInput = {
    id?: string
    classId: string
    assignmentId?: string | null
    quizId?: string | null
    studentId: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    category?: string | null
    difficulty?: string | null
    duration?: number | null
    thumbnail?: string | null
    instructor?: string | null
    isActive?: boolean
    isPublished?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutModuleInput
    createdBy?: UserCreateNestedOneWithoutModulesCreatedInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    category?: string | null
    difficulty?: string | null
    duration?: number | null
    thumbnail?: string | null
    instructor?: string | null
    isActive?: boolean
    isPublished?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    classes?: ClassUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutModuleNestedInput
    createdBy?: UserUpdateOneWithoutModulesCreatedNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: ClassUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    category?: string | null
    difficulty?: string | null
    duration?: number | null
    thumbnail?: string | null
    instructor?: string | null
    isActive?: boolean
    isPublished?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentParentCreateInput = {
    id?: string
    relationship?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent: UserCreateNestedOneWithoutParentRelationsInput
    student: UserCreateNestedOneWithoutStudentParentsInput
  }

  export type StudentParentUncheckedCreateInput = {
    id?: string
    studentId: string
    parentId: string
    relationship?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: UserUpdateOneRequiredWithoutParentRelationsNestedInput
    student?: UserUpdateOneRequiredWithoutStudentParentsNestedInput
  }

  export type StudentParentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateManyInput = {
    id?: string
    studentId: string
    parentId: string
    relationship?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementStudentCreateInput = {
    id?: string
    streamItem: StreamItemCreateNestedOneWithoutAnnouncementStudentsInput
    student: UserCreateNestedOneWithoutAnnouncementStudentsInput
  }

  export type AnnouncementStudentUncheckedCreateInput = {
    id?: string
    streamItemId: string
    studentId: string
  }

  export type AnnouncementStudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItem?: StreamItemUpdateOneRequiredWithoutAnnouncementStudentsNestedInput
    student?: UserUpdateOneRequiredWithoutAnnouncementStudentsNestedInput
  }

  export type AnnouncementStudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type AnnouncementStudentCreateManyInput = {
    id?: string
    streamItemId: string
    studentId: string
  }

  export type AnnouncementStudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AnnouncementStudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientCreateInput = {
    id?: string
    companyName: string
    contactName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    status?: string
    source?: string | null
    totalProjects?: number
    totalRevenue?: Decimal | DecimalJsLike | number | string
    lastContact?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventos?: EventoCreateNestedManyWithoutClientInput
    ordenes?: OrdenCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    companyName: string
    contactName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    status?: string
    source?: string | null
    totalProjects?: number
    totalRevenue?: Decimal | DecimalJsLike | number | string
    lastContact?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventos?: EventoUncheckedCreateNestedManyWithoutClientInput
    ordenes?: OrdenUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    totalProjects?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventos?: EventoUpdateManyWithoutClientNestedInput
    ordenes?: OrdenUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    totalProjects?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventos?: EventoUncheckedUpdateManyWithoutClientNestedInput
    ordenes?: OrdenUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    companyName: string
    contactName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    status?: string
    source?: string | null
    totalProjects?: number
    totalRevenue?: Decimal | DecimalJsLike | number | string
    lastContact?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    totalProjects?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    totalProjects?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoCreateInput = {
    id?: string
    name: string
    date: Date | string
    time?: Date | string | null
    location?: string | null
    type: string
    status?: string
    attendees?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutEventosInput
  }

  export type EventoUncheckedCreateInput = {
    id?: string
    name: string
    date: Date | string
    time?: Date | string | null
    location?: string | null
    type: string
    status?: string
    attendees?: number
    description?: string | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attendees?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutEventosNestedInput
  }

  export type EventoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attendees?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoCreateManyInput = {
    id?: string
    name: string
    date: Date | string
    time?: Date | string | null
    location?: string | null
    type: string
    status?: string
    attendees?: number
    description?: string | null
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attendees?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attendees?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdenCreateInput = {
    id?: string
    orderNumber: string
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordenItems?: OrdenItemCreateNestedManyWithoutOrdenInput
    client?: ClientCreateNestedOneWithoutOrdenesInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
  }

  export type OrdenUncheckedCreateInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ordenItems?: OrdenItemUncheckedCreateNestedManyWithoutOrdenInput
  }

  export type OrdenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordenItems?: OrdenItemUpdateManyWithoutOrdenNestedInput
    client?: ClientUpdateOneWithoutOrdenesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
  }

  export type OrdenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordenItems?: OrdenItemUncheckedUpdateManyWithoutOrdenNestedInput
  }

  export type OrdenCreateManyInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrdenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdenItemCreateInput = {
    id?: string
    code?: string | null
    title: string
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    total: Decimal | DecimalJsLike | number | string
    order?: number
    createdAt?: Date | string
    orden: OrdenCreateNestedOneWithoutOrdenItemsInput
  }

  export type OrdenItemUncheckedCreateInput = {
    id?: string
    ordenId: string
    code?: string | null
    title: string
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    total: Decimal | DecimalJsLike | number | string
    order?: number
    createdAt?: Date | string
  }

  export type OrdenItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: OrdenUpdateOneRequiredWithoutOrdenItemsNestedInput
  }

  export type OrdenItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ordenId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdenItemCreateManyInput = {
    id?: string
    ordenId: string
    code?: string | null
    title: string
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    total: Decimal | DecimalJsLike | number | string
    order?: number
    createdAt?: Date | string
  }

  export type OrdenItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdenItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ordenId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AnnouncementStudentListRelationFilter = {
    every?: AnnouncementStudentWhereInput
    some?: AnnouncementStudentWhereInput
    none?: AnnouncementStudentWhereInput
  }

  export type AssignmentStudentListRelationFilter = {
    every?: AssignmentStudentWhereInput
    some?: AssignmentStudentWhereInput
    none?: AssignmentStudentWhereInput
  }

  export type AssignmentSubmissionListRelationFilter = {
    every?: AssignmentSubmissionWhereInput
    some?: AssignmentSubmissionWhereInput
    none?: AssignmentSubmissionWhereInput
  }

  export type ClassMemberListRelationFilter = {
    every?: ClassMemberWhereInput
    some?: ClassMemberWhereInput
    none?: ClassMemberWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type GradeListRelationFilter = {
    every?: GradeWhereInput
    some?: GradeWhereInput
    none?: GradeWhereInput
  }

  export type MaterialStudentListRelationFilter = {
    every?: MaterialStudentWhereInput
    some?: MaterialStudentWhereInput
    none?: MaterialStudentWhereInput
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type OrdenListRelationFilter = {
    every?: OrdenWhereInput
    some?: OrdenWhereInput
    none?: OrdenWhereInput
  }

  export type QuizStudentListRelationFilter = {
    every?: QuizStudentWhereInput
    some?: QuizStudentWhereInput
    none?: QuizStudentWhereInput
  }

  export type QuizSubmissionListRelationFilter = {
    every?: QuizSubmissionWhereInput
    some?: QuizSubmissionWhereInput
    none?: QuizSubmissionWhereInput
  }

  export type StreamItemListRelationFilter = {
    every?: StreamItemWhereInput
    some?: StreamItemWhereInput
    none?: StreamItemWhereInput
  }

  export type StudentParentListRelationFilter = {
    every?: StudentParentWhereInput
    some?: StudentParentWhereInput
    none?: StudentParentWhereInput
  }

  export type BugReportListRelationFilter = {
    every?: BugReportWhereInput
    some?: BugReportWhereInput
    none?: BugReportWhereInput
  }

  export type ResidentNullableScalarRelationFilter = {
    is?: ResidentWhereInput | null
    isNot?: ResidentWhereInput | null
  }

  export type MedicationLogListRelationFilter = {
    every?: MedicationLogWhereInput
    some?: MedicationLogWhereInput
    none?: MedicationLogWhereInput
  }

  export type VitalSignListRelationFilter = {
    every?: VitalSignWhereInput
    some?: VitalSignWhereInput
    none?: VitalSignWhereInput
  }

  export type NursingNoteListRelationFilter = {
    every?: NursingNoteWhereInput
    some?: NursingNoteWhereInput
    none?: NursingNoteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AnnouncementStudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentStudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialStudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizStudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StreamItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentParentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BugReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitalSignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NursingNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grupoAsignado?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grupoAsignado?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grupoAsignado?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BugReportCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    errorHash?: SortOrder
    createdAt?: SortOrder
  }

  export type BugReportMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    errorHash?: SortOrder
    createdAt?: SortOrder
  }

  export type BugReportMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    errorHash?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MedicationOrderListRelationFilter = {
    every?: MedicationOrderWhereInput
    some?: MedicationOrderWhereInput
    none?: MedicationOrderWhereInput
  }

  export type MedicationOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResidentCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    roomNumber?: SortOrder
    status?: SortOrder
    emergencyContact?: SortOrder
    allergies?: SortOrder
    conditions?: SortOrder
    carePlanSummary?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResidentMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    roomNumber?: SortOrder
    status?: SortOrder
    allergies?: SortOrder
    conditions?: SortOrder
    carePlanSummary?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResidentMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    roomNumber?: SortOrder
    status?: SortOrder
    allergies?: SortOrder
    conditions?: SortOrder
    carePlanSummary?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ResidentScalarRelationFilter = {
    is?: ResidentWhereInput
    isNot?: ResidentWhereInput
  }

  export type MedicationOrderCountOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationOrderMinOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    route?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type MedicationOrderScalarRelationFilter = {
    is?: MedicationOrderWhereInput
    isNot?: MedicationOrderWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type MedicationLogCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    administeredBy?: SortOrder
    administeredAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    shift?: SortOrder
  }

  export type MedicationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    administeredBy?: SortOrder
    administeredAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    shift?: SortOrder
  }

  export type MedicationLogMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    administeredBy?: SortOrder
    administeredAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    shift?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VitalSignCountOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    temperature?: SortOrder
    oxygenSaturation?: SortOrder
    glucose?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VitalSignAvgOrderByAggregateInput = {
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    temperature?: SortOrder
    oxygenSaturation?: SortOrder
    glucose?: SortOrder
    weight?: SortOrder
  }

  export type VitalSignMaxOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    temperature?: SortOrder
    oxygenSaturation?: SortOrder
    glucose?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VitalSignMinOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    temperature?: SortOrder
    oxygenSaturation?: SortOrder
    glucose?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VitalSignSumOrderByAggregateInput = {
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    temperature?: SortOrder
    oxygenSaturation?: SortOrder
    glucose?: SortOrder
    weight?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NursingNoteCountOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    shift?: SortOrder
    category?: SortOrder
    content?: SortOrder
    severity?: SortOrder
    updatedAt?: SortOrder
  }

  export type NursingNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    shift?: SortOrder
    category?: SortOrder
    content?: SortOrder
    severity?: SortOrder
    updatedAt?: SortOrder
  }

  export type NursingNoteMinOrderByAggregateInput = {
    id?: SortOrder
    residentId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    shift?: SortOrder
    category?: SortOrder
    content?: SortOrder
    severity?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleNullableScalarRelationFilter = {
    is?: ModuleWhereInput | null
    isNot?: ModuleWhereInput | null
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    classCode?: SortOrder
    section?: SortOrder
    subject?: SortOrder
    room?: SortOrder
    teacherId?: SortOrder
    moduleId?: SortOrder
    backgroundImage?: SortOrder
    isArchived?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    classCode?: SortOrder
    section?: SortOrder
    subject?: SortOrder
    room?: SortOrder
    teacherId?: SortOrder
    moduleId?: SortOrder
    backgroundImage?: SortOrder
    isArchived?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    classCode?: SortOrder
    section?: SortOrder
    subject?: SortOrder
    room?: SortOrder
    teacherId?: SortOrder
    moduleId?: SortOrder
    backgroundImage?: SortOrder
    isArchived?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type ClassMemberClassIdUserIdCompoundUniqueInput = {
    classId: string
    userId: string
  }

  export type ClassMemberCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type ClassMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type ClassMemberMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AssignmentNullableScalarRelationFilter = {
    is?: AssignmentWhereInput | null
    isNot?: AssignmentWhereInput | null
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type MaterialNullableScalarRelationFilter = {
    is?: MaterialWhereInput | null
    isNot?: MaterialWhereInput | null
  }

  export type QuizNullableScalarRelationFilter = {
    is?: QuizWhereInput | null
    isNot?: QuizWhereInput | null
  }

  export type ClassNullableScalarRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type TopicNullableScalarRelationFilter = {
    is?: TopicWhereInput | null
    isNot?: TopicWhereInput | null
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StreamItemCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isArchived?: SortOrder
  }

  export type StreamItemMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isArchived?: SortOrder
  }

  export type StreamItemMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isArchived?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StreamItemScalarRelationFilter = {
    is?: StreamItemWhereInput
    isNot?: StreamItemWhereInput
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    points?: SortOrder
    dueDate?: SortOrder
    dueTime?: SortOrder
    instructions?: SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedGroups?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    points?: SortOrder
    dueDate?: SortOrder
    dueTime?: SortOrder
    instructions?: SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    points?: SortOrder
    dueDate?: SortOrder
    dueTime?: SortOrder
    instructions?: SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AssignmentScalarRelationFilter = {
    is?: AssignmentWhereInput
    isNot?: AssignmentWhereInput
  }

  export type AssignmentStudentAssignmentIdStudentIdCompoundUniqueInput = {
    assignmentId: string
    studentId: string
  }

  export type AssignmentStudentCountOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
  }

  export type AssignmentStudentMaxOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
  }

  export type AssignmentStudentMinOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AssignmentSubmissionAssignmentIdStudentIdCompoundUniqueInput = {
    assignmentId: string
    studentId: string
  }

  export type AssignmentSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    returnedAt?: SortOrder
    gradedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grade?: SortOrder
    studentComments?: SortOrder
    teacherComments?: SortOrder
    reviewedAt?: SortOrder
  }

  export type AssignmentSubmissionAvgOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type AssignmentSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    returnedAt?: SortOrder
    gradedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grade?: SortOrder
    studentComments?: SortOrder
    teacherComments?: SortOrder
    reviewedAt?: SortOrder
  }

  export type AssignmentSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    returnedAt?: SortOrder
    gradedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grade?: SortOrder
    studentComments?: SortOrder
    teacherComments?: SortOrder
    reviewedAt?: SortOrder
  }

  export type AssignmentSubmissionSumOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    points?: SortOrder
    dueDate?: SortOrder
    dueTime?: SortOrder
    description?: SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedGroups?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    points?: SortOrder
    dueDate?: SortOrder
    dueTime?: SortOrder
    description?: SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    points?: SortOrder
    dueDate?: SortOrder
    dueTime?: SortOrder
    description?: SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type QuizScalarRelationFilter = {
    is?: QuizWhereInput
    isNot?: QuizWhereInput
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    required?: SortOrder
    points?: SortOrder
    correctAnswer?: SortOrder
    options?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionAvgOrderByAggregateInput = {
    points?: SortOrder
    order?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    required?: SortOrder
    points?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    required?: SortOrder
    points?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionSumOrderByAggregateInput = {
    points?: SortOrder
    order?: SortOrder
  }

  export type QuizStudentQuizIdStudentIdCompoundUniqueInput = {
    quizId: string
    studentId: string
  }

  export type QuizStudentCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
  }

  export type QuizStudentMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
  }

  export type QuizStudentMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
  }

  export type QuizSubmissionQuizIdStudentIdCompoundUniqueInput = {
    quizId: string
    studentId: string
  }

  export type QuizSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    answers?: SortOrder
    status?: SortOrder
    grade?: SortOrder
    studentComments?: SortOrder
    teacherComments?: SortOrder
    submittedAt?: SortOrder
    gradedAt?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSubmissionAvgOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type QuizSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    grade?: SortOrder
    studentComments?: SortOrder
    teacherComments?: SortOrder
    submittedAt?: SortOrder
    gradedAt?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    grade?: SortOrder
    studentComments?: SortOrder
    teacherComments?: SortOrder
    submittedAt?: SortOrder
    gradedAt?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSubmissionSumOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    description?: SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedGroups?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    description?: SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    description?: SortOrder
    assignToAll?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialScalarRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type MaterialStudentMaterialIdStudentIdCompoundUniqueInput = {
    materialId: string
    studentId: string
  }

  export type MaterialStudentCountOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    studentId?: SortOrder
  }

  export type MaterialStudentMaxOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    studentId?: SortOrder
  }

  export type MaterialStudentMinOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    studentId?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    order?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
    order?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    assignmentId?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    pointsEarned?: SortOrder
    maxPoints?: SortOrder
    percentage?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    submittedAt?: SortOrder
    gradedAt?: SortOrder
    gradedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeAvgOrderByAggregateInput = {
    pointsEarned?: SortOrder
    maxPoints?: SortOrder
    percentage?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    assignmentId?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    pointsEarned?: SortOrder
    maxPoints?: SortOrder
    percentage?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    submittedAt?: SortOrder
    gradedAt?: SortOrder
    gradedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    assignmentId?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    pointsEarned?: SortOrder
    maxPoints?: SortOrder
    percentage?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    submittedAt?: SortOrder
    gradedAt?: SortOrder
    gradedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeSumOrderByAggregateInput = {
    pointsEarned?: SortOrder
    maxPoints?: SortOrder
    percentage?: SortOrder
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    thumbnail?: SortOrder
    instructor?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    thumbnail?: SortOrder
    instructor?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    thumbnail?: SortOrder
    instructor?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
  }

  export type StudentParentStudentIdParentIdCompoundUniqueInput = {
    studentId: string
    parentId: string
  }

  export type StudentParentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationship?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentParentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationship?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentParentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationship?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementStudentStreamItemIdStudentIdCompoundUniqueInput = {
    streamItemId: string
    studentId: string
  }

  export type AnnouncementStudentCountOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    studentId?: SortOrder
  }

  export type AnnouncementStudentMaxOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    studentId?: SortOrder
  }

  export type AnnouncementStudentMinOrderByAggregateInput = {
    id?: SortOrder
    streamItemId?: SortOrder
    studentId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EventoListRelationFilter = {
    every?: EventoWhereInput
    some?: EventoWhereInput
    none?: EventoWhereInput
  }

  export type EventoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    status?: SortOrder
    source?: SortOrder
    totalProjects?: SortOrder
    totalRevenue?: SortOrder
    lastContact?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    totalProjects?: SortOrder
    totalRevenue?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    status?: SortOrder
    source?: SortOrder
    totalProjects?: SortOrder
    totalRevenue?: SortOrder
    lastContact?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    status?: SortOrder
    source?: SortOrder
    totalProjects?: SortOrder
    totalRevenue?: SortOrder
    lastContact?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    totalProjects?: SortOrder
    totalRevenue?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type EventoCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    type?: SortOrder
    status?: SortOrder
    attendees?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventoAvgOrderByAggregateInput = {
    attendees?: SortOrder
  }

  export type EventoMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    type?: SortOrder
    status?: SortOrder
    attendees?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventoMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    type?: SortOrder
    status?: SortOrder
    attendees?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventoSumOrderByAggregateInput = {
    attendees?: SortOrder
  }

  export type OrdenItemListRelationFilter = {
    every?: OrdenItemWhereInput
    some?: OrdenItemWhereInput
    none?: OrdenItemWhereInput
  }

  export type OrdenItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdenCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientId?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrdenAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    discount?: SortOrder
    total?: SortOrder
  }

  export type OrdenMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientId?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrdenMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientId?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrdenSumOrderByAggregateInput = {
    subtotal?: SortOrder
    discount?: SortOrder
    total?: SortOrder
  }

  export type OrdenScalarRelationFilter = {
    is?: OrdenWhereInput
    isNot?: OrdenWhereInput
  }

  export type OrdenItemCountOrderByAggregateInput = {
    id?: SortOrder
    ordenId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type OrdenItemAvgOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    order?: SortOrder
  }

  export type OrdenItemMaxOrderByAggregateInput = {
    id?: SortOrder
    ordenId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type OrdenItemMinOrderByAggregateInput = {
    id?: SortOrder
    ordenId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type OrdenItemSumOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    order?: SortOrder
  }

  export type AnnouncementStudentCreateNestedManyWithoutStudentInput = {
    create?: XOR<AnnouncementStudentCreateWithoutStudentInput, AnnouncementStudentUncheckedCreateWithoutStudentInput> | AnnouncementStudentCreateWithoutStudentInput[] | AnnouncementStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AnnouncementStudentCreateOrConnectWithoutStudentInput | AnnouncementStudentCreateOrConnectWithoutStudentInput[]
    createMany?: AnnouncementStudentCreateManyStudentInputEnvelope
    connect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
  }

  export type AssignmentStudentCreateNestedManyWithoutStudentInput = {
    create?: XOR<AssignmentStudentCreateWithoutStudentInput, AssignmentStudentUncheckedCreateWithoutStudentInput> | AssignmentStudentCreateWithoutStudentInput[] | AssignmentStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentStudentCreateOrConnectWithoutStudentInput | AssignmentStudentCreateOrConnectWithoutStudentInput[]
    createMany?: AssignmentStudentCreateManyStudentInputEnvelope
    connect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
  }

  export type AssignmentSubmissionCreateNestedManyWithoutStudentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type ClassMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ClassMemberCreateWithoutUserInput, ClassMemberUncheckedCreateWithoutUserInput> | ClassMemberCreateWithoutUserInput[] | ClassMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassMemberCreateOrConnectWithoutUserInput | ClassMemberCreateOrConnectWithoutUserInput[]
    createMany?: ClassMemberCreateManyUserInputEnvelope
    connect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutGradedByInput = {
    create?: XOR<GradeCreateWithoutGradedByInput, GradeUncheckedCreateWithoutGradedByInput> | GradeCreateWithoutGradedByInput[] | GradeUncheckedCreateWithoutGradedByInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutGradedByInput | GradeCreateOrConnectWithoutGradedByInput[]
    createMany?: GradeCreateManyGradedByInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutStudentInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type MaterialStudentCreateNestedManyWithoutStudentInput = {
    create?: XOR<MaterialStudentCreateWithoutStudentInput, MaterialStudentUncheckedCreateWithoutStudentInput> | MaterialStudentCreateWithoutStudentInput[] | MaterialStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MaterialStudentCreateOrConnectWithoutStudentInput | MaterialStudentCreateOrConnectWithoutStudentInput[]
    createMany?: MaterialStudentCreateManyStudentInputEnvelope
    connect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ModuleCreateWithoutCreatedByInput, ModuleUncheckedCreateWithoutCreatedByInput> | ModuleCreateWithoutCreatedByInput[] | ModuleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCreatedByInput | ModuleCreateOrConnectWithoutCreatedByInput[]
    createMany?: ModuleCreateManyCreatedByInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type OrdenCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OrdenCreateWithoutCreatedByInput, OrdenUncheckedCreateWithoutCreatedByInput> | OrdenCreateWithoutCreatedByInput[] | OrdenUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrdenCreateOrConnectWithoutCreatedByInput | OrdenCreateOrConnectWithoutCreatedByInput[]
    createMany?: OrdenCreateManyCreatedByInputEnvelope
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
  }

  export type QuizStudentCreateNestedManyWithoutStudentInput = {
    create?: XOR<QuizStudentCreateWithoutStudentInput, QuizStudentUncheckedCreateWithoutStudentInput> | QuizStudentCreateWithoutStudentInput[] | QuizStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizStudentCreateOrConnectWithoutStudentInput | QuizStudentCreateOrConnectWithoutStudentInput[]
    createMany?: QuizStudentCreateManyStudentInputEnvelope
    connect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
  }

  export type QuizSubmissionCreateNestedManyWithoutStudentInput = {
    create?: XOR<QuizSubmissionCreateWithoutStudentInput, QuizSubmissionUncheckedCreateWithoutStudentInput> | QuizSubmissionCreateWithoutStudentInput[] | QuizSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizSubmissionCreateOrConnectWithoutStudentInput | QuizSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: QuizSubmissionCreateManyStudentInputEnvelope
    connect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
  }

  export type StreamItemCreateNestedManyWithoutAuthorInput = {
    create?: XOR<StreamItemCreateWithoutAuthorInput, StreamItemUncheckedCreateWithoutAuthorInput> | StreamItemCreateWithoutAuthorInput[] | StreamItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutAuthorInput | StreamItemCreateOrConnectWithoutAuthorInput[]
    createMany?: StreamItemCreateManyAuthorInputEnvelope
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
  }

  export type StudentParentCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type StudentParentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type BugReportCreateNestedManyWithoutUserInput = {
    create?: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput> | BugReportCreateWithoutUserInput[] | BugReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BugReportCreateOrConnectWithoutUserInput | BugReportCreateOrConnectWithoutUserInput[]
    createMany?: BugReportCreateManyUserInputEnvelope
    connect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
  }

  export type ResidentCreateNestedOneWithoutUserInput = {
    create?: XOR<ResidentCreateWithoutUserInput, ResidentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResidentCreateOrConnectWithoutUserInput
    connect?: ResidentWhereUniqueInput
  }

  export type MedicationLogCreateNestedManyWithoutAdministratorInput = {
    create?: XOR<MedicationLogCreateWithoutAdministratorInput, MedicationLogUncheckedCreateWithoutAdministratorInput> | MedicationLogCreateWithoutAdministratorInput[] | MedicationLogUncheckedCreateWithoutAdministratorInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutAdministratorInput | MedicationLogCreateOrConnectWithoutAdministratorInput[]
    createMany?: MedicationLogCreateManyAdministratorInputEnvelope
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
  }

  export type VitalSignCreateNestedManyWithoutRecorderInput = {
    create?: XOR<VitalSignCreateWithoutRecorderInput, VitalSignUncheckedCreateWithoutRecorderInput> | VitalSignCreateWithoutRecorderInput[] | VitalSignUncheckedCreateWithoutRecorderInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutRecorderInput | VitalSignCreateOrConnectWithoutRecorderInput[]
    createMany?: VitalSignCreateManyRecorderInputEnvelope
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
  }

  export type NursingNoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<NursingNoteCreateWithoutAuthorInput, NursingNoteUncheckedCreateWithoutAuthorInput> | NursingNoteCreateWithoutAuthorInput[] | NursingNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NursingNoteCreateOrConnectWithoutAuthorInput | NursingNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: NursingNoteCreateManyAuthorInputEnvelope
    connect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
  }

  export type AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AnnouncementStudentCreateWithoutStudentInput, AnnouncementStudentUncheckedCreateWithoutStudentInput> | AnnouncementStudentCreateWithoutStudentInput[] | AnnouncementStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AnnouncementStudentCreateOrConnectWithoutStudentInput | AnnouncementStudentCreateOrConnectWithoutStudentInput[]
    createMany?: AnnouncementStudentCreateManyStudentInputEnvelope
    connect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
  }

  export type AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AssignmentStudentCreateWithoutStudentInput, AssignmentStudentUncheckedCreateWithoutStudentInput> | AssignmentStudentCreateWithoutStudentInput[] | AssignmentStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentStudentCreateOrConnectWithoutStudentInput | AssignmentStudentCreateOrConnectWithoutStudentInput[]
    createMany?: AssignmentStudentCreateManyStudentInputEnvelope
    connect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type ClassMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClassMemberCreateWithoutUserInput, ClassMemberUncheckedCreateWithoutUserInput> | ClassMemberCreateWithoutUserInput[] | ClassMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassMemberCreateOrConnectWithoutUserInput | ClassMemberCreateOrConnectWithoutUserInput[]
    createMany?: ClassMemberCreateManyUserInputEnvelope
    connect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutGradedByInput = {
    create?: XOR<GradeCreateWithoutGradedByInput, GradeUncheckedCreateWithoutGradedByInput> | GradeCreateWithoutGradedByInput[] | GradeUncheckedCreateWithoutGradedByInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutGradedByInput | GradeCreateOrConnectWithoutGradedByInput[]
    createMany?: GradeCreateManyGradedByInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type MaterialStudentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<MaterialStudentCreateWithoutStudentInput, MaterialStudentUncheckedCreateWithoutStudentInput> | MaterialStudentCreateWithoutStudentInput[] | MaterialStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MaterialStudentCreateOrConnectWithoutStudentInput | MaterialStudentCreateOrConnectWithoutStudentInput[]
    createMany?: MaterialStudentCreateManyStudentInputEnvelope
    connect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ModuleCreateWithoutCreatedByInput, ModuleUncheckedCreateWithoutCreatedByInput> | ModuleCreateWithoutCreatedByInput[] | ModuleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCreatedByInput | ModuleCreateOrConnectWithoutCreatedByInput[]
    createMany?: ModuleCreateManyCreatedByInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type OrdenUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OrdenCreateWithoutCreatedByInput, OrdenUncheckedCreateWithoutCreatedByInput> | OrdenCreateWithoutCreatedByInput[] | OrdenUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrdenCreateOrConnectWithoutCreatedByInput | OrdenCreateOrConnectWithoutCreatedByInput[]
    createMany?: OrdenCreateManyCreatedByInputEnvelope
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
  }

  export type QuizStudentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<QuizStudentCreateWithoutStudentInput, QuizStudentUncheckedCreateWithoutStudentInput> | QuizStudentCreateWithoutStudentInput[] | QuizStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizStudentCreateOrConnectWithoutStudentInput | QuizStudentCreateOrConnectWithoutStudentInput[]
    createMany?: QuizStudentCreateManyStudentInputEnvelope
    connect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
  }

  export type QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<QuizSubmissionCreateWithoutStudentInput, QuizSubmissionUncheckedCreateWithoutStudentInput> | QuizSubmissionCreateWithoutStudentInput[] | QuizSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizSubmissionCreateOrConnectWithoutStudentInput | QuizSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: QuizSubmissionCreateManyStudentInputEnvelope
    connect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
  }

  export type StreamItemUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<StreamItemCreateWithoutAuthorInput, StreamItemUncheckedCreateWithoutAuthorInput> | StreamItemCreateWithoutAuthorInput[] | StreamItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutAuthorInput | StreamItemCreateOrConnectWithoutAuthorInput[]
    createMany?: StreamItemCreateManyAuthorInputEnvelope
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
  }

  export type StudentParentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type StudentParentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type BugReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput> | BugReportCreateWithoutUserInput[] | BugReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BugReportCreateOrConnectWithoutUserInput | BugReportCreateOrConnectWithoutUserInput[]
    createMany?: BugReportCreateManyUserInputEnvelope
    connect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
  }

  export type ResidentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ResidentCreateWithoutUserInput, ResidentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResidentCreateOrConnectWithoutUserInput
    connect?: ResidentWhereUniqueInput
  }

  export type MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput = {
    create?: XOR<MedicationLogCreateWithoutAdministratorInput, MedicationLogUncheckedCreateWithoutAdministratorInput> | MedicationLogCreateWithoutAdministratorInput[] | MedicationLogUncheckedCreateWithoutAdministratorInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutAdministratorInput | MedicationLogCreateOrConnectWithoutAdministratorInput[]
    createMany?: MedicationLogCreateManyAdministratorInputEnvelope
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
  }

  export type VitalSignUncheckedCreateNestedManyWithoutRecorderInput = {
    create?: XOR<VitalSignCreateWithoutRecorderInput, VitalSignUncheckedCreateWithoutRecorderInput> | VitalSignCreateWithoutRecorderInput[] | VitalSignUncheckedCreateWithoutRecorderInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutRecorderInput | VitalSignCreateOrConnectWithoutRecorderInput[]
    createMany?: VitalSignCreateManyRecorderInputEnvelope
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
  }

  export type NursingNoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<NursingNoteCreateWithoutAuthorInput, NursingNoteUncheckedCreateWithoutAuthorInput> | NursingNoteCreateWithoutAuthorInput[] | NursingNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NursingNoteCreateOrConnectWithoutAuthorInput | NursingNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: NursingNoteCreateManyAuthorInputEnvelope
    connect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AnnouncementStudentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AnnouncementStudentCreateWithoutStudentInput, AnnouncementStudentUncheckedCreateWithoutStudentInput> | AnnouncementStudentCreateWithoutStudentInput[] | AnnouncementStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AnnouncementStudentCreateOrConnectWithoutStudentInput | AnnouncementStudentCreateOrConnectWithoutStudentInput[]
    upsert?: AnnouncementStudentUpsertWithWhereUniqueWithoutStudentInput | AnnouncementStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AnnouncementStudentCreateManyStudentInputEnvelope
    set?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    disconnect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    delete?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    connect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    update?: AnnouncementStudentUpdateWithWhereUniqueWithoutStudentInput | AnnouncementStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AnnouncementStudentUpdateManyWithWhereWithoutStudentInput | AnnouncementStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AnnouncementStudentScalarWhereInput | AnnouncementStudentScalarWhereInput[]
  }

  export type AssignmentStudentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AssignmentStudentCreateWithoutStudentInput, AssignmentStudentUncheckedCreateWithoutStudentInput> | AssignmentStudentCreateWithoutStudentInput[] | AssignmentStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentStudentCreateOrConnectWithoutStudentInput | AssignmentStudentCreateOrConnectWithoutStudentInput[]
    upsert?: AssignmentStudentUpsertWithWhereUniqueWithoutStudentInput | AssignmentStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AssignmentStudentCreateManyStudentInputEnvelope
    set?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    disconnect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    delete?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    connect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    update?: AssignmentStudentUpdateWithWhereUniqueWithoutStudentInput | AssignmentStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AssignmentStudentUpdateManyWithWhereWithoutStudentInput | AssignmentStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AssignmentStudentScalarWhereInput | AssignmentStudentScalarWhereInput[]
  }

  export type AssignmentSubmissionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput | AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type ClassMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClassMemberCreateWithoutUserInput, ClassMemberUncheckedCreateWithoutUserInput> | ClassMemberCreateWithoutUserInput[] | ClassMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassMemberCreateOrConnectWithoutUserInput | ClassMemberCreateOrConnectWithoutUserInput[]
    upsert?: ClassMemberUpsertWithWhereUniqueWithoutUserInput | ClassMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClassMemberCreateManyUserInputEnvelope
    set?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    disconnect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    delete?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    connect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    update?: ClassMemberUpdateWithWhereUniqueWithoutUserInput | ClassMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClassMemberUpdateManyWithWhereWithoutUserInput | ClassMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClassMemberScalarWhereInput | ClassMemberScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTeacherInput | ClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTeacherInput | ClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTeacherInput | ClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutGradedByNestedInput = {
    create?: XOR<GradeCreateWithoutGradedByInput, GradeUncheckedCreateWithoutGradedByInput> | GradeCreateWithoutGradedByInput[] | GradeUncheckedCreateWithoutGradedByInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutGradedByInput | GradeCreateOrConnectWithoutGradedByInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutGradedByInput | GradeUpsertWithWhereUniqueWithoutGradedByInput[]
    createMany?: GradeCreateManyGradedByInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutGradedByInput | GradeUpdateWithWhereUniqueWithoutGradedByInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutGradedByInput | GradeUpdateManyWithWhereWithoutGradedByInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutStudentInput | GradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutStudentInput | GradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutStudentInput | GradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type MaterialStudentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MaterialStudentCreateWithoutStudentInput, MaterialStudentUncheckedCreateWithoutStudentInput> | MaterialStudentCreateWithoutStudentInput[] | MaterialStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MaterialStudentCreateOrConnectWithoutStudentInput | MaterialStudentCreateOrConnectWithoutStudentInput[]
    upsert?: MaterialStudentUpsertWithWhereUniqueWithoutStudentInput | MaterialStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MaterialStudentCreateManyStudentInputEnvelope
    set?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    disconnect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    delete?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    connect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    update?: MaterialStudentUpdateWithWhereUniqueWithoutStudentInput | MaterialStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MaterialStudentUpdateManyWithWhereWithoutStudentInput | MaterialStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MaterialStudentScalarWhereInput | MaterialStudentScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ModuleCreateWithoutCreatedByInput, ModuleUncheckedCreateWithoutCreatedByInput> | ModuleCreateWithoutCreatedByInput[] | ModuleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCreatedByInput | ModuleCreateOrConnectWithoutCreatedByInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCreatedByInput | ModuleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ModuleCreateManyCreatedByInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCreatedByInput | ModuleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCreatedByInput | ModuleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type OrdenUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OrdenCreateWithoutCreatedByInput, OrdenUncheckedCreateWithoutCreatedByInput> | OrdenCreateWithoutCreatedByInput[] | OrdenUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrdenCreateOrConnectWithoutCreatedByInput | OrdenCreateOrConnectWithoutCreatedByInput[]
    upsert?: OrdenUpsertWithWhereUniqueWithoutCreatedByInput | OrdenUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OrdenCreateManyCreatedByInputEnvelope
    set?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    disconnect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    delete?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    update?: OrdenUpdateWithWhereUniqueWithoutCreatedByInput | OrdenUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OrdenUpdateManyWithWhereWithoutCreatedByInput | OrdenUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OrdenScalarWhereInput | OrdenScalarWhereInput[]
  }

  export type QuizStudentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<QuizStudentCreateWithoutStudentInput, QuizStudentUncheckedCreateWithoutStudentInput> | QuizStudentCreateWithoutStudentInput[] | QuizStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizStudentCreateOrConnectWithoutStudentInput | QuizStudentCreateOrConnectWithoutStudentInput[]
    upsert?: QuizStudentUpsertWithWhereUniqueWithoutStudentInput | QuizStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: QuizStudentCreateManyStudentInputEnvelope
    set?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    disconnect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    delete?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    connect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    update?: QuizStudentUpdateWithWhereUniqueWithoutStudentInput | QuizStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: QuizStudentUpdateManyWithWhereWithoutStudentInput | QuizStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: QuizStudentScalarWhereInput | QuizStudentScalarWhereInput[]
  }

  export type QuizSubmissionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<QuizSubmissionCreateWithoutStudentInput, QuizSubmissionUncheckedCreateWithoutStudentInput> | QuizSubmissionCreateWithoutStudentInput[] | QuizSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizSubmissionCreateOrConnectWithoutStudentInput | QuizSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: QuizSubmissionUpsertWithWhereUniqueWithoutStudentInput | QuizSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: QuizSubmissionCreateManyStudentInputEnvelope
    set?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    disconnect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    delete?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    connect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    update?: QuizSubmissionUpdateWithWhereUniqueWithoutStudentInput | QuizSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: QuizSubmissionUpdateManyWithWhereWithoutStudentInput | QuizSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: QuizSubmissionScalarWhereInput | QuizSubmissionScalarWhereInput[]
  }

  export type StreamItemUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<StreamItemCreateWithoutAuthorInput, StreamItemUncheckedCreateWithoutAuthorInput> | StreamItemCreateWithoutAuthorInput[] | StreamItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutAuthorInput | StreamItemCreateOrConnectWithoutAuthorInput[]
    upsert?: StreamItemUpsertWithWhereUniqueWithoutAuthorInput | StreamItemUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: StreamItemCreateManyAuthorInputEnvelope
    set?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    disconnect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    delete?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    update?: StreamItemUpdateWithWhereUniqueWithoutAuthorInput | StreamItemUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: StreamItemUpdateManyWithWhereWithoutAuthorInput | StreamItemUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: StreamItemScalarWhereInput | StreamItemScalarWhereInput[]
  }

  export type StudentParentUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutParentInput | StudentParentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutParentInput | StudentParentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutParentInput | StudentParentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type StudentParentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutStudentInput | StudentParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutStudentInput | StudentParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutStudentInput | StudentParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type BugReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput> | BugReportCreateWithoutUserInput[] | BugReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BugReportCreateOrConnectWithoutUserInput | BugReportCreateOrConnectWithoutUserInput[]
    upsert?: BugReportUpsertWithWhereUniqueWithoutUserInput | BugReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BugReportCreateManyUserInputEnvelope
    set?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    disconnect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    delete?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    connect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    update?: BugReportUpdateWithWhereUniqueWithoutUserInput | BugReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BugReportUpdateManyWithWhereWithoutUserInput | BugReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BugReportScalarWhereInput | BugReportScalarWhereInput[]
  }

  export type ResidentUpdateOneWithoutUserNestedInput = {
    create?: XOR<ResidentCreateWithoutUserInput, ResidentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResidentCreateOrConnectWithoutUserInput
    upsert?: ResidentUpsertWithoutUserInput
    disconnect?: ResidentWhereInput | boolean
    delete?: ResidentWhereInput | boolean
    connect?: ResidentWhereUniqueInput
    update?: XOR<XOR<ResidentUpdateToOneWithWhereWithoutUserInput, ResidentUpdateWithoutUserInput>, ResidentUncheckedUpdateWithoutUserInput>
  }

  export type MedicationLogUpdateManyWithoutAdministratorNestedInput = {
    create?: XOR<MedicationLogCreateWithoutAdministratorInput, MedicationLogUncheckedCreateWithoutAdministratorInput> | MedicationLogCreateWithoutAdministratorInput[] | MedicationLogUncheckedCreateWithoutAdministratorInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutAdministratorInput | MedicationLogCreateOrConnectWithoutAdministratorInput[]
    upsert?: MedicationLogUpsertWithWhereUniqueWithoutAdministratorInput | MedicationLogUpsertWithWhereUniqueWithoutAdministratorInput[]
    createMany?: MedicationLogCreateManyAdministratorInputEnvelope
    set?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    disconnect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    delete?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    update?: MedicationLogUpdateWithWhereUniqueWithoutAdministratorInput | MedicationLogUpdateWithWhereUniqueWithoutAdministratorInput[]
    updateMany?: MedicationLogUpdateManyWithWhereWithoutAdministratorInput | MedicationLogUpdateManyWithWhereWithoutAdministratorInput[]
    deleteMany?: MedicationLogScalarWhereInput | MedicationLogScalarWhereInput[]
  }

  export type VitalSignUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<VitalSignCreateWithoutRecorderInput, VitalSignUncheckedCreateWithoutRecorderInput> | VitalSignCreateWithoutRecorderInput[] | VitalSignUncheckedCreateWithoutRecorderInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutRecorderInput | VitalSignCreateOrConnectWithoutRecorderInput[]
    upsert?: VitalSignUpsertWithWhereUniqueWithoutRecorderInput | VitalSignUpsertWithWhereUniqueWithoutRecorderInput[]
    createMany?: VitalSignCreateManyRecorderInputEnvelope
    set?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    disconnect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    delete?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    update?: VitalSignUpdateWithWhereUniqueWithoutRecorderInput | VitalSignUpdateWithWhereUniqueWithoutRecorderInput[]
    updateMany?: VitalSignUpdateManyWithWhereWithoutRecorderInput | VitalSignUpdateManyWithWhereWithoutRecorderInput[]
    deleteMany?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
  }

  export type NursingNoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<NursingNoteCreateWithoutAuthorInput, NursingNoteUncheckedCreateWithoutAuthorInput> | NursingNoteCreateWithoutAuthorInput[] | NursingNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NursingNoteCreateOrConnectWithoutAuthorInput | NursingNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: NursingNoteUpsertWithWhereUniqueWithoutAuthorInput | NursingNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: NursingNoteCreateManyAuthorInputEnvelope
    set?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    disconnect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    delete?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    connect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    update?: NursingNoteUpdateWithWhereUniqueWithoutAuthorInput | NursingNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: NursingNoteUpdateManyWithWhereWithoutAuthorInput | NursingNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: NursingNoteScalarWhereInput | NursingNoteScalarWhereInput[]
  }

  export type AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AnnouncementStudentCreateWithoutStudentInput, AnnouncementStudentUncheckedCreateWithoutStudentInput> | AnnouncementStudentCreateWithoutStudentInput[] | AnnouncementStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AnnouncementStudentCreateOrConnectWithoutStudentInput | AnnouncementStudentCreateOrConnectWithoutStudentInput[]
    upsert?: AnnouncementStudentUpsertWithWhereUniqueWithoutStudentInput | AnnouncementStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AnnouncementStudentCreateManyStudentInputEnvelope
    set?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    disconnect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    delete?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    connect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    update?: AnnouncementStudentUpdateWithWhereUniqueWithoutStudentInput | AnnouncementStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AnnouncementStudentUpdateManyWithWhereWithoutStudentInput | AnnouncementStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AnnouncementStudentScalarWhereInput | AnnouncementStudentScalarWhereInput[]
  }

  export type AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AssignmentStudentCreateWithoutStudentInput, AssignmentStudentUncheckedCreateWithoutStudentInput> | AssignmentStudentCreateWithoutStudentInput[] | AssignmentStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentStudentCreateOrConnectWithoutStudentInput | AssignmentStudentCreateOrConnectWithoutStudentInput[]
    upsert?: AssignmentStudentUpsertWithWhereUniqueWithoutStudentInput | AssignmentStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AssignmentStudentCreateManyStudentInputEnvelope
    set?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    disconnect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    delete?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    connect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    update?: AssignmentStudentUpdateWithWhereUniqueWithoutStudentInput | AssignmentStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AssignmentStudentUpdateManyWithWhereWithoutStudentInput | AssignmentStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AssignmentStudentScalarWhereInput | AssignmentStudentScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput | AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type ClassMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClassMemberCreateWithoutUserInput, ClassMemberUncheckedCreateWithoutUserInput> | ClassMemberCreateWithoutUserInput[] | ClassMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassMemberCreateOrConnectWithoutUserInput | ClassMemberCreateOrConnectWithoutUserInput[]
    upsert?: ClassMemberUpsertWithWhereUniqueWithoutUserInput | ClassMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClassMemberCreateManyUserInputEnvelope
    set?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    disconnect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    delete?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    connect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    update?: ClassMemberUpdateWithWhereUniqueWithoutUserInput | ClassMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClassMemberUpdateManyWithWhereWithoutUserInput | ClassMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClassMemberScalarWhereInput | ClassMemberScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTeacherInput | ClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTeacherInput | ClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTeacherInput | ClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutGradedByNestedInput = {
    create?: XOR<GradeCreateWithoutGradedByInput, GradeUncheckedCreateWithoutGradedByInput> | GradeCreateWithoutGradedByInput[] | GradeUncheckedCreateWithoutGradedByInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutGradedByInput | GradeCreateOrConnectWithoutGradedByInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutGradedByInput | GradeUpsertWithWhereUniqueWithoutGradedByInput[]
    createMany?: GradeCreateManyGradedByInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutGradedByInput | GradeUpdateWithWhereUniqueWithoutGradedByInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutGradedByInput | GradeUpdateManyWithWhereWithoutGradedByInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutStudentInput | GradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutStudentInput | GradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutStudentInput | GradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MaterialStudentCreateWithoutStudentInput, MaterialStudentUncheckedCreateWithoutStudentInput> | MaterialStudentCreateWithoutStudentInput[] | MaterialStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MaterialStudentCreateOrConnectWithoutStudentInput | MaterialStudentCreateOrConnectWithoutStudentInput[]
    upsert?: MaterialStudentUpsertWithWhereUniqueWithoutStudentInput | MaterialStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MaterialStudentCreateManyStudentInputEnvelope
    set?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    disconnect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    delete?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    connect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    update?: MaterialStudentUpdateWithWhereUniqueWithoutStudentInput | MaterialStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MaterialStudentUpdateManyWithWhereWithoutStudentInput | MaterialStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MaterialStudentScalarWhereInput | MaterialStudentScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ModuleCreateWithoutCreatedByInput, ModuleUncheckedCreateWithoutCreatedByInput> | ModuleCreateWithoutCreatedByInput[] | ModuleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCreatedByInput | ModuleCreateOrConnectWithoutCreatedByInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCreatedByInput | ModuleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ModuleCreateManyCreatedByInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCreatedByInput | ModuleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCreatedByInput | ModuleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type OrdenUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OrdenCreateWithoutCreatedByInput, OrdenUncheckedCreateWithoutCreatedByInput> | OrdenCreateWithoutCreatedByInput[] | OrdenUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrdenCreateOrConnectWithoutCreatedByInput | OrdenCreateOrConnectWithoutCreatedByInput[]
    upsert?: OrdenUpsertWithWhereUniqueWithoutCreatedByInput | OrdenUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OrdenCreateManyCreatedByInputEnvelope
    set?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    disconnect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    delete?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    update?: OrdenUpdateWithWhereUniqueWithoutCreatedByInput | OrdenUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OrdenUpdateManyWithWhereWithoutCreatedByInput | OrdenUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OrdenScalarWhereInput | OrdenScalarWhereInput[]
  }

  export type QuizStudentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<QuizStudentCreateWithoutStudentInput, QuizStudentUncheckedCreateWithoutStudentInput> | QuizStudentCreateWithoutStudentInput[] | QuizStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizStudentCreateOrConnectWithoutStudentInput | QuizStudentCreateOrConnectWithoutStudentInput[]
    upsert?: QuizStudentUpsertWithWhereUniqueWithoutStudentInput | QuizStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: QuizStudentCreateManyStudentInputEnvelope
    set?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    disconnect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    delete?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    connect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    update?: QuizStudentUpdateWithWhereUniqueWithoutStudentInput | QuizStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: QuizStudentUpdateManyWithWhereWithoutStudentInput | QuizStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: QuizStudentScalarWhereInput | QuizStudentScalarWhereInput[]
  }

  export type QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<QuizSubmissionCreateWithoutStudentInput, QuizSubmissionUncheckedCreateWithoutStudentInput> | QuizSubmissionCreateWithoutStudentInput[] | QuizSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizSubmissionCreateOrConnectWithoutStudentInput | QuizSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: QuizSubmissionUpsertWithWhereUniqueWithoutStudentInput | QuizSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: QuizSubmissionCreateManyStudentInputEnvelope
    set?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    disconnect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    delete?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    connect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    update?: QuizSubmissionUpdateWithWhereUniqueWithoutStudentInput | QuizSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: QuizSubmissionUpdateManyWithWhereWithoutStudentInput | QuizSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: QuizSubmissionScalarWhereInput | QuizSubmissionScalarWhereInput[]
  }

  export type StreamItemUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<StreamItemCreateWithoutAuthorInput, StreamItemUncheckedCreateWithoutAuthorInput> | StreamItemCreateWithoutAuthorInput[] | StreamItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutAuthorInput | StreamItemCreateOrConnectWithoutAuthorInput[]
    upsert?: StreamItemUpsertWithWhereUniqueWithoutAuthorInput | StreamItemUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: StreamItemCreateManyAuthorInputEnvelope
    set?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    disconnect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    delete?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    update?: StreamItemUpdateWithWhereUniqueWithoutAuthorInput | StreamItemUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: StreamItemUpdateManyWithWhereWithoutAuthorInput | StreamItemUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: StreamItemScalarWhereInput | StreamItemScalarWhereInput[]
  }

  export type StudentParentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutParentInput | StudentParentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutParentInput | StudentParentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutParentInput | StudentParentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type StudentParentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutStudentInput | StudentParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutStudentInput | StudentParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutStudentInput | StudentParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type BugReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput> | BugReportCreateWithoutUserInput[] | BugReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BugReportCreateOrConnectWithoutUserInput | BugReportCreateOrConnectWithoutUserInput[]
    upsert?: BugReportUpsertWithWhereUniqueWithoutUserInput | BugReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BugReportCreateManyUserInputEnvelope
    set?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    disconnect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    delete?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    connect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    update?: BugReportUpdateWithWhereUniqueWithoutUserInput | BugReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BugReportUpdateManyWithWhereWithoutUserInput | BugReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BugReportScalarWhereInput | BugReportScalarWhereInput[]
  }

  export type ResidentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ResidentCreateWithoutUserInput, ResidentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResidentCreateOrConnectWithoutUserInput
    upsert?: ResidentUpsertWithoutUserInput
    disconnect?: ResidentWhereInput | boolean
    delete?: ResidentWhereInput | boolean
    connect?: ResidentWhereUniqueInput
    update?: XOR<XOR<ResidentUpdateToOneWithWhereWithoutUserInput, ResidentUpdateWithoutUserInput>, ResidentUncheckedUpdateWithoutUserInput>
  }

  export type MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput = {
    create?: XOR<MedicationLogCreateWithoutAdministratorInput, MedicationLogUncheckedCreateWithoutAdministratorInput> | MedicationLogCreateWithoutAdministratorInput[] | MedicationLogUncheckedCreateWithoutAdministratorInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutAdministratorInput | MedicationLogCreateOrConnectWithoutAdministratorInput[]
    upsert?: MedicationLogUpsertWithWhereUniqueWithoutAdministratorInput | MedicationLogUpsertWithWhereUniqueWithoutAdministratorInput[]
    createMany?: MedicationLogCreateManyAdministratorInputEnvelope
    set?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    disconnect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    delete?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    update?: MedicationLogUpdateWithWhereUniqueWithoutAdministratorInput | MedicationLogUpdateWithWhereUniqueWithoutAdministratorInput[]
    updateMany?: MedicationLogUpdateManyWithWhereWithoutAdministratorInput | MedicationLogUpdateManyWithWhereWithoutAdministratorInput[]
    deleteMany?: MedicationLogScalarWhereInput | MedicationLogScalarWhereInput[]
  }

  export type VitalSignUncheckedUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<VitalSignCreateWithoutRecorderInput, VitalSignUncheckedCreateWithoutRecorderInput> | VitalSignCreateWithoutRecorderInput[] | VitalSignUncheckedCreateWithoutRecorderInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutRecorderInput | VitalSignCreateOrConnectWithoutRecorderInput[]
    upsert?: VitalSignUpsertWithWhereUniqueWithoutRecorderInput | VitalSignUpsertWithWhereUniqueWithoutRecorderInput[]
    createMany?: VitalSignCreateManyRecorderInputEnvelope
    set?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    disconnect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    delete?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    update?: VitalSignUpdateWithWhereUniqueWithoutRecorderInput | VitalSignUpdateWithWhereUniqueWithoutRecorderInput[]
    updateMany?: VitalSignUpdateManyWithWhereWithoutRecorderInput | VitalSignUpdateManyWithWhereWithoutRecorderInput[]
    deleteMany?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
  }

  export type NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<NursingNoteCreateWithoutAuthorInput, NursingNoteUncheckedCreateWithoutAuthorInput> | NursingNoteCreateWithoutAuthorInput[] | NursingNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NursingNoteCreateOrConnectWithoutAuthorInput | NursingNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: NursingNoteUpsertWithWhereUniqueWithoutAuthorInput | NursingNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: NursingNoteCreateManyAuthorInputEnvelope
    set?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    disconnect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    delete?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    connect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    update?: NursingNoteUpdateWithWhereUniqueWithoutAuthorInput | NursingNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: NursingNoteUpdateManyWithWhereWithoutAuthorInput | NursingNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: NursingNoteScalarWhereInput | NursingNoteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBugReportsInput = {
    create?: XOR<UserCreateWithoutBugReportsInput, UserUncheckedCreateWithoutBugReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBugReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutBugReportsNestedInput = {
    create?: XOR<UserCreateWithoutBugReportsInput, UserUncheckedCreateWithoutBugReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBugReportsInput
    upsert?: UserUpsertWithoutBugReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBugReportsInput, UserUpdateWithoutBugReportsInput>, UserUncheckedUpdateWithoutBugReportsInput>
  }

  export type UserCreateNestedOneWithoutResidentInput = {
    create?: XOR<UserCreateWithoutResidentInput, UserUncheckedCreateWithoutResidentInput>
    connectOrCreate?: UserCreateOrConnectWithoutResidentInput
    connect?: UserWhereUniqueInput
  }

  export type MedicationOrderCreateNestedManyWithoutResidentInput = {
    create?: XOR<MedicationOrderCreateWithoutResidentInput, MedicationOrderUncheckedCreateWithoutResidentInput> | MedicationOrderCreateWithoutResidentInput[] | MedicationOrderUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: MedicationOrderCreateOrConnectWithoutResidentInput | MedicationOrderCreateOrConnectWithoutResidentInput[]
    createMany?: MedicationOrderCreateManyResidentInputEnvelope
    connect?: MedicationOrderWhereUniqueInput | MedicationOrderWhereUniqueInput[]
  }

  export type VitalSignCreateNestedManyWithoutResidentInput = {
    create?: XOR<VitalSignCreateWithoutResidentInput, VitalSignUncheckedCreateWithoutResidentInput> | VitalSignCreateWithoutResidentInput[] | VitalSignUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutResidentInput | VitalSignCreateOrConnectWithoutResidentInput[]
    createMany?: VitalSignCreateManyResidentInputEnvelope
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
  }

  export type NursingNoteCreateNestedManyWithoutResidentInput = {
    create?: XOR<NursingNoteCreateWithoutResidentInput, NursingNoteUncheckedCreateWithoutResidentInput> | NursingNoteCreateWithoutResidentInput[] | NursingNoteUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: NursingNoteCreateOrConnectWithoutResidentInput | NursingNoteCreateOrConnectWithoutResidentInput[]
    createMany?: NursingNoteCreateManyResidentInputEnvelope
    connect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
  }

  export type MedicationOrderUncheckedCreateNestedManyWithoutResidentInput = {
    create?: XOR<MedicationOrderCreateWithoutResidentInput, MedicationOrderUncheckedCreateWithoutResidentInput> | MedicationOrderCreateWithoutResidentInput[] | MedicationOrderUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: MedicationOrderCreateOrConnectWithoutResidentInput | MedicationOrderCreateOrConnectWithoutResidentInput[]
    createMany?: MedicationOrderCreateManyResidentInputEnvelope
    connect?: MedicationOrderWhereUniqueInput | MedicationOrderWhereUniqueInput[]
  }

  export type VitalSignUncheckedCreateNestedManyWithoutResidentInput = {
    create?: XOR<VitalSignCreateWithoutResidentInput, VitalSignUncheckedCreateWithoutResidentInput> | VitalSignCreateWithoutResidentInput[] | VitalSignUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutResidentInput | VitalSignCreateOrConnectWithoutResidentInput[]
    createMany?: VitalSignCreateManyResidentInputEnvelope
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
  }

  export type NursingNoteUncheckedCreateNestedManyWithoutResidentInput = {
    create?: XOR<NursingNoteCreateWithoutResidentInput, NursingNoteUncheckedCreateWithoutResidentInput> | NursingNoteCreateWithoutResidentInput[] | NursingNoteUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: NursingNoteCreateOrConnectWithoutResidentInput | NursingNoteCreateOrConnectWithoutResidentInput[]
    createMany?: NursingNoteCreateManyResidentInputEnvelope
    connect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutResidentNestedInput = {
    create?: XOR<UserCreateWithoutResidentInput, UserUncheckedCreateWithoutResidentInput>
    connectOrCreate?: UserCreateOrConnectWithoutResidentInput
    upsert?: UserUpsertWithoutResidentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResidentInput, UserUpdateWithoutResidentInput>, UserUncheckedUpdateWithoutResidentInput>
  }

  export type MedicationOrderUpdateManyWithoutResidentNestedInput = {
    create?: XOR<MedicationOrderCreateWithoutResidentInput, MedicationOrderUncheckedCreateWithoutResidentInput> | MedicationOrderCreateWithoutResidentInput[] | MedicationOrderUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: MedicationOrderCreateOrConnectWithoutResidentInput | MedicationOrderCreateOrConnectWithoutResidentInput[]
    upsert?: MedicationOrderUpsertWithWhereUniqueWithoutResidentInput | MedicationOrderUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: MedicationOrderCreateManyResidentInputEnvelope
    set?: MedicationOrderWhereUniqueInput | MedicationOrderWhereUniqueInput[]
    disconnect?: MedicationOrderWhereUniqueInput | MedicationOrderWhereUniqueInput[]
    delete?: MedicationOrderWhereUniqueInput | MedicationOrderWhereUniqueInput[]
    connect?: MedicationOrderWhereUniqueInput | MedicationOrderWhereUniqueInput[]
    update?: MedicationOrderUpdateWithWhereUniqueWithoutResidentInput | MedicationOrderUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: MedicationOrderUpdateManyWithWhereWithoutResidentInput | MedicationOrderUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: MedicationOrderScalarWhereInput | MedicationOrderScalarWhereInput[]
  }

  export type VitalSignUpdateManyWithoutResidentNestedInput = {
    create?: XOR<VitalSignCreateWithoutResidentInput, VitalSignUncheckedCreateWithoutResidentInput> | VitalSignCreateWithoutResidentInput[] | VitalSignUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutResidentInput | VitalSignCreateOrConnectWithoutResidentInput[]
    upsert?: VitalSignUpsertWithWhereUniqueWithoutResidentInput | VitalSignUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: VitalSignCreateManyResidentInputEnvelope
    set?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    disconnect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    delete?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    update?: VitalSignUpdateWithWhereUniqueWithoutResidentInput | VitalSignUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: VitalSignUpdateManyWithWhereWithoutResidentInput | VitalSignUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
  }

  export type NursingNoteUpdateManyWithoutResidentNestedInput = {
    create?: XOR<NursingNoteCreateWithoutResidentInput, NursingNoteUncheckedCreateWithoutResidentInput> | NursingNoteCreateWithoutResidentInput[] | NursingNoteUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: NursingNoteCreateOrConnectWithoutResidentInput | NursingNoteCreateOrConnectWithoutResidentInput[]
    upsert?: NursingNoteUpsertWithWhereUniqueWithoutResidentInput | NursingNoteUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: NursingNoteCreateManyResidentInputEnvelope
    set?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    disconnect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    delete?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    connect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    update?: NursingNoteUpdateWithWhereUniqueWithoutResidentInput | NursingNoteUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: NursingNoteUpdateManyWithWhereWithoutResidentInput | NursingNoteUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: NursingNoteScalarWhereInput | NursingNoteScalarWhereInput[]
  }

  export type MedicationOrderUncheckedUpdateManyWithoutResidentNestedInput = {
    create?: XOR<MedicationOrderCreateWithoutResidentInput, MedicationOrderUncheckedCreateWithoutResidentInput> | MedicationOrderCreateWithoutResidentInput[] | MedicationOrderUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: MedicationOrderCreateOrConnectWithoutResidentInput | MedicationOrderCreateOrConnectWithoutResidentInput[]
    upsert?: MedicationOrderUpsertWithWhereUniqueWithoutResidentInput | MedicationOrderUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: MedicationOrderCreateManyResidentInputEnvelope
    set?: MedicationOrderWhereUniqueInput | MedicationOrderWhereUniqueInput[]
    disconnect?: MedicationOrderWhereUniqueInput | MedicationOrderWhereUniqueInput[]
    delete?: MedicationOrderWhereUniqueInput | MedicationOrderWhereUniqueInput[]
    connect?: MedicationOrderWhereUniqueInput | MedicationOrderWhereUniqueInput[]
    update?: MedicationOrderUpdateWithWhereUniqueWithoutResidentInput | MedicationOrderUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: MedicationOrderUpdateManyWithWhereWithoutResidentInput | MedicationOrderUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: MedicationOrderScalarWhereInput | MedicationOrderScalarWhereInput[]
  }

  export type VitalSignUncheckedUpdateManyWithoutResidentNestedInput = {
    create?: XOR<VitalSignCreateWithoutResidentInput, VitalSignUncheckedCreateWithoutResidentInput> | VitalSignCreateWithoutResidentInput[] | VitalSignUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutResidentInput | VitalSignCreateOrConnectWithoutResidentInput[]
    upsert?: VitalSignUpsertWithWhereUniqueWithoutResidentInput | VitalSignUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: VitalSignCreateManyResidentInputEnvelope
    set?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    disconnect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    delete?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    update?: VitalSignUpdateWithWhereUniqueWithoutResidentInput | VitalSignUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: VitalSignUpdateManyWithWhereWithoutResidentInput | VitalSignUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
  }

  export type NursingNoteUncheckedUpdateManyWithoutResidentNestedInput = {
    create?: XOR<NursingNoteCreateWithoutResidentInput, NursingNoteUncheckedCreateWithoutResidentInput> | NursingNoteCreateWithoutResidentInput[] | NursingNoteUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: NursingNoteCreateOrConnectWithoutResidentInput | NursingNoteCreateOrConnectWithoutResidentInput[]
    upsert?: NursingNoteUpsertWithWhereUniqueWithoutResidentInput | NursingNoteUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: NursingNoteCreateManyResidentInputEnvelope
    set?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    disconnect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    delete?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    connect?: NursingNoteWhereUniqueInput | NursingNoteWhereUniqueInput[]
    update?: NursingNoteUpdateWithWhereUniqueWithoutResidentInput | NursingNoteUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: NursingNoteUpdateManyWithWhereWithoutResidentInput | NursingNoteUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: NursingNoteScalarWhereInput | NursingNoteScalarWhereInput[]
  }

  export type ResidentCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<ResidentCreateWithoutMedicationsInput, ResidentUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: ResidentCreateOrConnectWithoutMedicationsInput
    connect?: ResidentWhereUniqueInput
  }

  export type MedicationLogCreateNestedManyWithoutOrderInput = {
    create?: XOR<MedicationLogCreateWithoutOrderInput, MedicationLogUncheckedCreateWithoutOrderInput> | MedicationLogCreateWithoutOrderInput[] | MedicationLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutOrderInput | MedicationLogCreateOrConnectWithoutOrderInput[]
    createMany?: MedicationLogCreateManyOrderInputEnvelope
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
  }

  export type MedicationLogUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<MedicationLogCreateWithoutOrderInput, MedicationLogUncheckedCreateWithoutOrderInput> | MedicationLogCreateWithoutOrderInput[] | MedicationLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutOrderInput | MedicationLogCreateOrConnectWithoutOrderInput[]
    createMany?: MedicationLogCreateManyOrderInputEnvelope
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ResidentUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<ResidentCreateWithoutMedicationsInput, ResidentUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: ResidentCreateOrConnectWithoutMedicationsInput
    upsert?: ResidentUpsertWithoutMedicationsInput
    connect?: ResidentWhereUniqueInput
    update?: XOR<XOR<ResidentUpdateToOneWithWhereWithoutMedicationsInput, ResidentUpdateWithoutMedicationsInput>, ResidentUncheckedUpdateWithoutMedicationsInput>
  }

  export type MedicationLogUpdateManyWithoutOrderNestedInput = {
    create?: XOR<MedicationLogCreateWithoutOrderInput, MedicationLogUncheckedCreateWithoutOrderInput> | MedicationLogCreateWithoutOrderInput[] | MedicationLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutOrderInput | MedicationLogCreateOrConnectWithoutOrderInput[]
    upsert?: MedicationLogUpsertWithWhereUniqueWithoutOrderInput | MedicationLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: MedicationLogCreateManyOrderInputEnvelope
    set?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    disconnect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    delete?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    update?: MedicationLogUpdateWithWhereUniqueWithoutOrderInput | MedicationLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: MedicationLogUpdateManyWithWhereWithoutOrderInput | MedicationLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: MedicationLogScalarWhereInput | MedicationLogScalarWhereInput[]
  }

  export type MedicationLogUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<MedicationLogCreateWithoutOrderInput, MedicationLogUncheckedCreateWithoutOrderInput> | MedicationLogCreateWithoutOrderInput[] | MedicationLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutOrderInput | MedicationLogCreateOrConnectWithoutOrderInput[]
    upsert?: MedicationLogUpsertWithWhereUniqueWithoutOrderInput | MedicationLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: MedicationLogCreateManyOrderInputEnvelope
    set?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    disconnect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    delete?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    update?: MedicationLogUpdateWithWhereUniqueWithoutOrderInput | MedicationLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: MedicationLogUpdateManyWithWhereWithoutOrderInput | MedicationLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: MedicationLogScalarWhereInput | MedicationLogScalarWhereInput[]
  }

  export type MedicationOrderCreateNestedOneWithoutLogsInput = {
    create?: XOR<MedicationOrderCreateWithoutLogsInput, MedicationOrderUncheckedCreateWithoutLogsInput>
    connectOrCreate?: MedicationOrderCreateOrConnectWithoutLogsInput
    connect?: MedicationOrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMedicationLogsInput = {
    create?: XOR<UserCreateWithoutMedicationLogsInput, UserUncheckedCreateWithoutMedicationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicationLogsInput
    connect?: UserWhereUniqueInput
  }

  export type MedicationOrderUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<MedicationOrderCreateWithoutLogsInput, MedicationOrderUncheckedCreateWithoutLogsInput>
    connectOrCreate?: MedicationOrderCreateOrConnectWithoutLogsInput
    upsert?: MedicationOrderUpsertWithoutLogsInput
    connect?: MedicationOrderWhereUniqueInput
    update?: XOR<XOR<MedicationOrderUpdateToOneWithWhereWithoutLogsInput, MedicationOrderUpdateWithoutLogsInput>, MedicationOrderUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneRequiredWithoutMedicationLogsNestedInput = {
    create?: XOR<UserCreateWithoutMedicationLogsInput, UserUncheckedCreateWithoutMedicationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicationLogsInput
    upsert?: UserUpsertWithoutMedicationLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMedicationLogsInput, UserUpdateWithoutMedicationLogsInput>, UserUncheckedUpdateWithoutMedicationLogsInput>
  }

  export type ResidentCreateNestedOneWithoutVitalSignsInput = {
    create?: XOR<ResidentCreateWithoutVitalSignsInput, ResidentUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: ResidentCreateOrConnectWithoutVitalSignsInput
    connect?: ResidentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecordedVitalsInput = {
    create?: XOR<UserCreateWithoutRecordedVitalsInput, UserUncheckedCreateWithoutRecordedVitalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecordedVitalsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ResidentUpdateOneRequiredWithoutVitalSignsNestedInput = {
    create?: XOR<ResidentCreateWithoutVitalSignsInput, ResidentUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: ResidentCreateOrConnectWithoutVitalSignsInput
    upsert?: ResidentUpsertWithoutVitalSignsInput
    connect?: ResidentWhereUniqueInput
    update?: XOR<XOR<ResidentUpdateToOneWithWhereWithoutVitalSignsInput, ResidentUpdateWithoutVitalSignsInput>, ResidentUncheckedUpdateWithoutVitalSignsInput>
  }

  export type UserUpdateOneRequiredWithoutRecordedVitalsNestedInput = {
    create?: XOR<UserCreateWithoutRecordedVitalsInput, UserUncheckedCreateWithoutRecordedVitalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecordedVitalsInput
    upsert?: UserUpsertWithoutRecordedVitalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecordedVitalsInput, UserUpdateWithoutRecordedVitalsInput>, UserUncheckedUpdateWithoutRecordedVitalsInput>
  }

  export type ResidentCreateNestedOneWithoutNursingNotesInput = {
    create?: XOR<ResidentCreateWithoutNursingNotesInput, ResidentUncheckedCreateWithoutNursingNotesInput>
    connectOrCreate?: ResidentCreateOrConnectWithoutNursingNotesInput
    connect?: ResidentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuthoredNotesInput = {
    create?: XOR<UserCreateWithoutAuthoredNotesInput, UserUncheckedCreateWithoutAuthoredNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthoredNotesInput
    connect?: UserWhereUniqueInput
  }

  export type ResidentUpdateOneRequiredWithoutNursingNotesNestedInput = {
    create?: XOR<ResidentCreateWithoutNursingNotesInput, ResidentUncheckedCreateWithoutNursingNotesInput>
    connectOrCreate?: ResidentCreateOrConnectWithoutNursingNotesInput
    upsert?: ResidentUpsertWithoutNursingNotesInput
    connect?: ResidentWhereUniqueInput
    update?: XOR<XOR<ResidentUpdateToOneWithWhereWithoutNursingNotesInput, ResidentUpdateWithoutNursingNotesInput>, ResidentUncheckedUpdateWithoutNursingNotesInput>
  }

  export type UserUpdateOneRequiredWithoutAuthoredNotesNestedInput = {
    create?: XOR<UserCreateWithoutAuthoredNotesInput, UserUncheckedCreateWithoutAuthoredNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthoredNotesInput
    upsert?: UserUpsertWithoutAuthoredNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthoredNotesInput, UserUpdateWithoutAuthoredNotesInput>, UserUncheckedUpdateWithoutAuthoredNotesInput>
  }

  export type ClassMemberCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassMemberCreateWithoutClassInput, ClassMemberUncheckedCreateWithoutClassInput> | ClassMemberCreateWithoutClassInput[] | ClassMemberUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassMemberCreateOrConnectWithoutClassInput | ClassMemberCreateOrConnectWithoutClassInput[]
    createMany?: ClassMemberCreateManyClassInputEnvelope
    connect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
  }

  export type ModuleCreateNestedOneWithoutClassesInput = {
    create?: XOR<ModuleCreateWithoutClassesInput, ModuleUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutClassesInput
    connect?: ModuleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassesAsTeacherInput = {
    create?: XOR<UserCreateWithoutClassesAsTeacherInput, UserUncheckedCreateWithoutClassesAsTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassesAsTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type GradeCreateNestedManyWithoutClassInput = {
    create?: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput> | GradeCreateWithoutClassInput[] | GradeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutClassInput | GradeCreateOrConnectWithoutClassInput[]
    createMany?: GradeCreateManyClassInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type StreamItemCreateNestedManyWithoutClassInput = {
    create?: XOR<StreamItemCreateWithoutClassInput, StreamItemUncheckedCreateWithoutClassInput> | StreamItemCreateWithoutClassInput[] | StreamItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutClassInput | StreamItemCreateOrConnectWithoutClassInput[]
    createMany?: StreamItemCreateManyClassInputEnvelope
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutClassInput = {
    create?: XOR<TopicCreateWithoutClassInput, TopicUncheckedCreateWithoutClassInput> | TopicCreateWithoutClassInput[] | TopicUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutClassInput | TopicCreateOrConnectWithoutClassInput[]
    createMany?: TopicCreateManyClassInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type ClassMemberUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassMemberCreateWithoutClassInput, ClassMemberUncheckedCreateWithoutClassInput> | ClassMemberCreateWithoutClassInput[] | ClassMemberUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassMemberCreateOrConnectWithoutClassInput | ClassMemberCreateOrConnectWithoutClassInput[]
    createMany?: ClassMemberCreateManyClassInputEnvelope
    connect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput> | GradeCreateWithoutClassInput[] | GradeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutClassInput | GradeCreateOrConnectWithoutClassInput[]
    createMany?: GradeCreateManyClassInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type StreamItemUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StreamItemCreateWithoutClassInput, StreamItemUncheckedCreateWithoutClassInput> | StreamItemCreateWithoutClassInput[] | StreamItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutClassInput | StreamItemCreateOrConnectWithoutClassInput[]
    createMany?: StreamItemCreateManyClassInputEnvelope
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<TopicCreateWithoutClassInput, TopicUncheckedCreateWithoutClassInput> | TopicCreateWithoutClassInput[] | TopicUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutClassInput | TopicCreateOrConnectWithoutClassInput[]
    createMany?: TopicCreateManyClassInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type ClassMemberUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassMemberCreateWithoutClassInput, ClassMemberUncheckedCreateWithoutClassInput> | ClassMemberCreateWithoutClassInput[] | ClassMemberUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassMemberCreateOrConnectWithoutClassInput | ClassMemberCreateOrConnectWithoutClassInput[]
    upsert?: ClassMemberUpsertWithWhereUniqueWithoutClassInput | ClassMemberUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassMemberCreateManyClassInputEnvelope
    set?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    disconnect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    delete?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    connect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    update?: ClassMemberUpdateWithWhereUniqueWithoutClassInput | ClassMemberUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassMemberUpdateManyWithWhereWithoutClassInput | ClassMemberUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassMemberScalarWhereInput | ClassMemberScalarWhereInput[]
  }

  export type ModuleUpdateOneWithoutClassesNestedInput = {
    create?: XOR<ModuleCreateWithoutClassesInput, ModuleUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutClassesInput
    upsert?: ModuleUpsertWithoutClassesInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutClassesInput, ModuleUpdateWithoutClassesInput>, ModuleUncheckedUpdateWithoutClassesInput>
  }

  export type UserUpdateOneRequiredWithoutClassesAsTeacherNestedInput = {
    create?: XOR<UserCreateWithoutClassesAsTeacherInput, UserUncheckedCreateWithoutClassesAsTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassesAsTeacherInput
    upsert?: UserUpsertWithoutClassesAsTeacherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassesAsTeacherInput, UserUpdateWithoutClassesAsTeacherInput>, UserUncheckedUpdateWithoutClassesAsTeacherInput>
  }

  export type GradeUpdateManyWithoutClassNestedInput = {
    create?: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput> | GradeCreateWithoutClassInput[] | GradeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutClassInput | GradeCreateOrConnectWithoutClassInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutClassInput | GradeUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: GradeCreateManyClassInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutClassInput | GradeUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutClassInput | GradeUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type StreamItemUpdateManyWithoutClassNestedInput = {
    create?: XOR<StreamItemCreateWithoutClassInput, StreamItemUncheckedCreateWithoutClassInput> | StreamItemCreateWithoutClassInput[] | StreamItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutClassInput | StreamItemCreateOrConnectWithoutClassInput[]
    upsert?: StreamItemUpsertWithWhereUniqueWithoutClassInput | StreamItemUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StreamItemCreateManyClassInputEnvelope
    set?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    disconnect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    delete?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    update?: StreamItemUpdateWithWhereUniqueWithoutClassInput | StreamItemUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StreamItemUpdateManyWithWhereWithoutClassInput | StreamItemUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StreamItemScalarWhereInput | StreamItemScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutClassNestedInput = {
    create?: XOR<TopicCreateWithoutClassInput, TopicUncheckedCreateWithoutClassInput> | TopicCreateWithoutClassInput[] | TopicUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutClassInput | TopicCreateOrConnectWithoutClassInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutClassInput | TopicUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TopicCreateManyClassInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutClassInput | TopicUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutClassInput | TopicUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type ClassMemberUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassMemberCreateWithoutClassInput, ClassMemberUncheckedCreateWithoutClassInput> | ClassMemberCreateWithoutClassInput[] | ClassMemberUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassMemberCreateOrConnectWithoutClassInput | ClassMemberCreateOrConnectWithoutClassInput[]
    upsert?: ClassMemberUpsertWithWhereUniqueWithoutClassInput | ClassMemberUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassMemberCreateManyClassInputEnvelope
    set?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    disconnect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    delete?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    connect?: ClassMemberWhereUniqueInput | ClassMemberWhereUniqueInput[]
    update?: ClassMemberUpdateWithWhereUniqueWithoutClassInput | ClassMemberUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassMemberUpdateManyWithWhereWithoutClassInput | ClassMemberUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassMemberScalarWhereInput | ClassMemberScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput> | GradeCreateWithoutClassInput[] | GradeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutClassInput | GradeCreateOrConnectWithoutClassInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutClassInput | GradeUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: GradeCreateManyClassInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutClassInput | GradeUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutClassInput | GradeUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type StreamItemUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StreamItemCreateWithoutClassInput, StreamItemUncheckedCreateWithoutClassInput> | StreamItemCreateWithoutClassInput[] | StreamItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutClassInput | StreamItemCreateOrConnectWithoutClassInput[]
    upsert?: StreamItemUpsertWithWhereUniqueWithoutClassInput | StreamItemUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StreamItemCreateManyClassInputEnvelope
    set?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    disconnect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    delete?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    update?: StreamItemUpdateWithWhereUniqueWithoutClassInput | StreamItemUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StreamItemUpdateManyWithWhereWithoutClassInput | StreamItemUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StreamItemScalarWhereInput | StreamItemScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<TopicCreateWithoutClassInput, TopicUncheckedCreateWithoutClassInput> | TopicCreateWithoutClassInput[] | TopicUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutClassInput | TopicCreateOrConnectWithoutClassInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutClassInput | TopicUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TopicCreateManyClassInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutClassInput | TopicUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutClassInput | TopicUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutMembersInput = {
    create?: XOR<ClassCreateWithoutMembersInput, ClassUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ClassCreateOrConnectWithoutMembersInput
    connect?: ClassWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassMembershipsInput = {
    create?: XOR<UserCreateWithoutClassMembershipsInput, UserUncheckedCreateWithoutClassMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ClassCreateWithoutMembersInput, ClassUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ClassCreateOrConnectWithoutMembersInput
    upsert?: ClassUpsertWithoutMembersInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutMembersInput, ClassUpdateWithoutMembersInput>, ClassUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutClassMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutClassMembershipsInput, UserUncheckedCreateWithoutClassMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassMembershipsInput
    upsert?: UserUpsertWithoutClassMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassMembershipsInput, UserUpdateWithoutClassMembershipsInput>, UserUncheckedUpdateWithoutClassMembershipsInput>
  }

  export type StreamItemCreateNestedManyWithoutTopicInput = {
    create?: XOR<StreamItemCreateWithoutTopicInput, StreamItemUncheckedCreateWithoutTopicInput> | StreamItemCreateWithoutTopicInput[] | StreamItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutTopicInput | StreamItemCreateOrConnectWithoutTopicInput[]
    createMany?: StreamItemCreateManyTopicInputEnvelope
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
  }

  export type ClassCreateNestedOneWithoutTopicsInput = {
    create?: XOR<ClassCreateWithoutTopicsInput, ClassUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTopicsInput
    connect?: ClassWhereUniqueInput
  }

  export type StreamItemUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<StreamItemCreateWithoutTopicInput, StreamItemUncheckedCreateWithoutTopicInput> | StreamItemCreateWithoutTopicInput[] | StreamItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutTopicInput | StreamItemCreateOrConnectWithoutTopicInput[]
    createMany?: StreamItemCreateManyTopicInputEnvelope
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StreamItemUpdateManyWithoutTopicNestedInput = {
    create?: XOR<StreamItemCreateWithoutTopicInput, StreamItemUncheckedCreateWithoutTopicInput> | StreamItemCreateWithoutTopicInput[] | StreamItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutTopicInput | StreamItemCreateOrConnectWithoutTopicInput[]
    upsert?: StreamItemUpsertWithWhereUniqueWithoutTopicInput | StreamItemUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: StreamItemCreateManyTopicInputEnvelope
    set?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    disconnect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    delete?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    update?: StreamItemUpdateWithWhereUniqueWithoutTopicInput | StreamItemUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: StreamItemUpdateManyWithWhereWithoutTopicInput | StreamItemUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: StreamItemScalarWhereInput | StreamItemScalarWhereInput[]
  }

  export type ClassUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<ClassCreateWithoutTopicsInput, ClassUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTopicsInput
    upsert?: ClassUpsertWithoutTopicsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutTopicsInput, ClassUpdateWithoutTopicsInput>, ClassUncheckedUpdateWithoutTopicsInput>
  }

  export type StreamItemUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<StreamItemCreateWithoutTopicInput, StreamItemUncheckedCreateWithoutTopicInput> | StreamItemCreateWithoutTopicInput[] | StreamItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: StreamItemCreateOrConnectWithoutTopicInput | StreamItemCreateOrConnectWithoutTopicInput[]
    upsert?: StreamItemUpsertWithWhereUniqueWithoutTopicInput | StreamItemUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: StreamItemCreateManyTopicInputEnvelope
    set?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    disconnect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    delete?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    connect?: StreamItemWhereUniqueInput | StreamItemWhereUniqueInput[]
    update?: StreamItemUpdateWithWhereUniqueWithoutTopicInput | StreamItemUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: StreamItemUpdateManyWithWhereWithoutTopicInput | StreamItemUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: StreamItemScalarWhereInput | StreamItemScalarWhereInput[]
  }

  export type AnnouncementStudentCreateNestedManyWithoutStreamItemInput = {
    create?: XOR<AnnouncementStudentCreateWithoutStreamItemInput, AnnouncementStudentUncheckedCreateWithoutStreamItemInput> | AnnouncementStudentCreateWithoutStreamItemInput[] | AnnouncementStudentUncheckedCreateWithoutStreamItemInput[]
    connectOrCreate?: AnnouncementStudentCreateOrConnectWithoutStreamItemInput | AnnouncementStudentCreateOrConnectWithoutStreamItemInput[]
    createMany?: AnnouncementStudentCreateManyStreamItemInputEnvelope
    connect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
  }

  export type AssignmentCreateNestedOneWithoutStreamItemInput = {
    create?: XOR<AssignmentCreateWithoutStreamItemInput, AssignmentUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutStreamItemInput
    connect?: AssignmentWhereUniqueInput
  }

  export type AttachmentCreateNestedManyWithoutStreamItemInput = {
    create?: XOR<AttachmentCreateWithoutStreamItemInput, AttachmentUncheckedCreateWithoutStreamItemInput> | AttachmentCreateWithoutStreamItemInput[] | AttachmentUncheckedCreateWithoutStreamItemInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutStreamItemInput | AttachmentCreateOrConnectWithoutStreamItemInput[]
    createMany?: AttachmentCreateManyStreamItemInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type MaterialCreateNestedOneWithoutStreamItemInput = {
    create?: XOR<MaterialCreateWithoutStreamItemInput, MaterialUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutStreamItemInput
    connect?: MaterialWhereUniqueInput
  }

  export type QuizCreateNestedOneWithoutStreamItemInput = {
    create?: XOR<QuizCreateWithoutStreamItemInput, QuizUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: QuizCreateOrConnectWithoutStreamItemInput
    connect?: QuizWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStreamItemsInput = {
    create?: XOR<UserCreateWithoutStreamItemsInput, UserUncheckedCreateWithoutStreamItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStreamItemsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutStreamItemsInput = {
    create?: XOR<ClassCreateWithoutStreamItemsInput, ClassUncheckedCreateWithoutStreamItemsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStreamItemsInput
    connect?: ClassWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutStreamItemsInput = {
    create?: XOR<TopicCreateWithoutStreamItemsInput, TopicUncheckedCreateWithoutStreamItemsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutStreamItemsInput
    connect?: TopicWhereUniqueInput
  }

  export type AnnouncementStudentUncheckedCreateNestedManyWithoutStreamItemInput = {
    create?: XOR<AnnouncementStudentCreateWithoutStreamItemInput, AnnouncementStudentUncheckedCreateWithoutStreamItemInput> | AnnouncementStudentCreateWithoutStreamItemInput[] | AnnouncementStudentUncheckedCreateWithoutStreamItemInput[]
    connectOrCreate?: AnnouncementStudentCreateOrConnectWithoutStreamItemInput | AnnouncementStudentCreateOrConnectWithoutStreamItemInput[]
    createMany?: AnnouncementStudentCreateManyStreamItemInputEnvelope
    connect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedOneWithoutStreamItemInput = {
    create?: XOR<AssignmentCreateWithoutStreamItemInput, AssignmentUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutStreamItemInput
    connect?: AssignmentWhereUniqueInput
  }

  export type AttachmentUncheckedCreateNestedManyWithoutStreamItemInput = {
    create?: XOR<AttachmentCreateWithoutStreamItemInput, AttachmentUncheckedCreateWithoutStreamItemInput> | AttachmentCreateWithoutStreamItemInput[] | AttachmentUncheckedCreateWithoutStreamItemInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutStreamItemInput | AttachmentCreateOrConnectWithoutStreamItemInput[]
    createMany?: AttachmentCreateManyStreamItemInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedOneWithoutStreamItemInput = {
    create?: XOR<MaterialCreateWithoutStreamItemInput, MaterialUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutStreamItemInput
    connect?: MaterialWhereUniqueInput
  }

  export type QuizUncheckedCreateNestedOneWithoutStreamItemInput = {
    create?: XOR<QuizCreateWithoutStreamItemInput, QuizUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: QuizCreateOrConnectWithoutStreamItemInput
    connect?: QuizWhereUniqueInput
  }

  export type AnnouncementStudentUpdateManyWithoutStreamItemNestedInput = {
    create?: XOR<AnnouncementStudentCreateWithoutStreamItemInput, AnnouncementStudentUncheckedCreateWithoutStreamItemInput> | AnnouncementStudentCreateWithoutStreamItemInput[] | AnnouncementStudentUncheckedCreateWithoutStreamItemInput[]
    connectOrCreate?: AnnouncementStudentCreateOrConnectWithoutStreamItemInput | AnnouncementStudentCreateOrConnectWithoutStreamItemInput[]
    upsert?: AnnouncementStudentUpsertWithWhereUniqueWithoutStreamItemInput | AnnouncementStudentUpsertWithWhereUniqueWithoutStreamItemInput[]
    createMany?: AnnouncementStudentCreateManyStreamItemInputEnvelope
    set?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    disconnect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    delete?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    connect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    update?: AnnouncementStudentUpdateWithWhereUniqueWithoutStreamItemInput | AnnouncementStudentUpdateWithWhereUniqueWithoutStreamItemInput[]
    updateMany?: AnnouncementStudentUpdateManyWithWhereWithoutStreamItemInput | AnnouncementStudentUpdateManyWithWhereWithoutStreamItemInput[]
    deleteMany?: AnnouncementStudentScalarWhereInput | AnnouncementStudentScalarWhereInput[]
  }

  export type AssignmentUpdateOneWithoutStreamItemNestedInput = {
    create?: XOR<AssignmentCreateWithoutStreamItemInput, AssignmentUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutStreamItemInput
    upsert?: AssignmentUpsertWithoutStreamItemInput
    disconnect?: AssignmentWhereInput | boolean
    delete?: AssignmentWhereInput | boolean
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutStreamItemInput, AssignmentUpdateWithoutStreamItemInput>, AssignmentUncheckedUpdateWithoutStreamItemInput>
  }

  export type AttachmentUpdateManyWithoutStreamItemNestedInput = {
    create?: XOR<AttachmentCreateWithoutStreamItemInput, AttachmentUncheckedCreateWithoutStreamItemInput> | AttachmentCreateWithoutStreamItemInput[] | AttachmentUncheckedCreateWithoutStreamItemInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutStreamItemInput | AttachmentCreateOrConnectWithoutStreamItemInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutStreamItemInput | AttachmentUpsertWithWhereUniqueWithoutStreamItemInput[]
    createMany?: AttachmentCreateManyStreamItemInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutStreamItemInput | AttachmentUpdateWithWhereUniqueWithoutStreamItemInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutStreamItemInput | AttachmentUpdateManyWithWhereWithoutStreamItemInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type MaterialUpdateOneWithoutStreamItemNestedInput = {
    create?: XOR<MaterialCreateWithoutStreamItemInput, MaterialUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutStreamItemInput
    upsert?: MaterialUpsertWithoutStreamItemInput
    disconnect?: MaterialWhereInput | boolean
    delete?: MaterialWhereInput | boolean
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutStreamItemInput, MaterialUpdateWithoutStreamItemInput>, MaterialUncheckedUpdateWithoutStreamItemInput>
  }

  export type QuizUpdateOneWithoutStreamItemNestedInput = {
    create?: XOR<QuizCreateWithoutStreamItemInput, QuizUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: QuizCreateOrConnectWithoutStreamItemInput
    upsert?: QuizUpsertWithoutStreamItemInput
    disconnect?: QuizWhereInput | boolean
    delete?: QuizWhereInput | boolean
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutStreamItemInput, QuizUpdateWithoutStreamItemInput>, QuizUncheckedUpdateWithoutStreamItemInput>
  }

  export type UserUpdateOneRequiredWithoutStreamItemsNestedInput = {
    create?: XOR<UserCreateWithoutStreamItemsInput, UserUncheckedCreateWithoutStreamItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStreamItemsInput
    upsert?: UserUpsertWithoutStreamItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStreamItemsInput, UserUpdateWithoutStreamItemsInput>, UserUncheckedUpdateWithoutStreamItemsInput>
  }

  export type ClassUpdateOneWithoutStreamItemsNestedInput = {
    create?: XOR<ClassCreateWithoutStreamItemsInput, ClassUncheckedCreateWithoutStreamItemsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStreamItemsInput
    upsert?: ClassUpsertWithoutStreamItemsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStreamItemsInput, ClassUpdateWithoutStreamItemsInput>, ClassUncheckedUpdateWithoutStreamItemsInput>
  }

  export type TopicUpdateOneWithoutStreamItemsNestedInput = {
    create?: XOR<TopicCreateWithoutStreamItemsInput, TopicUncheckedCreateWithoutStreamItemsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutStreamItemsInput
    upsert?: TopicUpsertWithoutStreamItemsInput
    disconnect?: TopicWhereInput | boolean
    delete?: TopicWhereInput | boolean
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutStreamItemsInput, TopicUpdateWithoutStreamItemsInput>, TopicUncheckedUpdateWithoutStreamItemsInput>
  }

  export type AnnouncementStudentUncheckedUpdateManyWithoutStreamItemNestedInput = {
    create?: XOR<AnnouncementStudentCreateWithoutStreamItemInput, AnnouncementStudentUncheckedCreateWithoutStreamItemInput> | AnnouncementStudentCreateWithoutStreamItemInput[] | AnnouncementStudentUncheckedCreateWithoutStreamItemInput[]
    connectOrCreate?: AnnouncementStudentCreateOrConnectWithoutStreamItemInput | AnnouncementStudentCreateOrConnectWithoutStreamItemInput[]
    upsert?: AnnouncementStudentUpsertWithWhereUniqueWithoutStreamItemInput | AnnouncementStudentUpsertWithWhereUniqueWithoutStreamItemInput[]
    createMany?: AnnouncementStudentCreateManyStreamItemInputEnvelope
    set?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    disconnect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    delete?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    connect?: AnnouncementStudentWhereUniqueInput | AnnouncementStudentWhereUniqueInput[]
    update?: AnnouncementStudentUpdateWithWhereUniqueWithoutStreamItemInput | AnnouncementStudentUpdateWithWhereUniqueWithoutStreamItemInput[]
    updateMany?: AnnouncementStudentUpdateManyWithWhereWithoutStreamItemInput | AnnouncementStudentUpdateManyWithWhereWithoutStreamItemInput[]
    deleteMany?: AnnouncementStudentScalarWhereInput | AnnouncementStudentScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateOneWithoutStreamItemNestedInput = {
    create?: XOR<AssignmentCreateWithoutStreamItemInput, AssignmentUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutStreamItemInput
    upsert?: AssignmentUpsertWithoutStreamItemInput
    disconnect?: AssignmentWhereInput | boolean
    delete?: AssignmentWhereInput | boolean
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutStreamItemInput, AssignmentUpdateWithoutStreamItemInput>, AssignmentUncheckedUpdateWithoutStreamItemInput>
  }

  export type AttachmentUncheckedUpdateManyWithoutStreamItemNestedInput = {
    create?: XOR<AttachmentCreateWithoutStreamItemInput, AttachmentUncheckedCreateWithoutStreamItemInput> | AttachmentCreateWithoutStreamItemInput[] | AttachmentUncheckedCreateWithoutStreamItemInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutStreamItemInput | AttachmentCreateOrConnectWithoutStreamItemInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutStreamItemInput | AttachmentUpsertWithWhereUniqueWithoutStreamItemInput[]
    createMany?: AttachmentCreateManyStreamItemInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutStreamItemInput | AttachmentUpdateWithWhereUniqueWithoutStreamItemInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutStreamItemInput | AttachmentUpdateManyWithWhereWithoutStreamItemInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateOneWithoutStreamItemNestedInput = {
    create?: XOR<MaterialCreateWithoutStreamItemInput, MaterialUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutStreamItemInput
    upsert?: MaterialUpsertWithoutStreamItemInput
    disconnect?: MaterialWhereInput | boolean
    delete?: MaterialWhereInput | boolean
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutStreamItemInput, MaterialUpdateWithoutStreamItemInput>, MaterialUncheckedUpdateWithoutStreamItemInput>
  }

  export type QuizUncheckedUpdateOneWithoutStreamItemNestedInput = {
    create?: XOR<QuizCreateWithoutStreamItemInput, QuizUncheckedCreateWithoutStreamItemInput>
    connectOrCreate?: QuizCreateOrConnectWithoutStreamItemInput
    upsert?: QuizUpsertWithoutStreamItemInput
    disconnect?: QuizWhereInput | boolean
    delete?: QuizWhereInput | boolean
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutStreamItemInput, QuizUpdateWithoutStreamItemInput>, QuizUncheckedUpdateWithoutStreamItemInput>
  }

  export type AssignmentCreateassignedGroupsInput = {
    set: string[]
  }

  export type AssignmentStudentCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentStudentCreateWithoutAssignmentInput, AssignmentStudentUncheckedCreateWithoutAssignmentInput> | AssignmentStudentCreateWithoutAssignmentInput[] | AssignmentStudentUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentStudentCreateOrConnectWithoutAssignmentInput | AssignmentStudentCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentStudentCreateManyAssignmentInputEnvelope
    connect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
  }

  export type AssignmentSubmissionCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type StreamItemCreateNestedOneWithoutAssignmentInput = {
    create?: XOR<StreamItemCreateWithoutAssignmentInput, StreamItemUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: StreamItemCreateOrConnectWithoutAssignmentInput
    connect?: StreamItemWhereUniqueInput
  }

  export type GradeCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<GradeCreateWithoutAssignmentInput, GradeUncheckedCreateWithoutAssignmentInput> | GradeCreateWithoutAssignmentInput[] | GradeUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutAssignmentInput | GradeCreateOrConnectWithoutAssignmentInput[]
    createMany?: GradeCreateManyAssignmentInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type AssignmentStudentUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentStudentCreateWithoutAssignmentInput, AssignmentStudentUncheckedCreateWithoutAssignmentInput> | AssignmentStudentCreateWithoutAssignmentInput[] | AssignmentStudentUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentStudentCreateOrConnectWithoutAssignmentInput | AssignmentStudentCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentStudentCreateManyAssignmentInputEnvelope
    connect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<GradeCreateWithoutAssignmentInput, GradeUncheckedCreateWithoutAssignmentInput> | GradeCreateWithoutAssignmentInput[] | GradeUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutAssignmentInput | GradeCreateOrConnectWithoutAssignmentInput[]
    createMany?: GradeCreateManyAssignmentInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type AssignmentUpdateassignedGroupsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AssignmentStudentUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentStudentCreateWithoutAssignmentInput, AssignmentStudentUncheckedCreateWithoutAssignmentInput> | AssignmentStudentCreateWithoutAssignmentInput[] | AssignmentStudentUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentStudentCreateOrConnectWithoutAssignmentInput | AssignmentStudentCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentStudentUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentStudentUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentStudentCreateManyAssignmentInputEnvelope
    set?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    disconnect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    delete?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    connect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    update?: AssignmentStudentUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentStudentUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentStudentUpdateManyWithWhereWithoutAssignmentInput | AssignmentStudentUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentStudentScalarWhereInput | AssignmentStudentScalarWhereInput[]
  }

  export type AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput | AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type StreamItemUpdateOneRequiredWithoutAssignmentNestedInput = {
    create?: XOR<StreamItemCreateWithoutAssignmentInput, StreamItemUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: StreamItemCreateOrConnectWithoutAssignmentInput
    upsert?: StreamItemUpsertWithoutAssignmentInput
    connect?: StreamItemWhereUniqueInput
    update?: XOR<XOR<StreamItemUpdateToOneWithWhereWithoutAssignmentInput, StreamItemUpdateWithoutAssignmentInput>, StreamItemUncheckedUpdateWithoutAssignmentInput>
  }

  export type GradeUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<GradeCreateWithoutAssignmentInput, GradeUncheckedCreateWithoutAssignmentInput> | GradeCreateWithoutAssignmentInput[] | GradeUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutAssignmentInput | GradeCreateOrConnectWithoutAssignmentInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutAssignmentInput | GradeUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: GradeCreateManyAssignmentInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutAssignmentInput | GradeUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutAssignmentInput | GradeUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type AssignmentStudentUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentStudentCreateWithoutAssignmentInput, AssignmentStudentUncheckedCreateWithoutAssignmentInput> | AssignmentStudentCreateWithoutAssignmentInput[] | AssignmentStudentUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentStudentCreateOrConnectWithoutAssignmentInput | AssignmentStudentCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentStudentUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentStudentUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentStudentCreateManyAssignmentInputEnvelope
    set?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    disconnect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    delete?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    connect?: AssignmentStudentWhereUniqueInput | AssignmentStudentWhereUniqueInput[]
    update?: AssignmentStudentUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentStudentUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentStudentUpdateManyWithWhereWithoutAssignmentInput | AssignmentStudentUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentStudentScalarWhereInput | AssignmentStudentScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput | AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<GradeCreateWithoutAssignmentInput, GradeUncheckedCreateWithoutAssignmentInput> | GradeCreateWithoutAssignmentInput[] | GradeUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutAssignmentInput | GradeCreateOrConnectWithoutAssignmentInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutAssignmentInput | GradeUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: GradeCreateManyAssignmentInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutAssignmentInput | GradeUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutAssignmentInput | GradeUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type AssignmentCreateNestedOneWithoutAssignmentStudentsInput = {
    create?: XOR<AssignmentCreateWithoutAssignmentStudentsInput, AssignmentUncheckedCreateWithoutAssignmentStudentsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutAssignmentStudentsInput
    connect?: AssignmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignmentStudentsInput = {
    create?: XOR<UserCreateWithoutAssignmentStudentsInput, UserUncheckedCreateWithoutAssignmentStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentStudentsInput
    connect?: UserWhereUniqueInput
  }

  export type AssignmentUpdateOneRequiredWithoutAssignmentStudentsNestedInput = {
    create?: XOR<AssignmentCreateWithoutAssignmentStudentsInput, AssignmentUncheckedCreateWithoutAssignmentStudentsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutAssignmentStudentsInput
    upsert?: AssignmentUpsertWithoutAssignmentStudentsInput
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutAssignmentStudentsInput, AssignmentUpdateWithoutAssignmentStudentsInput>, AssignmentUncheckedUpdateWithoutAssignmentStudentsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignmentStudentsNestedInput = {
    create?: XOR<UserCreateWithoutAssignmentStudentsInput, UserUncheckedCreateWithoutAssignmentStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentStudentsInput
    upsert?: UserUpsertWithoutAssignmentStudentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignmentStudentsInput, UserUpdateWithoutAssignmentStudentsInput>, UserUncheckedUpdateWithoutAssignmentStudentsInput>
  }

  export type AssignmentCreateNestedOneWithoutAssignmentSubmissionsInput = {
    create?: XOR<AssignmentCreateWithoutAssignmentSubmissionsInput, AssignmentUncheckedCreateWithoutAssignmentSubmissionsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutAssignmentSubmissionsInput
    connect?: AssignmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignmentSubmissionsInput = {
    create?: XOR<UserCreateWithoutAssignmentSubmissionsInput, UserUncheckedCreateWithoutAssignmentSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AssignmentUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput = {
    create?: XOR<AssignmentCreateWithoutAssignmentSubmissionsInput, AssignmentUncheckedCreateWithoutAssignmentSubmissionsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutAssignmentSubmissionsInput
    upsert?: AssignmentUpsertWithoutAssignmentSubmissionsInput
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutAssignmentSubmissionsInput, AssignmentUpdateWithoutAssignmentSubmissionsInput>, AssignmentUncheckedUpdateWithoutAssignmentSubmissionsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutAssignmentSubmissionsInput, UserUncheckedCreateWithoutAssignmentSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentSubmissionsInput
    upsert?: UserUpsertWithoutAssignmentSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignmentSubmissionsInput, UserUpdateWithoutAssignmentSubmissionsInput>, UserUncheckedUpdateWithoutAssignmentSubmissionsInput>
  }

  export type QuizCreateassignedGroupsInput = {
    set: string[]
  }

  export type GradeCreateNestedManyWithoutQuizInput = {
    create?: XOR<GradeCreateWithoutQuizInput, GradeUncheckedCreateWithoutQuizInput> | GradeCreateWithoutQuizInput[] | GradeUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutQuizInput | GradeCreateOrConnectWithoutQuizInput[]
    createMany?: GradeCreateManyQuizInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type QuizQuestionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizStudentCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizStudentCreateWithoutQuizInput, QuizStudentUncheckedCreateWithoutQuizInput> | QuizStudentCreateWithoutQuizInput[] | QuizStudentUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizStudentCreateOrConnectWithoutQuizInput | QuizStudentCreateOrConnectWithoutQuizInput[]
    createMany?: QuizStudentCreateManyQuizInputEnvelope
    connect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
  }

  export type QuizSubmissionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizSubmissionCreateWithoutQuizInput, QuizSubmissionUncheckedCreateWithoutQuizInput> | QuizSubmissionCreateWithoutQuizInput[] | QuizSubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizSubmissionCreateOrConnectWithoutQuizInput | QuizSubmissionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizSubmissionCreateManyQuizInputEnvelope
    connect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
  }

  export type StreamItemCreateNestedOneWithoutQuizInput = {
    create?: XOR<StreamItemCreateWithoutQuizInput, StreamItemUncheckedCreateWithoutQuizInput>
    connectOrCreate?: StreamItemCreateOrConnectWithoutQuizInput
    connect?: StreamItemWhereUniqueInput
  }

  export type GradeUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<GradeCreateWithoutQuizInput, GradeUncheckedCreateWithoutQuizInput> | GradeCreateWithoutQuizInput[] | GradeUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutQuizInput | GradeCreateOrConnectWithoutQuizInput[]
    createMany?: GradeCreateManyQuizInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizStudentUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizStudentCreateWithoutQuizInput, QuizStudentUncheckedCreateWithoutQuizInput> | QuizStudentCreateWithoutQuizInput[] | QuizStudentUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizStudentCreateOrConnectWithoutQuizInput | QuizStudentCreateOrConnectWithoutQuizInput[]
    createMany?: QuizStudentCreateManyQuizInputEnvelope
    connect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
  }

  export type QuizSubmissionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizSubmissionCreateWithoutQuizInput, QuizSubmissionUncheckedCreateWithoutQuizInput> | QuizSubmissionCreateWithoutQuizInput[] | QuizSubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizSubmissionCreateOrConnectWithoutQuizInput | QuizSubmissionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizSubmissionCreateManyQuizInputEnvelope
    connect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
  }

  export type QuizUpdateassignedGroupsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GradeUpdateManyWithoutQuizNestedInput = {
    create?: XOR<GradeCreateWithoutQuizInput, GradeUncheckedCreateWithoutQuizInput> | GradeCreateWithoutQuizInput[] | GradeUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutQuizInput | GradeCreateOrConnectWithoutQuizInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutQuizInput | GradeUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: GradeCreateManyQuizInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutQuizInput | GradeUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutQuizInput | GradeUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type QuizQuestionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizStudentUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizStudentCreateWithoutQuizInput, QuizStudentUncheckedCreateWithoutQuizInput> | QuizStudentCreateWithoutQuizInput[] | QuizStudentUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizStudentCreateOrConnectWithoutQuizInput | QuizStudentCreateOrConnectWithoutQuizInput[]
    upsert?: QuizStudentUpsertWithWhereUniqueWithoutQuizInput | QuizStudentUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizStudentCreateManyQuizInputEnvelope
    set?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    disconnect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    delete?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    connect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    update?: QuizStudentUpdateWithWhereUniqueWithoutQuizInput | QuizStudentUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizStudentUpdateManyWithWhereWithoutQuizInput | QuizStudentUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizStudentScalarWhereInput | QuizStudentScalarWhereInput[]
  }

  export type QuizSubmissionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizSubmissionCreateWithoutQuizInput, QuizSubmissionUncheckedCreateWithoutQuizInput> | QuizSubmissionCreateWithoutQuizInput[] | QuizSubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizSubmissionCreateOrConnectWithoutQuizInput | QuizSubmissionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizSubmissionUpsertWithWhereUniqueWithoutQuizInput | QuizSubmissionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizSubmissionCreateManyQuizInputEnvelope
    set?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    disconnect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    delete?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    connect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    update?: QuizSubmissionUpdateWithWhereUniqueWithoutQuizInput | QuizSubmissionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizSubmissionUpdateManyWithWhereWithoutQuizInput | QuizSubmissionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizSubmissionScalarWhereInput | QuizSubmissionScalarWhereInput[]
  }

  export type StreamItemUpdateOneRequiredWithoutQuizNestedInput = {
    create?: XOR<StreamItemCreateWithoutQuizInput, StreamItemUncheckedCreateWithoutQuizInput>
    connectOrCreate?: StreamItemCreateOrConnectWithoutQuizInput
    upsert?: StreamItemUpsertWithoutQuizInput
    connect?: StreamItemWhereUniqueInput
    update?: XOR<XOR<StreamItemUpdateToOneWithWhereWithoutQuizInput, StreamItemUpdateWithoutQuizInput>, StreamItemUncheckedUpdateWithoutQuizInput>
  }

  export type GradeUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<GradeCreateWithoutQuizInput, GradeUncheckedCreateWithoutQuizInput> | GradeCreateWithoutQuizInput[] | GradeUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutQuizInput | GradeCreateOrConnectWithoutQuizInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutQuizInput | GradeUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: GradeCreateManyQuizInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutQuizInput | GradeUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutQuizInput | GradeUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizStudentUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizStudentCreateWithoutQuizInput, QuizStudentUncheckedCreateWithoutQuizInput> | QuizStudentCreateWithoutQuizInput[] | QuizStudentUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizStudentCreateOrConnectWithoutQuizInput | QuizStudentCreateOrConnectWithoutQuizInput[]
    upsert?: QuizStudentUpsertWithWhereUniqueWithoutQuizInput | QuizStudentUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizStudentCreateManyQuizInputEnvelope
    set?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    disconnect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    delete?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    connect?: QuizStudentWhereUniqueInput | QuizStudentWhereUniqueInput[]
    update?: QuizStudentUpdateWithWhereUniqueWithoutQuizInput | QuizStudentUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizStudentUpdateManyWithWhereWithoutQuizInput | QuizStudentUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizStudentScalarWhereInput | QuizStudentScalarWhereInput[]
  }

  export type QuizSubmissionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizSubmissionCreateWithoutQuizInput, QuizSubmissionUncheckedCreateWithoutQuizInput> | QuizSubmissionCreateWithoutQuizInput[] | QuizSubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizSubmissionCreateOrConnectWithoutQuizInput | QuizSubmissionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizSubmissionUpsertWithWhereUniqueWithoutQuizInput | QuizSubmissionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizSubmissionCreateManyQuizInputEnvelope
    set?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    disconnect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    delete?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    connect?: QuizSubmissionWhereUniqueInput | QuizSubmissionWhereUniqueInput[]
    update?: QuizSubmissionUpdateWithWhereUniqueWithoutQuizInput | QuizSubmissionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizSubmissionUpdateManyWithWhereWithoutQuizInput | QuizSubmissionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizSubmissionScalarWhereInput | QuizSubmissionScalarWhereInput[]
  }

  export type QuizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
  }

  export type QuizUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    upsert?: QuizUpsertWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuestionsInput, QuizUpdateWithoutQuestionsInput>, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizCreateNestedOneWithoutQuizStudentsInput = {
    create?: XOR<QuizCreateWithoutQuizStudentsInput, QuizUncheckedCreateWithoutQuizStudentsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuizStudentsInput
    connect?: QuizWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuizStudentsInput = {
    create?: XOR<UserCreateWithoutQuizStudentsInput, UserUncheckedCreateWithoutQuizStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizStudentsInput
    connect?: UserWhereUniqueInput
  }

  export type QuizUpdateOneRequiredWithoutQuizStudentsNestedInput = {
    create?: XOR<QuizCreateWithoutQuizStudentsInput, QuizUncheckedCreateWithoutQuizStudentsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuizStudentsInput
    upsert?: QuizUpsertWithoutQuizStudentsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuizStudentsInput, QuizUpdateWithoutQuizStudentsInput>, QuizUncheckedUpdateWithoutQuizStudentsInput>
  }

  export type UserUpdateOneRequiredWithoutQuizStudentsNestedInput = {
    create?: XOR<UserCreateWithoutQuizStudentsInput, UserUncheckedCreateWithoutQuizStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizStudentsInput
    upsert?: UserUpsertWithoutQuizStudentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizStudentsInput, UserUpdateWithoutQuizStudentsInput>, UserUncheckedUpdateWithoutQuizStudentsInput>
  }

  export type QuizCreateNestedOneWithoutQuizSubmissionsInput = {
    create?: XOR<QuizCreateWithoutQuizSubmissionsInput, QuizUncheckedCreateWithoutQuizSubmissionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuizSubmissionsInput
    connect?: QuizWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuizSubmissionsInput = {
    create?: XOR<UserCreateWithoutQuizSubmissionsInput, UserUncheckedCreateWithoutQuizSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type QuizUpdateOneRequiredWithoutQuizSubmissionsNestedInput = {
    create?: XOR<QuizCreateWithoutQuizSubmissionsInput, QuizUncheckedCreateWithoutQuizSubmissionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuizSubmissionsInput
    upsert?: QuizUpsertWithoutQuizSubmissionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuizSubmissionsInput, QuizUpdateWithoutQuizSubmissionsInput>, QuizUncheckedUpdateWithoutQuizSubmissionsInput>
  }

  export type UserUpdateOneRequiredWithoutQuizSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutQuizSubmissionsInput, UserUncheckedCreateWithoutQuizSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizSubmissionsInput
    upsert?: UserUpsertWithoutQuizSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizSubmissionsInput, UserUpdateWithoutQuizSubmissionsInput>, UserUncheckedUpdateWithoutQuizSubmissionsInput>
  }

  export type MaterialCreateassignedGroupsInput = {
    set: string[]
  }

  export type MaterialStudentCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialStudentCreateWithoutMaterialInput, MaterialStudentUncheckedCreateWithoutMaterialInput> | MaterialStudentCreateWithoutMaterialInput[] | MaterialStudentUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialStudentCreateOrConnectWithoutMaterialInput | MaterialStudentCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialStudentCreateManyMaterialInputEnvelope
    connect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
  }

  export type StreamItemCreateNestedOneWithoutMaterialInput = {
    create?: XOR<StreamItemCreateWithoutMaterialInput, StreamItemUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: StreamItemCreateOrConnectWithoutMaterialInput
    connect?: StreamItemWhereUniqueInput
  }

  export type MaterialStudentUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialStudentCreateWithoutMaterialInput, MaterialStudentUncheckedCreateWithoutMaterialInput> | MaterialStudentCreateWithoutMaterialInput[] | MaterialStudentUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialStudentCreateOrConnectWithoutMaterialInput | MaterialStudentCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialStudentCreateManyMaterialInputEnvelope
    connect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
  }

  export type MaterialUpdateassignedGroupsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MaterialStudentUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialStudentCreateWithoutMaterialInput, MaterialStudentUncheckedCreateWithoutMaterialInput> | MaterialStudentCreateWithoutMaterialInput[] | MaterialStudentUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialStudentCreateOrConnectWithoutMaterialInput | MaterialStudentCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialStudentUpsertWithWhereUniqueWithoutMaterialInput | MaterialStudentUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialStudentCreateManyMaterialInputEnvelope
    set?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    disconnect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    delete?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    connect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    update?: MaterialStudentUpdateWithWhereUniqueWithoutMaterialInput | MaterialStudentUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialStudentUpdateManyWithWhereWithoutMaterialInput | MaterialStudentUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialStudentScalarWhereInput | MaterialStudentScalarWhereInput[]
  }

  export type StreamItemUpdateOneRequiredWithoutMaterialNestedInput = {
    create?: XOR<StreamItemCreateWithoutMaterialInput, StreamItemUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: StreamItemCreateOrConnectWithoutMaterialInput
    upsert?: StreamItemUpsertWithoutMaterialInput
    connect?: StreamItemWhereUniqueInput
    update?: XOR<XOR<StreamItemUpdateToOneWithWhereWithoutMaterialInput, StreamItemUpdateWithoutMaterialInput>, StreamItemUncheckedUpdateWithoutMaterialInput>
  }

  export type MaterialStudentUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialStudentCreateWithoutMaterialInput, MaterialStudentUncheckedCreateWithoutMaterialInput> | MaterialStudentCreateWithoutMaterialInput[] | MaterialStudentUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialStudentCreateOrConnectWithoutMaterialInput | MaterialStudentCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialStudentUpsertWithWhereUniqueWithoutMaterialInput | MaterialStudentUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialStudentCreateManyMaterialInputEnvelope
    set?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    disconnect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    delete?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    connect?: MaterialStudentWhereUniqueInput | MaterialStudentWhereUniqueInput[]
    update?: MaterialStudentUpdateWithWhereUniqueWithoutMaterialInput | MaterialStudentUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialStudentUpdateManyWithWhereWithoutMaterialInput | MaterialStudentUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialStudentScalarWhereInput | MaterialStudentScalarWhereInput[]
  }

  export type MaterialCreateNestedOneWithoutMaterialStudentsInput = {
    create?: XOR<MaterialCreateWithoutMaterialStudentsInput, MaterialUncheckedCreateWithoutMaterialStudentsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutMaterialStudentsInput
    connect?: MaterialWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMaterialStudentsInput = {
    create?: XOR<UserCreateWithoutMaterialStudentsInput, UserUncheckedCreateWithoutMaterialStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaterialStudentsInput
    connect?: UserWhereUniqueInput
  }

  export type MaterialUpdateOneRequiredWithoutMaterialStudentsNestedInput = {
    create?: XOR<MaterialCreateWithoutMaterialStudentsInput, MaterialUncheckedCreateWithoutMaterialStudentsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutMaterialStudentsInput
    upsert?: MaterialUpsertWithoutMaterialStudentsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutMaterialStudentsInput, MaterialUpdateWithoutMaterialStudentsInput>, MaterialUncheckedUpdateWithoutMaterialStudentsInput>
  }

  export type UserUpdateOneRequiredWithoutMaterialStudentsNestedInput = {
    create?: XOR<UserCreateWithoutMaterialStudentsInput, UserUncheckedCreateWithoutMaterialStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaterialStudentsInput
    upsert?: UserUpsertWithoutMaterialStudentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMaterialStudentsInput, UserUpdateWithoutMaterialStudentsInput>, UserUncheckedUpdateWithoutMaterialStudentsInput>
  }

  export type StreamItemCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<StreamItemCreateWithoutAttachmentsInput, StreamItemUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: StreamItemCreateOrConnectWithoutAttachmentsInput
    connect?: StreamItemWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StreamItemUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<StreamItemCreateWithoutAttachmentsInput, StreamItemUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: StreamItemCreateOrConnectWithoutAttachmentsInput
    upsert?: StreamItemUpsertWithoutAttachmentsInput
    connect?: StreamItemWhereUniqueInput
    update?: XOR<XOR<StreamItemUpdateToOneWithWhereWithoutAttachmentsInput, StreamItemUpdateWithoutAttachmentsInput>, StreamItemUncheckedUpdateWithoutAttachmentsInput>
  }

  export type AssignmentCreateNestedOneWithoutGradesInput = {
    create?: XOR<AssignmentCreateWithoutGradesInput, AssignmentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutGradesInput
    connect?: AssignmentWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutGradesInput = {
    create?: XOR<ClassCreateWithoutGradesInput, ClassUncheckedCreateWithoutGradesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutGradesInput
    connect?: ClassWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGradesAsGraderInput = {
    create?: XOR<UserCreateWithoutGradesAsGraderInput, UserUncheckedCreateWithoutGradesAsGraderInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradesAsGraderInput
    connect?: UserWhereUniqueInput
  }

  export type QuizCreateNestedOneWithoutGradesInput = {
    create?: XOR<QuizCreateWithoutGradesInput, QuizUncheckedCreateWithoutGradesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutGradesInput
    connect?: QuizWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGradesAsStudentInput = {
    create?: XOR<UserCreateWithoutGradesAsStudentInput, UserUncheckedCreateWithoutGradesAsStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradesAsStudentInput
    connect?: UserWhereUniqueInput
  }

  export type AssignmentUpdateOneWithoutGradesNestedInput = {
    create?: XOR<AssignmentCreateWithoutGradesInput, AssignmentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutGradesInput
    upsert?: AssignmentUpsertWithoutGradesInput
    disconnect?: AssignmentWhereInput | boolean
    delete?: AssignmentWhereInput | boolean
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutGradesInput, AssignmentUpdateWithoutGradesInput>, AssignmentUncheckedUpdateWithoutGradesInput>
  }

  export type ClassUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<ClassCreateWithoutGradesInput, ClassUncheckedCreateWithoutGradesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutGradesInput
    upsert?: ClassUpsertWithoutGradesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutGradesInput, ClassUpdateWithoutGradesInput>, ClassUncheckedUpdateWithoutGradesInput>
  }

  export type UserUpdateOneWithoutGradesAsGraderNestedInput = {
    create?: XOR<UserCreateWithoutGradesAsGraderInput, UserUncheckedCreateWithoutGradesAsGraderInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradesAsGraderInput
    upsert?: UserUpsertWithoutGradesAsGraderInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGradesAsGraderInput, UserUpdateWithoutGradesAsGraderInput>, UserUncheckedUpdateWithoutGradesAsGraderInput>
  }

  export type QuizUpdateOneWithoutGradesNestedInput = {
    create?: XOR<QuizCreateWithoutGradesInput, QuizUncheckedCreateWithoutGradesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutGradesInput
    upsert?: QuizUpsertWithoutGradesInput
    disconnect?: QuizWhereInput | boolean
    delete?: QuizWhereInput | boolean
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutGradesInput, QuizUpdateWithoutGradesInput>, QuizUncheckedUpdateWithoutGradesInput>
  }

  export type UserUpdateOneRequiredWithoutGradesAsStudentNestedInput = {
    create?: XOR<UserCreateWithoutGradesAsStudentInput, UserUncheckedCreateWithoutGradesAsStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradesAsStudentInput
    upsert?: UserUpsertWithoutGradesAsStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGradesAsStudentInput, UserUpdateWithoutGradesAsStudentInput>, UserUncheckedUpdateWithoutGradesAsStudentInput>
  }

  export type ClassCreateNestedManyWithoutModuleInput = {
    create?: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput> | ClassCreateWithoutModuleInput[] | ClassUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutModuleInput | ClassCreateOrConnectWithoutModuleInput[]
    createMany?: ClassCreateManyModuleInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutModulesCreatedInput = {
    create?: XOR<UserCreateWithoutModulesCreatedInput, UserUncheckedCreateWithoutModulesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutModulesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ClassUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput> | ClassCreateWithoutModuleInput[] | ClassUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutModuleInput | ClassCreateOrConnectWithoutModuleInput[]
    createMany?: ClassCreateManyModuleInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ClassUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput> | ClassCreateWithoutModuleInput[] | ClassUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutModuleInput | ClassCreateOrConnectWithoutModuleInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutModuleInput | ClassUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ClassCreateManyModuleInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutModuleInput | ClassUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutModuleInput | ClassUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type UserUpdateOneWithoutModulesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutModulesCreatedInput, UserUncheckedCreateWithoutModulesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutModulesCreatedInput
    upsert?: UserUpsertWithoutModulesCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModulesCreatedInput, UserUpdateWithoutModulesCreatedInput>, UserUncheckedUpdateWithoutModulesCreatedInput>
  }

  export type ClassUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput> | ClassCreateWithoutModuleInput[] | ClassUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutModuleInput | ClassCreateOrConnectWithoutModuleInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutModuleInput | ClassUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ClassCreateManyModuleInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutModuleInput | ClassUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutModuleInput | ClassUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParentRelationsInput = {
    create?: XOR<UserCreateWithoutParentRelationsInput, UserUncheckedCreateWithoutParentRelationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentRelationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStudentParentsInput = {
    create?: XOR<UserCreateWithoutStudentParentsInput, UserUncheckedCreateWithoutStudentParentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentParentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutParentRelationsNestedInput = {
    create?: XOR<UserCreateWithoutParentRelationsInput, UserUncheckedCreateWithoutParentRelationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentRelationsInput
    upsert?: UserUpsertWithoutParentRelationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParentRelationsInput, UserUpdateWithoutParentRelationsInput>, UserUncheckedUpdateWithoutParentRelationsInput>
  }

  export type UserUpdateOneRequiredWithoutStudentParentsNestedInput = {
    create?: XOR<UserCreateWithoutStudentParentsInput, UserUncheckedCreateWithoutStudentParentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentParentsInput
    upsert?: UserUpsertWithoutStudentParentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentParentsInput, UserUpdateWithoutStudentParentsInput>, UserUncheckedUpdateWithoutStudentParentsInput>
  }

  export type StreamItemCreateNestedOneWithoutAnnouncementStudentsInput = {
    create?: XOR<StreamItemCreateWithoutAnnouncementStudentsInput, StreamItemUncheckedCreateWithoutAnnouncementStudentsInput>
    connectOrCreate?: StreamItemCreateOrConnectWithoutAnnouncementStudentsInput
    connect?: StreamItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnnouncementStudentsInput = {
    create?: XOR<UserCreateWithoutAnnouncementStudentsInput, UserUncheckedCreateWithoutAnnouncementStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementStudentsInput
    connect?: UserWhereUniqueInput
  }

  export type StreamItemUpdateOneRequiredWithoutAnnouncementStudentsNestedInput = {
    create?: XOR<StreamItemCreateWithoutAnnouncementStudentsInput, StreamItemUncheckedCreateWithoutAnnouncementStudentsInput>
    connectOrCreate?: StreamItemCreateOrConnectWithoutAnnouncementStudentsInput
    upsert?: StreamItemUpsertWithoutAnnouncementStudentsInput
    connect?: StreamItemWhereUniqueInput
    update?: XOR<XOR<StreamItemUpdateToOneWithWhereWithoutAnnouncementStudentsInput, StreamItemUpdateWithoutAnnouncementStudentsInput>, StreamItemUncheckedUpdateWithoutAnnouncementStudentsInput>
  }

  export type UserUpdateOneRequiredWithoutAnnouncementStudentsNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementStudentsInput, UserUncheckedCreateWithoutAnnouncementStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementStudentsInput
    upsert?: UserUpsertWithoutAnnouncementStudentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnouncementStudentsInput, UserUpdateWithoutAnnouncementStudentsInput>, UserUncheckedUpdateWithoutAnnouncementStudentsInput>
  }

  export type EventoCreateNestedManyWithoutClientInput = {
    create?: XOR<EventoCreateWithoutClientInput, EventoUncheckedCreateWithoutClientInput> | EventoCreateWithoutClientInput[] | EventoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutClientInput | EventoCreateOrConnectWithoutClientInput[]
    createMany?: EventoCreateManyClientInputEnvelope
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
  }

  export type OrdenCreateNestedManyWithoutClientInput = {
    create?: XOR<OrdenCreateWithoutClientInput, OrdenUncheckedCreateWithoutClientInput> | OrdenCreateWithoutClientInput[] | OrdenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrdenCreateOrConnectWithoutClientInput | OrdenCreateOrConnectWithoutClientInput[]
    createMany?: OrdenCreateManyClientInputEnvelope
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
  }

  export type EventoUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<EventoCreateWithoutClientInput, EventoUncheckedCreateWithoutClientInput> | EventoCreateWithoutClientInput[] | EventoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutClientInput | EventoCreateOrConnectWithoutClientInput[]
    createMany?: EventoCreateManyClientInputEnvelope
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
  }

  export type OrdenUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<OrdenCreateWithoutClientInput, OrdenUncheckedCreateWithoutClientInput> | OrdenCreateWithoutClientInput[] | OrdenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrdenCreateOrConnectWithoutClientInput | OrdenCreateOrConnectWithoutClientInput[]
    createMany?: OrdenCreateManyClientInputEnvelope
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EventoUpdateManyWithoutClientNestedInput = {
    create?: XOR<EventoCreateWithoutClientInput, EventoUncheckedCreateWithoutClientInput> | EventoCreateWithoutClientInput[] | EventoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutClientInput | EventoCreateOrConnectWithoutClientInput[]
    upsert?: EventoUpsertWithWhereUniqueWithoutClientInput | EventoUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: EventoCreateManyClientInputEnvelope
    set?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    disconnect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    delete?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    update?: EventoUpdateWithWhereUniqueWithoutClientInput | EventoUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: EventoUpdateManyWithWhereWithoutClientInput | EventoUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: EventoScalarWhereInput | EventoScalarWhereInput[]
  }

  export type OrdenUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrdenCreateWithoutClientInput, OrdenUncheckedCreateWithoutClientInput> | OrdenCreateWithoutClientInput[] | OrdenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrdenCreateOrConnectWithoutClientInput | OrdenCreateOrConnectWithoutClientInput[]
    upsert?: OrdenUpsertWithWhereUniqueWithoutClientInput | OrdenUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrdenCreateManyClientInputEnvelope
    set?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    disconnect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    delete?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    update?: OrdenUpdateWithWhereUniqueWithoutClientInput | OrdenUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrdenUpdateManyWithWhereWithoutClientInput | OrdenUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrdenScalarWhereInput | OrdenScalarWhereInput[]
  }

  export type EventoUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<EventoCreateWithoutClientInput, EventoUncheckedCreateWithoutClientInput> | EventoCreateWithoutClientInput[] | EventoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutClientInput | EventoCreateOrConnectWithoutClientInput[]
    upsert?: EventoUpsertWithWhereUniqueWithoutClientInput | EventoUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: EventoCreateManyClientInputEnvelope
    set?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    disconnect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    delete?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    update?: EventoUpdateWithWhereUniqueWithoutClientInput | EventoUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: EventoUpdateManyWithWhereWithoutClientInput | EventoUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: EventoScalarWhereInput | EventoScalarWhereInput[]
  }

  export type OrdenUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrdenCreateWithoutClientInput, OrdenUncheckedCreateWithoutClientInput> | OrdenCreateWithoutClientInput[] | OrdenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrdenCreateOrConnectWithoutClientInput | OrdenCreateOrConnectWithoutClientInput[]
    upsert?: OrdenUpsertWithWhereUniqueWithoutClientInput | OrdenUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrdenCreateManyClientInputEnvelope
    set?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    disconnect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    delete?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    connect?: OrdenWhereUniqueInput | OrdenWhereUniqueInput[]
    update?: OrdenUpdateWithWhereUniqueWithoutClientInput | OrdenUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrdenUpdateManyWithWhereWithoutClientInput | OrdenUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrdenScalarWhereInput | OrdenScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutEventosInput = {
    create?: XOR<ClientCreateWithoutEventosInput, ClientUncheckedCreateWithoutEventosInput>
    connectOrCreate?: ClientCreateOrConnectWithoutEventosInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneWithoutEventosNestedInput = {
    create?: XOR<ClientCreateWithoutEventosInput, ClientUncheckedCreateWithoutEventosInput>
    connectOrCreate?: ClientCreateOrConnectWithoutEventosInput
    upsert?: ClientUpsertWithoutEventosInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutEventosInput, ClientUpdateWithoutEventosInput>, ClientUncheckedUpdateWithoutEventosInput>
  }

  export type OrdenItemCreateNestedManyWithoutOrdenInput = {
    create?: XOR<OrdenItemCreateWithoutOrdenInput, OrdenItemUncheckedCreateWithoutOrdenInput> | OrdenItemCreateWithoutOrdenInput[] | OrdenItemUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: OrdenItemCreateOrConnectWithoutOrdenInput | OrdenItemCreateOrConnectWithoutOrdenInput[]
    createMany?: OrdenItemCreateManyOrdenInputEnvelope
    connect?: OrdenItemWhereUniqueInput | OrdenItemWhereUniqueInput[]
  }

  export type ClientCreateNestedOneWithoutOrdenesInput = {
    create?: XOR<ClientCreateWithoutOrdenesInput, ClientUncheckedCreateWithoutOrdenesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdenesInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersCreatedInput = {
    create?: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type OrdenItemUncheckedCreateNestedManyWithoutOrdenInput = {
    create?: XOR<OrdenItemCreateWithoutOrdenInput, OrdenItemUncheckedCreateWithoutOrdenInput> | OrdenItemCreateWithoutOrdenInput[] | OrdenItemUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: OrdenItemCreateOrConnectWithoutOrdenInput | OrdenItemCreateOrConnectWithoutOrdenInput[]
    createMany?: OrdenItemCreateManyOrdenInputEnvelope
    connect?: OrdenItemWhereUniqueInput | OrdenItemWhereUniqueInput[]
  }

  export type OrdenItemUpdateManyWithoutOrdenNestedInput = {
    create?: XOR<OrdenItemCreateWithoutOrdenInput, OrdenItemUncheckedCreateWithoutOrdenInput> | OrdenItemCreateWithoutOrdenInput[] | OrdenItemUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: OrdenItemCreateOrConnectWithoutOrdenInput | OrdenItemCreateOrConnectWithoutOrdenInput[]
    upsert?: OrdenItemUpsertWithWhereUniqueWithoutOrdenInput | OrdenItemUpsertWithWhereUniqueWithoutOrdenInput[]
    createMany?: OrdenItemCreateManyOrdenInputEnvelope
    set?: OrdenItemWhereUniqueInput | OrdenItemWhereUniqueInput[]
    disconnect?: OrdenItemWhereUniqueInput | OrdenItemWhereUniqueInput[]
    delete?: OrdenItemWhereUniqueInput | OrdenItemWhereUniqueInput[]
    connect?: OrdenItemWhereUniqueInput | OrdenItemWhereUniqueInput[]
    update?: OrdenItemUpdateWithWhereUniqueWithoutOrdenInput | OrdenItemUpdateWithWhereUniqueWithoutOrdenInput[]
    updateMany?: OrdenItemUpdateManyWithWhereWithoutOrdenInput | OrdenItemUpdateManyWithWhereWithoutOrdenInput[]
    deleteMany?: OrdenItemScalarWhereInput | OrdenItemScalarWhereInput[]
  }

  export type ClientUpdateOneWithoutOrdenesNestedInput = {
    create?: XOR<ClientCreateWithoutOrdenesInput, ClientUncheckedCreateWithoutOrdenesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdenesInput
    upsert?: ClientUpsertWithoutOrdenesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutOrdenesInput, ClientUpdateWithoutOrdenesInput>, ClientUncheckedUpdateWithoutOrdenesInput>
  }

  export type UserUpdateOneRequiredWithoutOrdersCreatedNestedInput = {
    create?: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersCreatedInput
    upsert?: UserUpsertWithoutOrdersCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersCreatedInput, UserUpdateWithoutOrdersCreatedInput>, UserUncheckedUpdateWithoutOrdersCreatedInput>
  }

  export type OrdenItemUncheckedUpdateManyWithoutOrdenNestedInput = {
    create?: XOR<OrdenItemCreateWithoutOrdenInput, OrdenItemUncheckedCreateWithoutOrdenInput> | OrdenItemCreateWithoutOrdenInput[] | OrdenItemUncheckedCreateWithoutOrdenInput[]
    connectOrCreate?: OrdenItemCreateOrConnectWithoutOrdenInput | OrdenItemCreateOrConnectWithoutOrdenInput[]
    upsert?: OrdenItemUpsertWithWhereUniqueWithoutOrdenInput | OrdenItemUpsertWithWhereUniqueWithoutOrdenInput[]
    createMany?: OrdenItemCreateManyOrdenInputEnvelope
    set?: OrdenItemWhereUniqueInput | OrdenItemWhereUniqueInput[]
    disconnect?: OrdenItemWhereUniqueInput | OrdenItemWhereUniqueInput[]
    delete?: OrdenItemWhereUniqueInput | OrdenItemWhereUniqueInput[]
    connect?: OrdenItemWhereUniqueInput | OrdenItemWhereUniqueInput[]
    update?: OrdenItemUpdateWithWhereUniqueWithoutOrdenInput | OrdenItemUpdateWithWhereUniqueWithoutOrdenInput[]
    updateMany?: OrdenItemUpdateManyWithWhereWithoutOrdenInput | OrdenItemUpdateManyWithWhereWithoutOrdenInput[]
    deleteMany?: OrdenItemScalarWhereInput | OrdenItemScalarWhereInput[]
  }

  export type OrdenCreateNestedOneWithoutOrdenItemsInput = {
    create?: XOR<OrdenCreateWithoutOrdenItemsInput, OrdenUncheckedCreateWithoutOrdenItemsInput>
    connectOrCreate?: OrdenCreateOrConnectWithoutOrdenItemsInput
    connect?: OrdenWhereUniqueInput
  }

  export type OrdenUpdateOneRequiredWithoutOrdenItemsNestedInput = {
    create?: XOR<OrdenCreateWithoutOrdenItemsInput, OrdenUncheckedCreateWithoutOrdenItemsInput>
    connectOrCreate?: OrdenCreateOrConnectWithoutOrdenItemsInput
    upsert?: OrdenUpsertWithoutOrdenItemsInput
    connect?: OrdenWhereUniqueInput
    update?: XOR<XOR<OrdenUpdateToOneWithWhereWithoutOrdenItemsInput, OrdenUpdateWithoutOrdenItemsInput>, OrdenUncheckedUpdateWithoutOrdenItemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AnnouncementStudentCreateWithoutStudentInput = {
    id?: string
    streamItem: StreamItemCreateNestedOneWithoutAnnouncementStudentsInput
  }

  export type AnnouncementStudentUncheckedCreateWithoutStudentInput = {
    id?: string
    streamItemId: string
  }

  export type AnnouncementStudentCreateOrConnectWithoutStudentInput = {
    where: AnnouncementStudentWhereUniqueInput
    create: XOR<AnnouncementStudentCreateWithoutStudentInput, AnnouncementStudentUncheckedCreateWithoutStudentInput>
  }

  export type AnnouncementStudentCreateManyStudentInputEnvelope = {
    data: AnnouncementStudentCreateManyStudentInput | AnnouncementStudentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentStudentCreateWithoutStudentInput = {
    id?: string
    assignment: AssignmentCreateNestedOneWithoutAssignmentStudentsInput
  }

  export type AssignmentStudentUncheckedCreateWithoutStudentInput = {
    id?: string
    assignmentId: string
  }

  export type AssignmentStudentCreateOrConnectWithoutStudentInput = {
    where: AssignmentStudentWhereUniqueInput
    create: XOR<AssignmentStudentCreateWithoutStudentInput, AssignmentStudentUncheckedCreateWithoutStudentInput>
  }

  export type AssignmentStudentCreateManyStudentInputEnvelope = {
    data: AssignmentStudentCreateManyStudentInput | AssignmentStudentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentSubmissionCreateWithoutStudentInput = {
    id?: string
    content?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    submittedAt?: Date | string | null
    returnedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    reviewedAt?: Date | string | null
    assignment: AssignmentCreateNestedOneWithoutAssignmentSubmissionsInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutStudentInput = {
    id?: string
    assignmentId: string
    content?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    submittedAt?: Date | string | null
    returnedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    reviewedAt?: Date | string | null
  }

  export type AssignmentSubmissionCreateOrConnectWithoutStudentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type AssignmentSubmissionCreateManyStudentInputEnvelope = {
    data: AssignmentSubmissionCreateManyStudentInput | AssignmentSubmissionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ClassMemberCreateWithoutUserInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    status?: string
    class: ClassCreateNestedOneWithoutMembersInput
  }

  export type ClassMemberUncheckedCreateWithoutUserInput = {
    id?: string
    classId: string
    role?: string
    joinedAt?: Date | string
    status?: string
  }

  export type ClassMemberCreateOrConnectWithoutUserInput = {
    where: ClassMemberWhereUniqueInput
    create: XOR<ClassMemberCreateWithoutUserInput, ClassMemberUncheckedCreateWithoutUserInput>
  }

  export type ClassMemberCreateManyUserInputEnvelope = {
    data: ClassMemberCreateManyUserInput | ClassMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutTeacherInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberCreateNestedManyWithoutClassInput
    module?: ModuleCreateNestedOneWithoutClassesInput
    grades?: GradeCreateNestedManyWithoutClassInput
    streamItems?: StreamItemCreateNestedManyWithoutClassInput
    topics?: TopicCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTeacherInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    moduleId?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberUncheckedCreateNestedManyWithoutClassInput
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutClassInput
    topics?: TopicUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTeacherInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput>
  }

  export type ClassCreateManyTeacherInputEnvelope = {
    data: ClassCreateManyTeacherInput | ClassCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutGradedByInput = {
    id?: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment?: AssignmentCreateNestedOneWithoutGradesInput
    class: ClassCreateNestedOneWithoutGradesInput
    quiz?: QuizCreateNestedOneWithoutGradesInput
    student: UserCreateNestedOneWithoutGradesAsStudentInput
  }

  export type GradeUncheckedCreateWithoutGradedByInput = {
    id?: string
    classId: string
    assignmentId?: string | null
    quizId?: string | null
    studentId: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutGradedByInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutGradedByInput, GradeUncheckedCreateWithoutGradedByInput>
  }

  export type GradeCreateManyGradedByInputEnvelope = {
    data: GradeCreateManyGradedByInput | GradeCreateManyGradedByInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutStudentInput = {
    id?: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment?: AssignmentCreateNestedOneWithoutGradesInput
    class: ClassCreateNestedOneWithoutGradesInput
    gradedBy?: UserCreateNestedOneWithoutGradesAsGraderInput
    quiz?: QuizCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateWithoutStudentInput = {
    id?: string
    classId: string
    assignmentId?: string | null
    quizId?: string | null
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutStudentInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput>
  }

  export type GradeCreateManyStudentInputEnvelope = {
    data: GradeCreateManyStudentInput | GradeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type MaterialStudentCreateWithoutStudentInput = {
    id?: string
    material: MaterialCreateNestedOneWithoutMaterialStudentsInput
  }

  export type MaterialStudentUncheckedCreateWithoutStudentInput = {
    id?: string
    materialId: string
  }

  export type MaterialStudentCreateOrConnectWithoutStudentInput = {
    where: MaterialStudentWhereUniqueInput
    create: XOR<MaterialStudentCreateWithoutStudentInput, MaterialStudentUncheckedCreateWithoutStudentInput>
  }

  export type MaterialStudentCreateManyStudentInputEnvelope = {
    data: MaterialStudentCreateManyStudentInput | MaterialStudentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    category?: string | null
    difficulty?: string | null
    duration?: number | null
    thumbnail?: string | null
    instructor?: string | null
    isActive?: boolean
    isPublished?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    category?: string | null
    difficulty?: string | null
    duration?: number | null
    thumbnail?: string | null
    instructor?: string | null
    isActive?: boolean
    isPublished?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCreatedByInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCreatedByInput, ModuleUncheckedCreateWithoutCreatedByInput>
  }

  export type ModuleCreateManyCreatedByInputEnvelope = {
    data: ModuleCreateManyCreatedByInput | ModuleCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type OrdenCreateWithoutCreatedByInput = {
    id?: string
    orderNumber: string
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordenItems?: OrdenItemCreateNestedManyWithoutOrdenInput
    client?: ClientCreateNestedOneWithoutOrdenesInput
  }

  export type OrdenUncheckedCreateWithoutCreatedByInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordenItems?: OrdenItemUncheckedCreateNestedManyWithoutOrdenInput
  }

  export type OrdenCreateOrConnectWithoutCreatedByInput = {
    where: OrdenWhereUniqueInput
    create: XOR<OrdenCreateWithoutCreatedByInput, OrdenUncheckedCreateWithoutCreatedByInput>
  }

  export type OrdenCreateManyCreatedByInputEnvelope = {
    data: OrdenCreateManyCreatedByInput | OrdenCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type QuizStudentCreateWithoutStudentInput = {
    id?: string
    quiz: QuizCreateNestedOneWithoutQuizStudentsInput
  }

  export type QuizStudentUncheckedCreateWithoutStudentInput = {
    id?: string
    quizId: string
  }

  export type QuizStudentCreateOrConnectWithoutStudentInput = {
    where: QuizStudentWhereUniqueInput
    create: XOR<QuizStudentCreateWithoutStudentInput, QuizStudentUncheckedCreateWithoutStudentInput>
  }

  export type QuizStudentCreateManyStudentInputEnvelope = {
    data: QuizStudentCreateManyStudentInput | QuizStudentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type QuizSubmissionCreateWithoutStudentInput = {
    id?: string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz: QuizCreateNestedOneWithoutQuizSubmissionsInput
  }

  export type QuizSubmissionUncheckedCreateWithoutStudentInput = {
    id?: string
    quizId: string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizSubmissionCreateOrConnectWithoutStudentInput = {
    where: QuizSubmissionWhereUniqueInput
    create: XOR<QuizSubmissionCreateWithoutStudentInput, QuizSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type QuizSubmissionCreateManyStudentInputEnvelope = {
    data: QuizSubmissionCreateManyStudentInput | QuizSubmissionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StreamItemCreateWithoutAuthorInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentCreateNestedManyWithoutStreamItemInput
    material?: MaterialCreateNestedOneWithoutStreamItemInput
    quiz?: QuizCreateNestedOneWithoutStreamItemInput
    class?: ClassCreateNestedOneWithoutStreamItemsInput
    topic?: TopicCreateNestedOneWithoutStreamItemsInput
  }

  export type StreamItemUncheckedCreateWithoutAuthorInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStreamItemInput
    material?: MaterialUncheckedCreateNestedOneWithoutStreamItemInput
    quiz?: QuizUncheckedCreateNestedOneWithoutStreamItemInput
  }

  export type StreamItemCreateOrConnectWithoutAuthorInput = {
    where: StreamItemWhereUniqueInput
    create: XOR<StreamItemCreateWithoutAuthorInput, StreamItemUncheckedCreateWithoutAuthorInput>
  }

  export type StreamItemCreateManyAuthorInputEnvelope = {
    data: StreamItemCreateManyAuthorInput | StreamItemCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type StudentParentCreateWithoutParentInput = {
    id?: string
    relationship?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: UserCreateNestedOneWithoutStudentParentsInput
  }

  export type StudentParentUncheckedCreateWithoutParentInput = {
    id?: string
    studentId: string
    relationship?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentCreateOrConnectWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    create: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput>
  }

  export type StudentParentCreateManyParentInputEnvelope = {
    data: StudentParentCreateManyParentInput | StudentParentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type StudentParentCreateWithoutStudentInput = {
    id?: string
    relationship?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent: UserCreateNestedOneWithoutParentRelationsInput
  }

  export type StudentParentUncheckedCreateWithoutStudentInput = {
    id?: string
    parentId: string
    relationship?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentCreateOrConnectWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    create: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentCreateManyStudentInputEnvelope = {
    data: StudentParentCreateManyStudentInput | StudentParentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type BugReportCreateWithoutUserInput = {
    id?: string
    description: string
    status?: string
    type?: string
    errorHash?: string | null
    createdAt?: Date | string
  }

  export type BugReportUncheckedCreateWithoutUserInput = {
    id?: string
    description: string
    status?: string
    type?: string
    errorHash?: string | null
    createdAt?: Date | string
  }

  export type BugReportCreateOrConnectWithoutUserInput = {
    where: BugReportWhereUniqueInput
    create: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput>
  }

  export type BugReportCreateManyUserInputEnvelope = {
    data: BugReportCreateManyUserInput | BugReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResidentCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medications?: MedicationOrderCreateNestedManyWithoutResidentInput
    vitalSigns?: VitalSignCreateNestedManyWithoutResidentInput
    nursingNotes?: NursingNoteCreateNestedManyWithoutResidentInput
  }

  export type ResidentUncheckedCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medications?: MedicationOrderUncheckedCreateNestedManyWithoutResidentInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutResidentInput
    nursingNotes?: NursingNoteUncheckedCreateNestedManyWithoutResidentInput
  }

  export type ResidentCreateOrConnectWithoutUserInput = {
    where: ResidentWhereUniqueInput
    create: XOR<ResidentCreateWithoutUserInput, ResidentUncheckedCreateWithoutUserInput>
  }

  export type MedicationLogCreateWithoutAdministratorInput = {
    id?: string
    administeredAt?: Date | string
    status: string
    notes?: string | null
    shift?: string | null
    order: MedicationOrderCreateNestedOneWithoutLogsInput
  }

  export type MedicationLogUncheckedCreateWithoutAdministratorInput = {
    id?: string
    orderId: string
    administeredAt?: Date | string
    status: string
    notes?: string | null
    shift?: string | null
  }

  export type MedicationLogCreateOrConnectWithoutAdministratorInput = {
    where: MedicationLogWhereUniqueInput
    create: XOR<MedicationLogCreateWithoutAdministratorInput, MedicationLogUncheckedCreateWithoutAdministratorInput>
  }

  export type MedicationLogCreateManyAdministratorInputEnvelope = {
    data: MedicationLogCreateManyAdministratorInput | MedicationLogCreateManyAdministratorInput[]
    skipDuplicates?: boolean
  }

  export type VitalSignCreateWithoutRecorderInput = {
    id?: string
    recordedAt?: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    temperature?: number | null
    oxygenSaturation?: number | null
    glucose?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentCreateNestedOneWithoutVitalSignsInput
  }

  export type VitalSignUncheckedCreateWithoutRecorderInput = {
    id?: string
    residentId: string
    recordedAt?: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    temperature?: number | null
    oxygenSaturation?: number | null
    glucose?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignCreateOrConnectWithoutRecorderInput = {
    where: VitalSignWhereUniqueInput
    create: XOR<VitalSignCreateWithoutRecorderInput, VitalSignUncheckedCreateWithoutRecorderInput>
  }

  export type VitalSignCreateManyRecorderInputEnvelope = {
    data: VitalSignCreateManyRecorderInput | VitalSignCreateManyRecorderInput[]
    skipDuplicates?: boolean
  }

  export type NursingNoteCreateWithoutAuthorInput = {
    id?: string
    createdAt?: Date | string
    shift: string
    category: string
    content: string
    severity?: string
    updatedAt?: Date | string
    resident: ResidentCreateNestedOneWithoutNursingNotesInput
  }

  export type NursingNoteUncheckedCreateWithoutAuthorInput = {
    id?: string
    residentId: string
    createdAt?: Date | string
    shift: string
    category: string
    content: string
    severity?: string
    updatedAt?: Date | string
  }

  export type NursingNoteCreateOrConnectWithoutAuthorInput = {
    where: NursingNoteWhereUniqueInput
    create: XOR<NursingNoteCreateWithoutAuthorInput, NursingNoteUncheckedCreateWithoutAuthorInput>
  }

  export type NursingNoteCreateManyAuthorInputEnvelope = {
    data: NursingNoteCreateManyAuthorInput | NursingNoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementStudentUpsertWithWhereUniqueWithoutStudentInput = {
    where: AnnouncementStudentWhereUniqueInput
    update: XOR<AnnouncementStudentUpdateWithoutStudentInput, AnnouncementStudentUncheckedUpdateWithoutStudentInput>
    create: XOR<AnnouncementStudentCreateWithoutStudentInput, AnnouncementStudentUncheckedCreateWithoutStudentInput>
  }

  export type AnnouncementStudentUpdateWithWhereUniqueWithoutStudentInput = {
    where: AnnouncementStudentWhereUniqueInput
    data: XOR<AnnouncementStudentUpdateWithoutStudentInput, AnnouncementStudentUncheckedUpdateWithoutStudentInput>
  }

  export type AnnouncementStudentUpdateManyWithWhereWithoutStudentInput = {
    where: AnnouncementStudentScalarWhereInput
    data: XOR<AnnouncementStudentUpdateManyMutationInput, AnnouncementStudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type AnnouncementStudentScalarWhereInput = {
    AND?: AnnouncementStudentScalarWhereInput | AnnouncementStudentScalarWhereInput[]
    OR?: AnnouncementStudentScalarWhereInput[]
    NOT?: AnnouncementStudentScalarWhereInput | AnnouncementStudentScalarWhereInput[]
    id?: StringFilter<"AnnouncementStudent"> | string
    streamItemId?: StringFilter<"AnnouncementStudent"> | string
    studentId?: StringFilter<"AnnouncementStudent"> | string
  }

  export type AssignmentStudentUpsertWithWhereUniqueWithoutStudentInput = {
    where: AssignmentStudentWhereUniqueInput
    update: XOR<AssignmentStudentUpdateWithoutStudentInput, AssignmentStudentUncheckedUpdateWithoutStudentInput>
    create: XOR<AssignmentStudentCreateWithoutStudentInput, AssignmentStudentUncheckedCreateWithoutStudentInput>
  }

  export type AssignmentStudentUpdateWithWhereUniqueWithoutStudentInput = {
    where: AssignmentStudentWhereUniqueInput
    data: XOR<AssignmentStudentUpdateWithoutStudentInput, AssignmentStudentUncheckedUpdateWithoutStudentInput>
  }

  export type AssignmentStudentUpdateManyWithWhereWithoutStudentInput = {
    where: AssignmentStudentScalarWhereInput
    data: XOR<AssignmentStudentUpdateManyMutationInput, AssignmentStudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type AssignmentStudentScalarWhereInput = {
    AND?: AssignmentStudentScalarWhereInput | AssignmentStudentScalarWhereInput[]
    OR?: AssignmentStudentScalarWhereInput[]
    NOT?: AssignmentStudentScalarWhereInput | AssignmentStudentScalarWhereInput[]
    id?: StringFilter<"AssignmentStudent"> | string
    assignmentId?: StringFilter<"AssignmentStudent"> | string
    studentId?: StringFilter<"AssignmentStudent"> | string
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutStudentInput, AssignmentSubmissionUncheckedUpdateWithoutStudentInput>
    create: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutStudentInput, AssignmentSubmissionUncheckedUpdateWithoutStudentInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutStudentInput>
  }

  export type AssignmentSubmissionScalarWhereInput = {
    AND?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
    OR?: AssignmentSubmissionScalarWhereInput[]
    NOT?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
    id?: StringFilter<"AssignmentSubmission"> | string
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    studentId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    attachments?: JsonNullableFilter<"AssignmentSubmission">
    status?: StringFilter<"AssignmentSubmission"> | string
    submittedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    returnedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    gradedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    createdAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    grade?: DecimalNullableFilter<"AssignmentSubmission"> | Decimal | DecimalJsLike | number | string | null
    studentComments?: StringNullableFilter<"AssignmentSubmission"> | string | null
    teacherComments?: StringNullableFilter<"AssignmentSubmission"> | string | null
    reviewedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
  }

  export type ClassMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ClassMemberWhereUniqueInput
    update: XOR<ClassMemberUpdateWithoutUserInput, ClassMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ClassMemberCreateWithoutUserInput, ClassMemberUncheckedCreateWithoutUserInput>
  }

  export type ClassMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ClassMemberWhereUniqueInput
    data: XOR<ClassMemberUpdateWithoutUserInput, ClassMemberUncheckedUpdateWithoutUserInput>
  }

  export type ClassMemberUpdateManyWithWhereWithoutUserInput = {
    where: ClassMemberScalarWhereInput
    data: XOR<ClassMemberUpdateManyMutationInput, ClassMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ClassMemberScalarWhereInput = {
    AND?: ClassMemberScalarWhereInput | ClassMemberScalarWhereInput[]
    OR?: ClassMemberScalarWhereInput[]
    NOT?: ClassMemberScalarWhereInput | ClassMemberScalarWhereInput[]
    id?: StringFilter<"ClassMember"> | string
    classId?: StringFilter<"ClassMember"> | string
    userId?: StringFilter<"ClassMember"> | string
    role?: StringFilter<"ClassMember"> | string
    joinedAt?: DateTimeFilter<"ClassMember"> | Date | string
    status?: StringFilter<"ClassMember"> | string
  }

  export type ClassUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutTeacherInput, ClassUncheckedUpdateWithoutTeacherInput>
    create: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutTeacherInput, ClassUncheckedUpdateWithoutTeacherInput>
  }

  export type ClassUpdateManyWithWhereWithoutTeacherInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    title?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    classCode?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    subject?: StringNullableFilter<"Class"> | string | null
    room?: StringNullableFilter<"Class"> | string | null
    teacherId?: StringFilter<"Class"> | string
    moduleId?: StringNullableFilter<"Class"> | string | null
    backgroundImage?: StringNullableFilter<"Class"> | string | null
    isArchived?: BoolFilter<"Class"> | boolean
    status?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type GradeUpsertWithWhereUniqueWithoutGradedByInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutGradedByInput, GradeUncheckedUpdateWithoutGradedByInput>
    create: XOR<GradeCreateWithoutGradedByInput, GradeUncheckedCreateWithoutGradedByInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutGradedByInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutGradedByInput, GradeUncheckedUpdateWithoutGradedByInput>
  }

  export type GradeUpdateManyWithWhereWithoutGradedByInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutGradedByInput>
  }

  export type GradeScalarWhereInput = {
    AND?: GradeScalarWhereInput | GradeScalarWhereInput[]
    OR?: GradeScalarWhereInput[]
    NOT?: GradeScalarWhereInput | GradeScalarWhereInput[]
    id?: StringFilter<"Grade"> | string
    classId?: StringFilter<"Grade"> | string
    assignmentId?: StringNullableFilter<"Grade"> | string | null
    quizId?: StringNullableFilter<"Grade"> | string | null
    studentId?: StringFilter<"Grade"> | string
    pointsEarned?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    maxPoints?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    percentage?: DecimalNullableFilter<"Grade"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"Grade"> | string
    feedback?: StringNullableFilter<"Grade"> | string | null
    submittedAt?: DateTimeNullableFilter<"Grade"> | Date | string | null
    gradedAt?: DateTimeNullableFilter<"Grade"> | Date | string | null
    gradedById?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
  }

  export type GradeUpsertWithWhereUniqueWithoutStudentInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutStudentInput, GradeUncheckedUpdateWithoutStudentInput>
    create: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutStudentInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutStudentInput, GradeUncheckedUpdateWithoutStudentInput>
  }

  export type GradeUpdateManyWithWhereWithoutStudentInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutStudentInput>
  }

  export type MaterialStudentUpsertWithWhereUniqueWithoutStudentInput = {
    where: MaterialStudentWhereUniqueInput
    update: XOR<MaterialStudentUpdateWithoutStudentInput, MaterialStudentUncheckedUpdateWithoutStudentInput>
    create: XOR<MaterialStudentCreateWithoutStudentInput, MaterialStudentUncheckedCreateWithoutStudentInput>
  }

  export type MaterialStudentUpdateWithWhereUniqueWithoutStudentInput = {
    where: MaterialStudentWhereUniqueInput
    data: XOR<MaterialStudentUpdateWithoutStudentInput, MaterialStudentUncheckedUpdateWithoutStudentInput>
  }

  export type MaterialStudentUpdateManyWithWhereWithoutStudentInput = {
    where: MaterialStudentScalarWhereInput
    data: XOR<MaterialStudentUpdateManyMutationInput, MaterialStudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type MaterialStudentScalarWhereInput = {
    AND?: MaterialStudentScalarWhereInput | MaterialStudentScalarWhereInput[]
    OR?: MaterialStudentScalarWhereInput[]
    NOT?: MaterialStudentScalarWhereInput | MaterialStudentScalarWhereInput[]
    id?: StringFilter<"MaterialStudent"> | string
    materialId?: StringFilter<"MaterialStudent"> | string
    studentId?: StringFilter<"MaterialStudent"> | string
  }

  export type ModuleUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutCreatedByInput, ModuleUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ModuleCreateWithoutCreatedByInput, ModuleUncheckedCreateWithoutCreatedByInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutCreatedByInput, ModuleUncheckedUpdateWithoutCreatedByInput>
  }

  export type ModuleUpdateManyWithWhereWithoutCreatedByInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    id?: StringFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    url?: StringNullableFilter<"Module"> | string | null
    category?: StringNullableFilter<"Module"> | string | null
    difficulty?: StringNullableFilter<"Module"> | string | null
    duration?: IntNullableFilter<"Module"> | number | null
    thumbnail?: StringNullableFilter<"Module"> | string | null
    instructor?: StringNullableFilter<"Module"> | string | null
    isActive?: BoolFilter<"Module"> | boolean
    isPublished?: BoolFilter<"Module"> | boolean
    order?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    createdById?: StringNullableFilter<"Module"> | string | null
  }

  export type OrdenUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: OrdenWhereUniqueInput
    update: XOR<OrdenUpdateWithoutCreatedByInput, OrdenUncheckedUpdateWithoutCreatedByInput>
    create: XOR<OrdenCreateWithoutCreatedByInput, OrdenUncheckedCreateWithoutCreatedByInput>
  }

  export type OrdenUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: OrdenWhereUniqueInput
    data: XOR<OrdenUpdateWithoutCreatedByInput, OrdenUncheckedUpdateWithoutCreatedByInput>
  }

  export type OrdenUpdateManyWithWhereWithoutCreatedByInput = {
    where: OrdenScalarWhereInput
    data: XOR<OrdenUpdateManyMutationInput, OrdenUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type OrdenScalarWhereInput = {
    AND?: OrdenScalarWhereInput | OrdenScalarWhereInput[]
    OR?: OrdenScalarWhereInput[]
    NOT?: OrdenScalarWhereInput | OrdenScalarWhereInput[]
    id?: StringFilter<"Orden"> | string
    orderNumber?: StringFilter<"Orden"> | string
    clientId?: StringNullableFilter<"Orden"> | string | null
    clientName?: StringFilter<"Orden"> | string
    clientEmail?: StringNullableFilter<"Orden"> | string | null
    subtotal?: DecimalFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Orden"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Orden"> | string
    notes?: StringNullableFilter<"Orden"> | string | null
    createdById?: StringFilter<"Orden"> | string
    createdAt?: DateTimeFilter<"Orden"> | Date | string
    updatedAt?: DateTimeFilter<"Orden"> | Date | string
  }

  export type QuizStudentUpsertWithWhereUniqueWithoutStudentInput = {
    where: QuizStudentWhereUniqueInput
    update: XOR<QuizStudentUpdateWithoutStudentInput, QuizStudentUncheckedUpdateWithoutStudentInput>
    create: XOR<QuizStudentCreateWithoutStudentInput, QuizStudentUncheckedCreateWithoutStudentInput>
  }

  export type QuizStudentUpdateWithWhereUniqueWithoutStudentInput = {
    where: QuizStudentWhereUniqueInput
    data: XOR<QuizStudentUpdateWithoutStudentInput, QuizStudentUncheckedUpdateWithoutStudentInput>
  }

  export type QuizStudentUpdateManyWithWhereWithoutStudentInput = {
    where: QuizStudentScalarWhereInput
    data: XOR<QuizStudentUpdateManyMutationInput, QuizStudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type QuizStudentScalarWhereInput = {
    AND?: QuizStudentScalarWhereInput | QuizStudentScalarWhereInput[]
    OR?: QuizStudentScalarWhereInput[]
    NOT?: QuizStudentScalarWhereInput | QuizStudentScalarWhereInput[]
    id?: StringFilter<"QuizStudent"> | string
    quizId?: StringFilter<"QuizStudent"> | string
    studentId?: StringFilter<"QuizStudent"> | string
  }

  export type QuizSubmissionUpsertWithWhereUniqueWithoutStudentInput = {
    where: QuizSubmissionWhereUniqueInput
    update: XOR<QuizSubmissionUpdateWithoutStudentInput, QuizSubmissionUncheckedUpdateWithoutStudentInput>
    create: XOR<QuizSubmissionCreateWithoutStudentInput, QuizSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type QuizSubmissionUpdateWithWhereUniqueWithoutStudentInput = {
    where: QuizSubmissionWhereUniqueInput
    data: XOR<QuizSubmissionUpdateWithoutStudentInput, QuizSubmissionUncheckedUpdateWithoutStudentInput>
  }

  export type QuizSubmissionUpdateManyWithWhereWithoutStudentInput = {
    where: QuizSubmissionScalarWhereInput
    data: XOR<QuizSubmissionUpdateManyMutationInput, QuizSubmissionUncheckedUpdateManyWithoutStudentInput>
  }

  export type QuizSubmissionScalarWhereInput = {
    AND?: QuizSubmissionScalarWhereInput | QuizSubmissionScalarWhereInput[]
    OR?: QuizSubmissionScalarWhereInput[]
    NOT?: QuizSubmissionScalarWhereInput | QuizSubmissionScalarWhereInput[]
    id?: StringFilter<"QuizSubmission"> | string
    quizId?: StringFilter<"QuizSubmission"> | string
    studentId?: StringFilter<"QuizSubmission"> | string
    answers?: JsonNullableFilter<"QuizSubmission">
    status?: StringFilter<"QuizSubmission"> | string
    grade?: DecimalNullableFilter<"QuizSubmission"> | Decimal | DecimalJsLike | number | string | null
    studentComments?: StringNullableFilter<"QuizSubmission"> | string | null
    teacherComments?: StringNullableFilter<"QuizSubmission"> | string | null
    submittedAt?: DateTimeNullableFilter<"QuizSubmission"> | Date | string | null
    gradedAt?: DateTimeNullableFilter<"QuizSubmission"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"QuizSubmission"> | Date | string | null
    createdAt?: DateTimeFilter<"QuizSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"QuizSubmission"> | Date | string
  }

  export type StreamItemUpsertWithWhereUniqueWithoutAuthorInput = {
    where: StreamItemWhereUniqueInput
    update: XOR<StreamItemUpdateWithoutAuthorInput, StreamItemUncheckedUpdateWithoutAuthorInput>
    create: XOR<StreamItemCreateWithoutAuthorInput, StreamItemUncheckedCreateWithoutAuthorInput>
  }

  export type StreamItemUpdateWithWhereUniqueWithoutAuthorInput = {
    where: StreamItemWhereUniqueInput
    data: XOR<StreamItemUpdateWithoutAuthorInput, StreamItemUncheckedUpdateWithoutAuthorInput>
  }

  export type StreamItemUpdateManyWithWhereWithoutAuthorInput = {
    where: StreamItemScalarWhereInput
    data: XOR<StreamItemUpdateManyMutationInput, StreamItemUncheckedUpdateManyWithoutAuthorInput>
  }

  export type StreamItemScalarWhereInput = {
    AND?: StreamItemScalarWhereInput | StreamItemScalarWhereInput[]
    OR?: StreamItemScalarWhereInput[]
    NOT?: StreamItemScalarWhereInput | StreamItemScalarWhereInput[]
    id?: StringFilter<"StreamItem"> | string
    classId?: StringNullableFilter<"StreamItem"> | string | null
    type?: StringFilter<"StreamItem"> | string
    title?: StringFilter<"StreamItem"> | string
    content?: StringNullableFilter<"StreamItem"> | string | null
    authorId?: StringFilter<"StreamItem"> | string
    topicId?: StringNullableFilter<"StreamItem"> | string | null
    createdAt?: DateTimeFilter<"StreamItem"> | Date | string
    updatedAt?: DateTimeFilter<"StreamItem"> | Date | string
    isArchived?: BoolFilter<"StreamItem"> | boolean
  }

  export type StudentParentUpsertWithWhereUniqueWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    update: XOR<StudentParentUpdateWithoutParentInput, StudentParentUncheckedUpdateWithoutParentInput>
    create: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput>
  }

  export type StudentParentUpdateWithWhereUniqueWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    data: XOR<StudentParentUpdateWithoutParentInput, StudentParentUncheckedUpdateWithoutParentInput>
  }

  export type StudentParentUpdateManyWithWhereWithoutParentInput = {
    where: StudentParentScalarWhereInput
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyWithoutParentInput>
  }

  export type StudentParentScalarWhereInput = {
    AND?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
    OR?: StudentParentScalarWhereInput[]
    NOT?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
    id?: StringFilter<"StudentParent"> | string
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    relationship?: StringNullableFilter<"StudentParent"> | string | null
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    createdAt?: DateTimeFilter<"StudentParent"> | Date | string
    updatedAt?: DateTimeFilter<"StudentParent"> | Date | string
  }

  export type StudentParentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    update: XOR<StudentParentUpdateWithoutStudentInput, StudentParentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    data: XOR<StudentParentUpdateWithoutStudentInput, StudentParentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentParentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentParentScalarWhereInput
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyWithoutStudentInput>
  }

  export type BugReportUpsertWithWhereUniqueWithoutUserInput = {
    where: BugReportWhereUniqueInput
    update: XOR<BugReportUpdateWithoutUserInput, BugReportUncheckedUpdateWithoutUserInput>
    create: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput>
  }

  export type BugReportUpdateWithWhereUniqueWithoutUserInput = {
    where: BugReportWhereUniqueInput
    data: XOR<BugReportUpdateWithoutUserInput, BugReportUncheckedUpdateWithoutUserInput>
  }

  export type BugReportUpdateManyWithWhereWithoutUserInput = {
    where: BugReportScalarWhereInput
    data: XOR<BugReportUpdateManyMutationInput, BugReportUncheckedUpdateManyWithoutUserInput>
  }

  export type BugReportScalarWhereInput = {
    AND?: BugReportScalarWhereInput | BugReportScalarWhereInput[]
    OR?: BugReportScalarWhereInput[]
    NOT?: BugReportScalarWhereInput | BugReportScalarWhereInput[]
    id?: StringFilter<"BugReport"> | string
    description?: StringFilter<"BugReport"> | string
    userId?: StringNullableFilter<"BugReport"> | string | null
    status?: StringFilter<"BugReport"> | string
    type?: StringFilter<"BugReport"> | string
    errorHash?: StringNullableFilter<"BugReport"> | string | null
    createdAt?: DateTimeFilter<"BugReport"> | Date | string
  }

  export type ResidentUpsertWithoutUserInput = {
    update: XOR<ResidentUpdateWithoutUserInput, ResidentUncheckedUpdateWithoutUserInput>
    create: XOR<ResidentCreateWithoutUserInput, ResidentUncheckedCreateWithoutUserInput>
    where?: ResidentWhereInput
  }

  export type ResidentUpdateToOneWithWhereWithoutUserInput = {
    where?: ResidentWhereInput
    data: XOR<ResidentUpdateWithoutUserInput, ResidentUncheckedUpdateWithoutUserInput>
  }

  export type ResidentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationOrderUpdateManyWithoutResidentNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutResidentNestedInput
    nursingNotes?: NursingNoteUpdateManyWithoutResidentNestedInput
  }

  export type ResidentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationOrderUncheckedUpdateManyWithoutResidentNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutResidentNestedInput
    nursingNotes?: NursingNoteUncheckedUpdateManyWithoutResidentNestedInput
  }

  export type MedicationLogUpsertWithWhereUniqueWithoutAdministratorInput = {
    where: MedicationLogWhereUniqueInput
    update: XOR<MedicationLogUpdateWithoutAdministratorInput, MedicationLogUncheckedUpdateWithoutAdministratorInput>
    create: XOR<MedicationLogCreateWithoutAdministratorInput, MedicationLogUncheckedCreateWithoutAdministratorInput>
  }

  export type MedicationLogUpdateWithWhereUniqueWithoutAdministratorInput = {
    where: MedicationLogWhereUniqueInput
    data: XOR<MedicationLogUpdateWithoutAdministratorInput, MedicationLogUncheckedUpdateWithoutAdministratorInput>
  }

  export type MedicationLogUpdateManyWithWhereWithoutAdministratorInput = {
    where: MedicationLogScalarWhereInput
    data: XOR<MedicationLogUpdateManyMutationInput, MedicationLogUncheckedUpdateManyWithoutAdministratorInput>
  }

  export type MedicationLogScalarWhereInput = {
    AND?: MedicationLogScalarWhereInput | MedicationLogScalarWhereInput[]
    OR?: MedicationLogScalarWhereInput[]
    NOT?: MedicationLogScalarWhereInput | MedicationLogScalarWhereInput[]
    id?: StringFilter<"MedicationLog"> | string
    orderId?: StringFilter<"MedicationLog"> | string
    administeredBy?: StringFilter<"MedicationLog"> | string
    administeredAt?: DateTimeFilter<"MedicationLog"> | Date | string
    status?: StringFilter<"MedicationLog"> | string
    notes?: StringNullableFilter<"MedicationLog"> | string | null
    shift?: StringNullableFilter<"MedicationLog"> | string | null
  }

  export type VitalSignUpsertWithWhereUniqueWithoutRecorderInput = {
    where: VitalSignWhereUniqueInput
    update: XOR<VitalSignUpdateWithoutRecorderInput, VitalSignUncheckedUpdateWithoutRecorderInput>
    create: XOR<VitalSignCreateWithoutRecorderInput, VitalSignUncheckedCreateWithoutRecorderInput>
  }

  export type VitalSignUpdateWithWhereUniqueWithoutRecorderInput = {
    where: VitalSignWhereUniqueInput
    data: XOR<VitalSignUpdateWithoutRecorderInput, VitalSignUncheckedUpdateWithoutRecorderInput>
  }

  export type VitalSignUpdateManyWithWhereWithoutRecorderInput = {
    where: VitalSignScalarWhereInput
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyWithoutRecorderInput>
  }

  export type VitalSignScalarWhereInput = {
    AND?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
    OR?: VitalSignScalarWhereInput[]
    NOT?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
    id?: StringFilter<"VitalSign"> | string
    residentId?: StringFilter<"VitalSign"> | string
    recordedBy?: StringFilter<"VitalSign"> | string
    recordedAt?: DateTimeFilter<"VitalSign"> | Date | string
    bloodPressureSystolic?: IntNullableFilter<"VitalSign"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"VitalSign"> | number | null
    heartRate?: IntNullableFilter<"VitalSign"> | number | null
    temperature?: FloatNullableFilter<"VitalSign"> | number | null
    oxygenSaturation?: IntNullableFilter<"VitalSign"> | number | null
    glucose?: IntNullableFilter<"VitalSign"> | number | null
    weight?: FloatNullableFilter<"VitalSign"> | number | null
    notes?: StringNullableFilter<"VitalSign"> | string | null
    createdAt?: DateTimeFilter<"VitalSign"> | Date | string
    updatedAt?: DateTimeFilter<"VitalSign"> | Date | string
  }

  export type NursingNoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: NursingNoteWhereUniqueInput
    update: XOR<NursingNoteUpdateWithoutAuthorInput, NursingNoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<NursingNoteCreateWithoutAuthorInput, NursingNoteUncheckedCreateWithoutAuthorInput>
  }

  export type NursingNoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: NursingNoteWhereUniqueInput
    data: XOR<NursingNoteUpdateWithoutAuthorInput, NursingNoteUncheckedUpdateWithoutAuthorInput>
  }

  export type NursingNoteUpdateManyWithWhereWithoutAuthorInput = {
    where: NursingNoteScalarWhereInput
    data: XOR<NursingNoteUpdateManyMutationInput, NursingNoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type NursingNoteScalarWhereInput = {
    AND?: NursingNoteScalarWhereInput | NursingNoteScalarWhereInput[]
    OR?: NursingNoteScalarWhereInput[]
    NOT?: NursingNoteScalarWhereInput | NursingNoteScalarWhereInput[]
    id?: StringFilter<"NursingNote"> | string
    residentId?: StringFilter<"NursingNote"> | string
    authorId?: StringFilter<"NursingNote"> | string
    createdAt?: DateTimeFilter<"NursingNote"> | Date | string
    shift?: StringFilter<"NursingNote"> | string
    category?: StringFilter<"NursingNote"> | string
    content?: StringFilter<"NursingNote"> | string
    severity?: StringFilter<"NursingNote"> | string
    updatedAt?: DateTimeFilter<"NursingNote"> | Date | string
  }

  export type UserCreateWithoutBugReportsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutBugReportsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutBugReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBugReportsInput, UserUncheckedCreateWithoutBugReportsInput>
  }

  export type UserUpsertWithoutBugReportsInput = {
    update: XOR<UserUpdateWithoutBugReportsInput, UserUncheckedUpdateWithoutBugReportsInput>
    create: XOR<UserCreateWithoutBugReportsInput, UserUncheckedCreateWithoutBugReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBugReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBugReportsInput, UserUncheckedUpdateWithoutBugReportsInput>
  }

  export type UserUpdateWithoutBugReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutBugReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutResidentInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutResidentInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutResidentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResidentInput, UserUncheckedCreateWithoutResidentInput>
  }

  export type MedicationOrderCreateWithoutResidentInput = {
    id?: string
    medicationName: string
    dosage: string
    frequency: string
    route: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: MedicationLogCreateNestedManyWithoutOrderInput
  }

  export type MedicationOrderUncheckedCreateWithoutResidentInput = {
    id?: string
    medicationName: string
    dosage: string
    frequency: string
    route: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: MedicationLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type MedicationOrderCreateOrConnectWithoutResidentInput = {
    where: MedicationOrderWhereUniqueInput
    create: XOR<MedicationOrderCreateWithoutResidentInput, MedicationOrderUncheckedCreateWithoutResidentInput>
  }

  export type MedicationOrderCreateManyResidentInputEnvelope = {
    data: MedicationOrderCreateManyResidentInput | MedicationOrderCreateManyResidentInput[]
    skipDuplicates?: boolean
  }

  export type VitalSignCreateWithoutResidentInput = {
    id?: string
    recordedAt?: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    temperature?: number | null
    oxygenSaturation?: number | null
    glucose?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recorder: UserCreateNestedOneWithoutRecordedVitalsInput
  }

  export type VitalSignUncheckedCreateWithoutResidentInput = {
    id?: string
    recordedBy: string
    recordedAt?: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    temperature?: number | null
    oxygenSaturation?: number | null
    glucose?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignCreateOrConnectWithoutResidentInput = {
    where: VitalSignWhereUniqueInput
    create: XOR<VitalSignCreateWithoutResidentInput, VitalSignUncheckedCreateWithoutResidentInput>
  }

  export type VitalSignCreateManyResidentInputEnvelope = {
    data: VitalSignCreateManyResidentInput | VitalSignCreateManyResidentInput[]
    skipDuplicates?: boolean
  }

  export type NursingNoteCreateWithoutResidentInput = {
    id?: string
    createdAt?: Date | string
    shift: string
    category: string
    content: string
    severity?: string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutAuthoredNotesInput
  }

  export type NursingNoteUncheckedCreateWithoutResidentInput = {
    id?: string
    authorId: string
    createdAt?: Date | string
    shift: string
    category: string
    content: string
    severity?: string
    updatedAt?: Date | string
  }

  export type NursingNoteCreateOrConnectWithoutResidentInput = {
    where: NursingNoteWhereUniqueInput
    create: XOR<NursingNoteCreateWithoutResidentInput, NursingNoteUncheckedCreateWithoutResidentInput>
  }

  export type NursingNoteCreateManyResidentInputEnvelope = {
    data: NursingNoteCreateManyResidentInput | NursingNoteCreateManyResidentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutResidentInput = {
    update: XOR<UserUpdateWithoutResidentInput, UserUncheckedUpdateWithoutResidentInput>
    create: XOR<UserCreateWithoutResidentInput, UserUncheckedCreateWithoutResidentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResidentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResidentInput, UserUncheckedUpdateWithoutResidentInput>
  }

  export type UserUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type MedicationOrderUpsertWithWhereUniqueWithoutResidentInput = {
    where: MedicationOrderWhereUniqueInput
    update: XOR<MedicationOrderUpdateWithoutResidentInput, MedicationOrderUncheckedUpdateWithoutResidentInput>
    create: XOR<MedicationOrderCreateWithoutResidentInput, MedicationOrderUncheckedCreateWithoutResidentInput>
  }

  export type MedicationOrderUpdateWithWhereUniqueWithoutResidentInput = {
    where: MedicationOrderWhereUniqueInput
    data: XOR<MedicationOrderUpdateWithoutResidentInput, MedicationOrderUncheckedUpdateWithoutResidentInput>
  }

  export type MedicationOrderUpdateManyWithWhereWithoutResidentInput = {
    where: MedicationOrderScalarWhereInput
    data: XOR<MedicationOrderUpdateManyMutationInput, MedicationOrderUncheckedUpdateManyWithoutResidentInput>
  }

  export type MedicationOrderScalarWhereInput = {
    AND?: MedicationOrderScalarWhereInput | MedicationOrderScalarWhereInput[]
    OR?: MedicationOrderScalarWhereInput[]
    NOT?: MedicationOrderScalarWhereInput | MedicationOrderScalarWhereInput[]
    id?: StringFilter<"MedicationOrder"> | string
    residentId?: StringFilter<"MedicationOrder"> | string
    medicationName?: StringFilter<"MedicationOrder"> | string
    dosage?: StringFilter<"MedicationOrder"> | string
    frequency?: StringFilter<"MedicationOrder"> | string
    route?: StringFilter<"MedicationOrder"> | string
    startDate?: DateTimeFilter<"MedicationOrder"> | Date | string
    endDate?: DateTimeNullableFilter<"MedicationOrder"> | Date | string | null
    isActive?: BoolFilter<"MedicationOrder"> | boolean
    instructions?: StringNullableFilter<"MedicationOrder"> | string | null
    createdAt?: DateTimeFilter<"MedicationOrder"> | Date | string
    updatedAt?: DateTimeFilter<"MedicationOrder"> | Date | string
  }

  export type VitalSignUpsertWithWhereUniqueWithoutResidentInput = {
    where: VitalSignWhereUniqueInput
    update: XOR<VitalSignUpdateWithoutResidentInput, VitalSignUncheckedUpdateWithoutResidentInput>
    create: XOR<VitalSignCreateWithoutResidentInput, VitalSignUncheckedCreateWithoutResidentInput>
  }

  export type VitalSignUpdateWithWhereUniqueWithoutResidentInput = {
    where: VitalSignWhereUniqueInput
    data: XOR<VitalSignUpdateWithoutResidentInput, VitalSignUncheckedUpdateWithoutResidentInput>
  }

  export type VitalSignUpdateManyWithWhereWithoutResidentInput = {
    where: VitalSignScalarWhereInput
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyWithoutResidentInput>
  }

  export type NursingNoteUpsertWithWhereUniqueWithoutResidentInput = {
    where: NursingNoteWhereUniqueInput
    update: XOR<NursingNoteUpdateWithoutResidentInput, NursingNoteUncheckedUpdateWithoutResidentInput>
    create: XOR<NursingNoteCreateWithoutResidentInput, NursingNoteUncheckedCreateWithoutResidentInput>
  }

  export type NursingNoteUpdateWithWhereUniqueWithoutResidentInput = {
    where: NursingNoteWhereUniqueInput
    data: XOR<NursingNoteUpdateWithoutResidentInput, NursingNoteUncheckedUpdateWithoutResidentInput>
  }

  export type NursingNoteUpdateManyWithWhereWithoutResidentInput = {
    where: NursingNoteScalarWhereInput
    data: XOR<NursingNoteUpdateManyMutationInput, NursingNoteUncheckedUpdateManyWithoutResidentInput>
  }

  export type ResidentCreateWithoutMedicationsInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutResidentInput
    vitalSigns?: VitalSignCreateNestedManyWithoutResidentInput
    nursingNotes?: NursingNoteCreateNestedManyWithoutResidentInput
  }

  export type ResidentUncheckedCreateWithoutMedicationsInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutResidentInput
    nursingNotes?: NursingNoteUncheckedCreateNestedManyWithoutResidentInput
  }

  export type ResidentCreateOrConnectWithoutMedicationsInput = {
    where: ResidentWhereUniqueInput
    create: XOR<ResidentCreateWithoutMedicationsInput, ResidentUncheckedCreateWithoutMedicationsInput>
  }

  export type MedicationLogCreateWithoutOrderInput = {
    id?: string
    administeredAt?: Date | string
    status: string
    notes?: string | null
    shift?: string | null
    administrator: UserCreateNestedOneWithoutMedicationLogsInput
  }

  export type MedicationLogUncheckedCreateWithoutOrderInput = {
    id?: string
    administeredBy: string
    administeredAt?: Date | string
    status: string
    notes?: string | null
    shift?: string | null
  }

  export type MedicationLogCreateOrConnectWithoutOrderInput = {
    where: MedicationLogWhereUniqueInput
    create: XOR<MedicationLogCreateWithoutOrderInput, MedicationLogUncheckedCreateWithoutOrderInput>
  }

  export type MedicationLogCreateManyOrderInputEnvelope = {
    data: MedicationLogCreateManyOrderInput | MedicationLogCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ResidentUpsertWithoutMedicationsInput = {
    update: XOR<ResidentUpdateWithoutMedicationsInput, ResidentUncheckedUpdateWithoutMedicationsInput>
    create: XOR<ResidentCreateWithoutMedicationsInput, ResidentUncheckedCreateWithoutMedicationsInput>
    where?: ResidentWhereInput
  }

  export type ResidentUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: ResidentWhereInput
    data: XOR<ResidentUpdateWithoutMedicationsInput, ResidentUncheckedUpdateWithoutMedicationsInput>
  }

  export type ResidentUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResidentNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutResidentNestedInput
    nursingNotes?: NursingNoteUpdateManyWithoutResidentNestedInput
  }

  export type ResidentUncheckedUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutResidentNestedInput
    nursingNotes?: NursingNoteUncheckedUpdateManyWithoutResidentNestedInput
  }

  export type MedicationLogUpsertWithWhereUniqueWithoutOrderInput = {
    where: MedicationLogWhereUniqueInput
    update: XOR<MedicationLogUpdateWithoutOrderInput, MedicationLogUncheckedUpdateWithoutOrderInput>
    create: XOR<MedicationLogCreateWithoutOrderInput, MedicationLogUncheckedCreateWithoutOrderInput>
  }

  export type MedicationLogUpdateWithWhereUniqueWithoutOrderInput = {
    where: MedicationLogWhereUniqueInput
    data: XOR<MedicationLogUpdateWithoutOrderInput, MedicationLogUncheckedUpdateWithoutOrderInput>
  }

  export type MedicationLogUpdateManyWithWhereWithoutOrderInput = {
    where: MedicationLogScalarWhereInput
    data: XOR<MedicationLogUpdateManyMutationInput, MedicationLogUncheckedUpdateManyWithoutOrderInput>
  }

  export type MedicationOrderCreateWithoutLogsInput = {
    id?: string
    medicationName: string
    dosage: string
    frequency: string
    route: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentCreateNestedOneWithoutMedicationsInput
  }

  export type MedicationOrderUncheckedCreateWithoutLogsInput = {
    id?: string
    residentId: string
    medicationName: string
    dosage: string
    frequency: string
    route: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationOrderCreateOrConnectWithoutLogsInput = {
    where: MedicationOrderWhereUniqueInput
    create: XOR<MedicationOrderCreateWithoutLogsInput, MedicationOrderUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutMedicationLogsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutMedicationLogsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutMedicationLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMedicationLogsInput, UserUncheckedCreateWithoutMedicationLogsInput>
  }

  export type MedicationOrderUpsertWithoutLogsInput = {
    update: XOR<MedicationOrderUpdateWithoutLogsInput, MedicationOrderUncheckedUpdateWithoutLogsInput>
    create: XOR<MedicationOrderCreateWithoutLogsInput, MedicationOrderUncheckedCreateWithoutLogsInput>
    where?: MedicationOrderWhereInput
  }

  export type MedicationOrderUpdateToOneWithWhereWithoutLogsInput = {
    where?: MedicationOrderWhereInput
    data: XOR<MedicationOrderUpdateWithoutLogsInput, MedicationOrderUncheckedUpdateWithoutLogsInput>
  }

  export type MedicationOrderUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentUpdateOneRequiredWithoutMedicationsNestedInput
  }

  export type MedicationOrderUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMedicationLogsInput = {
    update: XOR<UserUpdateWithoutMedicationLogsInput, UserUncheckedUpdateWithoutMedicationLogsInput>
    create: XOR<UserCreateWithoutMedicationLogsInput, UserUncheckedCreateWithoutMedicationLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMedicationLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMedicationLogsInput, UserUncheckedUpdateWithoutMedicationLogsInput>
  }

  export type UserUpdateWithoutMedicationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutMedicationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ResidentCreateWithoutVitalSignsInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutResidentInput
    medications?: MedicationOrderCreateNestedManyWithoutResidentInput
    nursingNotes?: NursingNoteCreateNestedManyWithoutResidentInput
  }

  export type ResidentUncheckedCreateWithoutVitalSignsInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medications?: MedicationOrderUncheckedCreateNestedManyWithoutResidentInput
    nursingNotes?: NursingNoteUncheckedCreateNestedManyWithoutResidentInput
  }

  export type ResidentCreateOrConnectWithoutVitalSignsInput = {
    where: ResidentWhereUniqueInput
    create: XOR<ResidentCreateWithoutVitalSignsInput, ResidentUncheckedCreateWithoutVitalSignsInput>
  }

  export type UserCreateWithoutRecordedVitalsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutRecordedVitalsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutRecordedVitalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecordedVitalsInput, UserUncheckedCreateWithoutRecordedVitalsInput>
  }

  export type ResidentUpsertWithoutVitalSignsInput = {
    update: XOR<ResidentUpdateWithoutVitalSignsInput, ResidentUncheckedUpdateWithoutVitalSignsInput>
    create: XOR<ResidentCreateWithoutVitalSignsInput, ResidentUncheckedCreateWithoutVitalSignsInput>
    where?: ResidentWhereInput
  }

  export type ResidentUpdateToOneWithWhereWithoutVitalSignsInput = {
    where?: ResidentWhereInput
    data: XOR<ResidentUpdateWithoutVitalSignsInput, ResidentUncheckedUpdateWithoutVitalSignsInput>
  }

  export type ResidentUpdateWithoutVitalSignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResidentNestedInput
    medications?: MedicationOrderUpdateManyWithoutResidentNestedInput
    nursingNotes?: NursingNoteUpdateManyWithoutResidentNestedInput
  }

  export type ResidentUncheckedUpdateWithoutVitalSignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationOrderUncheckedUpdateManyWithoutResidentNestedInput
    nursingNotes?: NursingNoteUncheckedUpdateManyWithoutResidentNestedInput
  }

  export type UserUpsertWithoutRecordedVitalsInput = {
    update: XOR<UserUpdateWithoutRecordedVitalsInput, UserUncheckedUpdateWithoutRecordedVitalsInput>
    create: XOR<UserCreateWithoutRecordedVitalsInput, UserUncheckedCreateWithoutRecordedVitalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecordedVitalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecordedVitalsInput, UserUncheckedUpdateWithoutRecordedVitalsInput>
  }

  export type UserUpdateWithoutRecordedVitalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutRecordedVitalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ResidentCreateWithoutNursingNotesInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutResidentInput
    medications?: MedicationOrderCreateNestedManyWithoutResidentInput
    vitalSigns?: VitalSignCreateNestedManyWithoutResidentInput
  }

  export type ResidentUncheckedCreateWithoutNursingNotesInput = {
    id?: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    roomNumber?: string | null
    status?: string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    conditions?: string | null
    carePlanSummary?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medications?: MedicationOrderUncheckedCreateNestedManyWithoutResidentInput
    vitalSigns?: VitalSignUncheckedCreateNestedManyWithoutResidentInput
  }

  export type ResidentCreateOrConnectWithoutNursingNotesInput = {
    where: ResidentWhereUniqueInput
    create: XOR<ResidentCreateWithoutNursingNotesInput, ResidentUncheckedCreateWithoutNursingNotesInput>
  }

  export type UserCreateWithoutAuthoredNotesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
  }

  export type UserUncheckedCreateWithoutAuthoredNotesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
  }

  export type UserCreateOrConnectWithoutAuthoredNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthoredNotesInput, UserUncheckedCreateWithoutAuthoredNotesInput>
  }

  export type ResidentUpsertWithoutNursingNotesInput = {
    update: XOR<ResidentUpdateWithoutNursingNotesInput, ResidentUncheckedUpdateWithoutNursingNotesInput>
    create: XOR<ResidentCreateWithoutNursingNotesInput, ResidentUncheckedCreateWithoutNursingNotesInput>
    where?: ResidentWhereInput
  }

  export type ResidentUpdateToOneWithWhereWithoutNursingNotesInput = {
    where?: ResidentWhereInput
    data: XOR<ResidentUpdateWithoutNursingNotesInput, ResidentUncheckedUpdateWithoutNursingNotesInput>
  }

  export type ResidentUpdateWithoutNursingNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResidentNestedInput
    medications?: MedicationOrderUpdateManyWithoutResidentNestedInput
    vitalSigns?: VitalSignUpdateManyWithoutResidentNestedInput
  }

  export type ResidentUncheckedUpdateWithoutNursingNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    carePlanSummary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: MedicationOrderUncheckedUpdateManyWithoutResidentNestedInput
    vitalSigns?: VitalSignUncheckedUpdateManyWithoutResidentNestedInput
  }

  export type UserUpsertWithoutAuthoredNotesInput = {
    update: XOR<UserUpdateWithoutAuthoredNotesInput, UserUncheckedUpdateWithoutAuthoredNotesInput>
    create: XOR<UserCreateWithoutAuthoredNotesInput, UserUncheckedCreateWithoutAuthoredNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthoredNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthoredNotesInput, UserUncheckedUpdateWithoutAuthoredNotesInput>
  }

  export type UserUpdateWithoutAuthoredNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthoredNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
  }

  export type ClassMemberCreateWithoutClassInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    status?: string
    user: UserCreateNestedOneWithoutClassMembershipsInput
  }

  export type ClassMemberUncheckedCreateWithoutClassInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
    status?: string
  }

  export type ClassMemberCreateOrConnectWithoutClassInput = {
    where: ClassMemberWhereUniqueInput
    create: XOR<ClassMemberCreateWithoutClassInput, ClassMemberUncheckedCreateWithoutClassInput>
  }

  export type ClassMemberCreateManyClassInputEnvelope = {
    data: ClassMemberCreateManyClassInput | ClassMemberCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutClassesInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    category?: string | null
    difficulty?: string | null
    duration?: number | null
    thumbnail?: string | null
    instructor?: string | null
    isActive?: boolean
    isPublished?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutModulesCreatedInput
  }

  export type ModuleUncheckedCreateWithoutClassesInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    category?: string | null
    difficulty?: string | null
    duration?: number | null
    thumbnail?: string | null
    instructor?: string | null
    isActive?: boolean
    isPublished?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type ModuleCreateOrConnectWithoutClassesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutClassesInput, ModuleUncheckedCreateWithoutClassesInput>
  }

  export type UserCreateWithoutClassesAsTeacherInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutClassesAsTeacherInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutClassesAsTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassesAsTeacherInput, UserUncheckedCreateWithoutClassesAsTeacherInput>
  }

  export type GradeCreateWithoutClassInput = {
    id?: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment?: AssignmentCreateNestedOneWithoutGradesInput
    gradedBy?: UserCreateNestedOneWithoutGradesAsGraderInput
    quiz?: QuizCreateNestedOneWithoutGradesInput
    student: UserCreateNestedOneWithoutGradesAsStudentInput
  }

  export type GradeUncheckedCreateWithoutClassInput = {
    id?: string
    assignmentId?: string | null
    quizId?: string | null
    studentId: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutClassInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput>
  }

  export type GradeCreateManyClassInputEnvelope = {
    data: GradeCreateManyClassInput | GradeCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StreamItemCreateWithoutClassInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentCreateNestedManyWithoutStreamItemInput
    material?: MaterialCreateNestedOneWithoutStreamItemInput
    quiz?: QuizCreateNestedOneWithoutStreamItemInput
    author: UserCreateNestedOneWithoutStreamItemsInput
    topic?: TopicCreateNestedOneWithoutStreamItemsInput
  }

  export type StreamItemUncheckedCreateWithoutClassInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    authorId: string
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStreamItemInput
    material?: MaterialUncheckedCreateNestedOneWithoutStreamItemInput
    quiz?: QuizUncheckedCreateNestedOneWithoutStreamItemInput
  }

  export type StreamItemCreateOrConnectWithoutClassInput = {
    where: StreamItemWhereUniqueInput
    create: XOR<StreamItemCreateWithoutClassInput, StreamItemUncheckedCreateWithoutClassInput>
  }

  export type StreamItemCreateManyClassInputEnvelope = {
    data: StreamItemCreateManyClassInput | StreamItemCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type TopicCreateWithoutClassInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    streamItems?: StreamItemCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutClassInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutClassInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutClassInput, TopicUncheckedCreateWithoutClassInput>
  }

  export type TopicCreateManyClassInputEnvelope = {
    data: TopicCreateManyClassInput | TopicCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassMemberUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassMemberWhereUniqueInput
    update: XOR<ClassMemberUpdateWithoutClassInput, ClassMemberUncheckedUpdateWithoutClassInput>
    create: XOR<ClassMemberCreateWithoutClassInput, ClassMemberUncheckedCreateWithoutClassInput>
  }

  export type ClassMemberUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassMemberWhereUniqueInput
    data: XOR<ClassMemberUpdateWithoutClassInput, ClassMemberUncheckedUpdateWithoutClassInput>
  }

  export type ClassMemberUpdateManyWithWhereWithoutClassInput = {
    where: ClassMemberScalarWhereInput
    data: XOR<ClassMemberUpdateManyMutationInput, ClassMemberUncheckedUpdateManyWithoutClassInput>
  }

  export type ModuleUpsertWithoutClassesInput = {
    update: XOR<ModuleUpdateWithoutClassesInput, ModuleUncheckedUpdateWithoutClassesInput>
    create: XOR<ModuleCreateWithoutClassesInput, ModuleUncheckedCreateWithoutClassesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutClassesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutClassesInput, ModuleUncheckedUpdateWithoutClassesInput>
  }

  export type ModuleUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutModulesCreatedNestedInput
  }

  export type ModuleUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutClassesAsTeacherInput = {
    update: XOR<UserUpdateWithoutClassesAsTeacherInput, UserUncheckedUpdateWithoutClassesAsTeacherInput>
    create: XOR<UserCreateWithoutClassesAsTeacherInput, UserUncheckedCreateWithoutClassesAsTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassesAsTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassesAsTeacherInput, UserUncheckedUpdateWithoutClassesAsTeacherInput>
  }

  export type UserUpdateWithoutClassesAsTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutClassesAsTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type GradeUpsertWithWhereUniqueWithoutClassInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutClassInput, GradeUncheckedUpdateWithoutClassInput>
    create: XOR<GradeCreateWithoutClassInput, GradeUncheckedCreateWithoutClassInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutClassInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutClassInput, GradeUncheckedUpdateWithoutClassInput>
  }

  export type GradeUpdateManyWithWhereWithoutClassInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutClassInput>
  }

  export type StreamItemUpsertWithWhereUniqueWithoutClassInput = {
    where: StreamItemWhereUniqueInput
    update: XOR<StreamItemUpdateWithoutClassInput, StreamItemUncheckedUpdateWithoutClassInput>
    create: XOR<StreamItemCreateWithoutClassInput, StreamItemUncheckedCreateWithoutClassInput>
  }

  export type StreamItemUpdateWithWhereUniqueWithoutClassInput = {
    where: StreamItemWhereUniqueInput
    data: XOR<StreamItemUpdateWithoutClassInput, StreamItemUncheckedUpdateWithoutClassInput>
  }

  export type StreamItemUpdateManyWithWhereWithoutClassInput = {
    where: StreamItemScalarWhereInput
    data: XOR<StreamItemUpdateManyMutationInput, StreamItemUncheckedUpdateManyWithoutClassInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutClassInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutClassInput, TopicUncheckedUpdateWithoutClassInput>
    create: XOR<TopicCreateWithoutClassInput, TopicUncheckedCreateWithoutClassInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutClassInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutClassInput, TopicUncheckedUpdateWithoutClassInput>
  }

  export type TopicUpdateManyWithWhereWithoutClassInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutClassInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: StringFilter<"Topic"> | string
    classId?: StringFilter<"Topic"> | string
    name?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    order?: IntFilter<"Topic"> | number
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
  }

  export type ClassCreateWithoutMembersInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    module?: ModuleCreateNestedOneWithoutClassesInput
    teacher: UserCreateNestedOneWithoutClassesAsTeacherInput
    grades?: GradeCreateNestedManyWithoutClassInput
    streamItems?: StreamItemCreateNestedManyWithoutClassInput
    topics?: TopicCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutMembersInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    teacherId: string
    moduleId?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutClassInput
    topics?: TopicUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutMembersInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutMembersInput, ClassUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutClassMembershipsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutClassMembershipsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutClassMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassMembershipsInput, UserUncheckedCreateWithoutClassMembershipsInput>
  }

  export type ClassUpsertWithoutMembersInput = {
    update: XOR<ClassUpdateWithoutMembersInput, ClassUncheckedUpdateWithoutMembersInput>
    create: XOR<ClassCreateWithoutMembersInput, ClassUncheckedCreateWithoutMembersInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutMembersInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutMembersInput, ClassUncheckedUpdateWithoutMembersInput>
  }

  export type ClassUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneWithoutClassesNestedInput
    teacher?: UserUpdateOneRequiredWithoutClassesAsTeacherNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUpdateManyWithoutClassNestedInput
    topics?: TopicUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutClassNestedInput
    topics?: TopicUncheckedUpdateManyWithoutClassNestedInput
  }

  export type UserUpsertWithoutClassMembershipsInput = {
    update: XOR<UserUpdateWithoutClassMembershipsInput, UserUncheckedUpdateWithoutClassMembershipsInput>
    create: XOR<UserCreateWithoutClassMembershipsInput, UserUncheckedCreateWithoutClassMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassMembershipsInput, UserUncheckedUpdateWithoutClassMembershipsInput>
  }

  export type UserUpdateWithoutClassMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutClassMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type StreamItemCreateWithoutTopicInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentCreateNestedManyWithoutStreamItemInput
    material?: MaterialCreateNestedOneWithoutStreamItemInput
    quiz?: QuizCreateNestedOneWithoutStreamItemInput
    author: UserCreateNestedOneWithoutStreamItemsInput
    class?: ClassCreateNestedOneWithoutStreamItemsInput
  }

  export type StreamItemUncheckedCreateWithoutTopicInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStreamItemInput
    material?: MaterialUncheckedCreateNestedOneWithoutStreamItemInput
    quiz?: QuizUncheckedCreateNestedOneWithoutStreamItemInput
  }

  export type StreamItemCreateOrConnectWithoutTopicInput = {
    where: StreamItemWhereUniqueInput
    create: XOR<StreamItemCreateWithoutTopicInput, StreamItemUncheckedCreateWithoutTopicInput>
  }

  export type StreamItemCreateManyTopicInputEnvelope = {
    data: StreamItemCreateManyTopicInput | StreamItemCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutTopicsInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberCreateNestedManyWithoutClassInput
    module?: ModuleCreateNestedOneWithoutClassesInput
    teacher: UserCreateNestedOneWithoutClassesAsTeacherInput
    grades?: GradeCreateNestedManyWithoutClassInput
    streamItems?: StreamItemCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTopicsInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    teacherId: string
    moduleId?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberUncheckedCreateNestedManyWithoutClassInput
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTopicsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTopicsInput, ClassUncheckedCreateWithoutTopicsInput>
  }

  export type StreamItemUpsertWithWhereUniqueWithoutTopicInput = {
    where: StreamItemWhereUniqueInput
    update: XOR<StreamItemUpdateWithoutTopicInput, StreamItemUncheckedUpdateWithoutTopicInput>
    create: XOR<StreamItemCreateWithoutTopicInput, StreamItemUncheckedCreateWithoutTopicInput>
  }

  export type StreamItemUpdateWithWhereUniqueWithoutTopicInput = {
    where: StreamItemWhereUniqueInput
    data: XOR<StreamItemUpdateWithoutTopicInput, StreamItemUncheckedUpdateWithoutTopicInput>
  }

  export type StreamItemUpdateManyWithWhereWithoutTopicInput = {
    where: StreamItemScalarWhereInput
    data: XOR<StreamItemUpdateManyMutationInput, StreamItemUncheckedUpdateManyWithoutTopicInput>
  }

  export type ClassUpsertWithoutTopicsInput = {
    update: XOR<ClassUpdateWithoutTopicsInput, ClassUncheckedUpdateWithoutTopicsInput>
    create: XOR<ClassCreateWithoutTopicsInput, ClassUncheckedCreateWithoutTopicsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutTopicsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutTopicsInput, ClassUncheckedUpdateWithoutTopicsInput>
  }

  export type ClassUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUpdateManyWithoutClassNestedInput
    module?: ModuleUpdateOneWithoutClassesNestedInput
    teacher?: UserUpdateOneRequiredWithoutClassesAsTeacherNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUncheckedUpdateManyWithoutClassNestedInput
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutClassNestedInput
  }

  export type AnnouncementStudentCreateWithoutStreamItemInput = {
    id?: string
    student: UserCreateNestedOneWithoutAnnouncementStudentsInput
  }

  export type AnnouncementStudentUncheckedCreateWithoutStreamItemInput = {
    id?: string
    studentId: string
  }

  export type AnnouncementStudentCreateOrConnectWithoutStreamItemInput = {
    where: AnnouncementStudentWhereUniqueInput
    create: XOR<AnnouncementStudentCreateWithoutStreamItemInput, AnnouncementStudentUncheckedCreateWithoutStreamItemInput>
  }

  export type AnnouncementStudentCreateManyStreamItemInputEnvelope = {
    data: AnnouncementStudentCreateManyStreamItemInput | AnnouncementStudentCreateManyStreamItemInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutStreamItemInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutAssignmentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
    grades?: GradeCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutStreamItemInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutAssignmentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
    grades?: GradeUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutStreamItemInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutStreamItemInput, AssignmentUncheckedCreateWithoutStreamItemInput>
  }

  export type AttachmentCreateWithoutStreamItemInput = {
    id?: string
    type: string
    name: string
    url?: string | null
    filePath?: string | null
    fileSize?: bigint | number | null
    mimeType?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type AttachmentUncheckedCreateWithoutStreamItemInput = {
    id?: string
    type: string
    name: string
    url?: string | null
    filePath?: string | null
    fileSize?: bigint | number | null
    mimeType?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutStreamItemInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutStreamItemInput, AttachmentUncheckedCreateWithoutStreamItemInput>
  }

  export type AttachmentCreateManyStreamItemInputEnvelope = {
    data: AttachmentCreateManyStreamItemInput | AttachmentCreateManyStreamItemInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutStreamItemInput = {
    id?: string
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: MaterialCreateassignedGroupsInput | string[]
    materialStudents?: MaterialStudentCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutStreamItemInput = {
    id?: string
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: MaterialCreateassignedGroupsInput | string[]
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutStreamItemInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutStreamItemInput, MaterialUncheckedCreateWithoutStreamItemInput>
  }

  export type QuizCreateWithoutStreamItemInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    grades?: GradeCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    quizStudents?: QuizStudentCreateNestedManyWithoutQuizInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutStreamItemInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    grades?: GradeUncheckedCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutQuizInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutStreamItemInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutStreamItemInput, QuizUncheckedCreateWithoutStreamItemInput>
  }

  export type UserCreateWithoutStreamItemsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutStreamItemsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutStreamItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStreamItemsInput, UserUncheckedCreateWithoutStreamItemsInput>
  }

  export type ClassCreateWithoutStreamItemsInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberCreateNestedManyWithoutClassInput
    module?: ModuleCreateNestedOneWithoutClassesInput
    teacher: UserCreateNestedOneWithoutClassesAsTeacherInput
    grades?: GradeCreateNestedManyWithoutClassInput
    topics?: TopicCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStreamItemsInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    teacherId: string
    moduleId?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberUncheckedCreateNestedManyWithoutClassInput
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    topics?: TopicUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStreamItemsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStreamItemsInput, ClassUncheckedCreateWithoutStreamItemsInput>
  }

  export type TopicCreateWithoutStreamItemsInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutStreamItemsInput = {
    id?: string
    classId: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicCreateOrConnectWithoutStreamItemsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutStreamItemsInput, TopicUncheckedCreateWithoutStreamItemsInput>
  }

  export type AnnouncementStudentUpsertWithWhereUniqueWithoutStreamItemInput = {
    where: AnnouncementStudentWhereUniqueInput
    update: XOR<AnnouncementStudentUpdateWithoutStreamItemInput, AnnouncementStudentUncheckedUpdateWithoutStreamItemInput>
    create: XOR<AnnouncementStudentCreateWithoutStreamItemInput, AnnouncementStudentUncheckedCreateWithoutStreamItemInput>
  }

  export type AnnouncementStudentUpdateWithWhereUniqueWithoutStreamItemInput = {
    where: AnnouncementStudentWhereUniqueInput
    data: XOR<AnnouncementStudentUpdateWithoutStreamItemInput, AnnouncementStudentUncheckedUpdateWithoutStreamItemInput>
  }

  export type AnnouncementStudentUpdateManyWithWhereWithoutStreamItemInput = {
    where: AnnouncementStudentScalarWhereInput
    data: XOR<AnnouncementStudentUpdateManyMutationInput, AnnouncementStudentUncheckedUpdateManyWithoutStreamItemInput>
  }

  export type AssignmentUpsertWithoutStreamItemInput = {
    update: XOR<AssignmentUpdateWithoutStreamItemInput, AssignmentUncheckedUpdateWithoutStreamItemInput>
    create: XOR<AssignmentCreateWithoutStreamItemInput, AssignmentUncheckedCreateWithoutStreamItemInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutStreamItemInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutStreamItemInput, AssignmentUncheckedUpdateWithoutStreamItemInput>
  }

  export type AssignmentUpdateWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentStudents?: AssignmentStudentUpdateManyWithoutAssignmentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
    grades?: GradeUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutAssignmentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AttachmentUpsertWithWhereUniqueWithoutStreamItemInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutStreamItemInput, AttachmentUncheckedUpdateWithoutStreamItemInput>
    create: XOR<AttachmentCreateWithoutStreamItemInput, AttachmentUncheckedCreateWithoutStreamItemInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutStreamItemInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutStreamItemInput, AttachmentUncheckedUpdateWithoutStreamItemInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutStreamItemInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutStreamItemInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    streamItemId?: StringFilter<"Attachment"> | string
    type?: StringFilter<"Attachment"> | string
    name?: StringFilter<"Attachment"> | string
    url?: StringNullableFilter<"Attachment"> | string | null
    filePath?: StringNullableFilter<"Attachment"> | string | null
    fileSize?: BigIntNullableFilter<"Attachment"> | bigint | number | null
    mimeType?: StringNullableFilter<"Attachment"> | string | null
    order?: IntFilter<"Attachment"> | number
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
  }

  export type MaterialUpsertWithoutStreamItemInput = {
    update: XOR<MaterialUpdateWithoutStreamItemInput, MaterialUncheckedUpdateWithoutStreamItemInput>
    create: XOR<MaterialCreateWithoutStreamItemInput, MaterialUncheckedCreateWithoutStreamItemInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutStreamItemInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutStreamItemInput, MaterialUncheckedUpdateWithoutStreamItemInput>
  }

  export type MaterialUpdateWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: MaterialUpdateassignedGroupsInput | string[]
    materialStudents?: MaterialStudentUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: MaterialUpdateassignedGroupsInput | string[]
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type QuizUpsertWithoutStreamItemInput = {
    update: XOR<QuizUpdateWithoutStreamItemInput, QuizUncheckedUpdateWithoutStreamItemInput>
    create: XOR<QuizCreateWithoutStreamItemInput, QuizUncheckedCreateWithoutStreamItemInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutStreamItemInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutStreamItemInput, QuizUncheckedUpdateWithoutStreamItemInput>
  }

  export type QuizUpdateWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    grades?: GradeUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutQuizNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    grades?: GradeUncheckedUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutQuizNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type UserUpsertWithoutStreamItemsInput = {
    update: XOR<UserUpdateWithoutStreamItemsInput, UserUncheckedUpdateWithoutStreamItemsInput>
    create: XOR<UserCreateWithoutStreamItemsInput, UserUncheckedCreateWithoutStreamItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStreamItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStreamItemsInput, UserUncheckedUpdateWithoutStreamItemsInput>
  }

  export type UserUpdateWithoutStreamItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutStreamItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ClassUpsertWithoutStreamItemsInput = {
    update: XOR<ClassUpdateWithoutStreamItemsInput, ClassUncheckedUpdateWithoutStreamItemsInput>
    create: XOR<ClassCreateWithoutStreamItemsInput, ClassUncheckedCreateWithoutStreamItemsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStreamItemsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStreamItemsInput, ClassUncheckedUpdateWithoutStreamItemsInput>
  }

  export type ClassUpdateWithoutStreamItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUpdateManyWithoutClassNestedInput
    module?: ModuleUpdateOneWithoutClassesNestedInput
    teacher?: UserUpdateOneRequiredWithoutClassesAsTeacherNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    topics?: TopicUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStreamItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUncheckedUpdateManyWithoutClassNestedInput
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    topics?: TopicUncheckedUpdateManyWithoutClassNestedInput
  }

  export type TopicUpsertWithoutStreamItemsInput = {
    update: XOR<TopicUpdateWithoutStreamItemsInput, TopicUncheckedUpdateWithoutStreamItemsInput>
    create: XOR<TopicCreateWithoutStreamItemsInput, TopicUncheckedCreateWithoutStreamItemsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutStreamItemsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutStreamItemsInput, TopicUncheckedUpdateWithoutStreamItemsInput>
  }

  export type TopicUpdateWithoutStreamItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutStreamItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentStudentCreateWithoutAssignmentInput = {
    id?: string
    student: UserCreateNestedOneWithoutAssignmentStudentsInput
  }

  export type AssignmentStudentUncheckedCreateWithoutAssignmentInput = {
    id?: string
    studentId: string
  }

  export type AssignmentStudentCreateOrConnectWithoutAssignmentInput = {
    where: AssignmentStudentWhereUniqueInput
    create: XOR<AssignmentStudentCreateWithoutAssignmentInput, AssignmentStudentUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentStudentCreateManyAssignmentInputEnvelope = {
    data: AssignmentStudentCreateManyAssignmentInput | AssignmentStudentCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentSubmissionCreateWithoutAssignmentInput = {
    id?: string
    content?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    submittedAt?: Date | string | null
    returnedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    reviewedAt?: Date | string | null
    student: UserCreateNestedOneWithoutAssignmentSubmissionsInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutAssignmentInput = {
    id?: string
    studentId: string
    content?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    submittedAt?: Date | string | null
    returnedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    reviewedAt?: Date | string | null
  }

  export type AssignmentSubmissionCreateOrConnectWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionCreateManyAssignmentInputEnvelope = {
    data: AssignmentSubmissionCreateManyAssignmentInput | AssignmentSubmissionCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type StreamItemCreateWithoutAssignmentInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStreamItemInput
    attachments?: AttachmentCreateNestedManyWithoutStreamItemInput
    material?: MaterialCreateNestedOneWithoutStreamItemInput
    quiz?: QuizCreateNestedOneWithoutStreamItemInput
    author: UserCreateNestedOneWithoutStreamItemsInput
    class?: ClassCreateNestedOneWithoutStreamItemsInput
    topic?: TopicCreateNestedOneWithoutStreamItemsInput
  }

  export type StreamItemUncheckedCreateWithoutAssignmentInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    authorId: string
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStreamItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStreamItemInput
    material?: MaterialUncheckedCreateNestedOneWithoutStreamItemInput
    quiz?: QuizUncheckedCreateNestedOneWithoutStreamItemInput
  }

  export type StreamItemCreateOrConnectWithoutAssignmentInput = {
    where: StreamItemWhereUniqueInput
    create: XOR<StreamItemCreateWithoutAssignmentInput, StreamItemUncheckedCreateWithoutAssignmentInput>
  }

  export type GradeCreateWithoutAssignmentInput = {
    id?: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutGradesInput
    gradedBy?: UserCreateNestedOneWithoutGradesAsGraderInput
    quiz?: QuizCreateNestedOneWithoutGradesInput
    student: UserCreateNestedOneWithoutGradesAsStudentInput
  }

  export type GradeUncheckedCreateWithoutAssignmentInput = {
    id?: string
    classId: string
    quizId?: string | null
    studentId: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutAssignmentInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutAssignmentInput, GradeUncheckedCreateWithoutAssignmentInput>
  }

  export type GradeCreateManyAssignmentInputEnvelope = {
    data: GradeCreateManyAssignmentInput | GradeCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentStudentUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentStudentWhereUniqueInput
    update: XOR<AssignmentStudentUpdateWithoutAssignmentInput, AssignmentStudentUncheckedUpdateWithoutAssignmentInput>
    create: XOR<AssignmentStudentCreateWithoutAssignmentInput, AssignmentStudentUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentStudentUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentStudentWhereUniqueInput
    data: XOR<AssignmentStudentUpdateWithoutAssignmentInput, AssignmentStudentUncheckedUpdateWithoutAssignmentInput>
  }

  export type AssignmentStudentUpdateManyWithWhereWithoutAssignmentInput = {
    where: AssignmentStudentScalarWhereInput
    data: XOR<AssignmentStudentUpdateManyMutationInput, AssignmentStudentUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutAssignmentInput, AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput>
    create: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutAssignmentInput, AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type StreamItemUpsertWithoutAssignmentInput = {
    update: XOR<StreamItemUpdateWithoutAssignmentInput, StreamItemUncheckedUpdateWithoutAssignmentInput>
    create: XOR<StreamItemCreateWithoutAssignmentInput, StreamItemUncheckedCreateWithoutAssignmentInput>
    where?: StreamItemWhereInput
  }

  export type StreamItemUpdateToOneWithWhereWithoutAssignmentInput = {
    where?: StreamItemWhereInput
    data: XOR<StreamItemUpdateWithoutAssignmentInput, StreamItemUncheckedUpdateWithoutAssignmentInput>
  }

  export type StreamItemUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStreamItemNestedInput
    attachments?: AttachmentUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUpdateOneWithoutStreamItemNestedInput
    author?: UserUpdateOneRequiredWithoutStreamItemsNestedInput
    class?: ClassUpdateOneWithoutStreamItemsNestedInput
    topic?: TopicUpdateOneWithoutStreamItemsNestedInput
  }

  export type StreamItemUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStreamItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUncheckedUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUncheckedUpdateOneWithoutStreamItemNestedInput
  }

  export type GradeUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutAssignmentInput, GradeUncheckedUpdateWithoutAssignmentInput>
    create: XOR<GradeCreateWithoutAssignmentInput, GradeUncheckedCreateWithoutAssignmentInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutAssignmentInput, GradeUncheckedUpdateWithoutAssignmentInput>
  }

  export type GradeUpdateManyWithWhereWithoutAssignmentInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type AssignmentCreateWithoutAssignmentStudentsInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
    streamItem: StreamItemCreateNestedOneWithoutAssignmentInput
    grades?: GradeCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutAssignmentStudentsInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
    grades?: GradeUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutAssignmentStudentsInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutAssignmentStudentsInput, AssignmentUncheckedCreateWithoutAssignmentStudentsInput>
  }

  export type UserCreateWithoutAssignmentStudentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAssignmentStudentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAssignmentStudentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignmentStudentsInput, UserUncheckedCreateWithoutAssignmentStudentsInput>
  }

  export type AssignmentUpsertWithoutAssignmentStudentsInput = {
    update: XOR<AssignmentUpdateWithoutAssignmentStudentsInput, AssignmentUncheckedUpdateWithoutAssignmentStudentsInput>
    create: XOR<AssignmentCreateWithoutAssignmentStudentsInput, AssignmentUncheckedCreateWithoutAssignmentStudentsInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutAssignmentStudentsInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutAssignmentStudentsInput, AssignmentUncheckedUpdateWithoutAssignmentStudentsInput>
  }

  export type AssignmentUpdateWithoutAssignmentStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
    streamItem?: StreamItemUpdateOneRequiredWithoutAssignmentNestedInput
    grades?: GradeUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutAssignmentStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type UserUpsertWithoutAssignmentStudentsInput = {
    update: XOR<UserUpdateWithoutAssignmentStudentsInput, UserUncheckedUpdateWithoutAssignmentStudentsInput>
    create: XOR<UserCreateWithoutAssignmentStudentsInput, UserUncheckedCreateWithoutAssignmentStudentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignmentStudentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignmentStudentsInput, UserUncheckedUpdateWithoutAssignmentStudentsInput>
  }

  export type UserUpdateWithoutAssignmentStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignmentStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AssignmentCreateWithoutAssignmentSubmissionsInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutAssignmentInput
    streamItem: StreamItemCreateNestedOneWithoutAssignmentInput
    grades?: GradeCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutAssignmentSubmissionsInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutAssignmentInput
    grades?: GradeUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutAssignmentSubmissionsInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutAssignmentSubmissionsInput, AssignmentUncheckedCreateWithoutAssignmentSubmissionsInput>
  }

  export type UserCreateWithoutAssignmentSubmissionsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAssignmentSubmissionsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAssignmentSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignmentSubmissionsInput, UserUncheckedCreateWithoutAssignmentSubmissionsInput>
  }

  export type AssignmentUpsertWithoutAssignmentSubmissionsInput = {
    update: XOR<AssignmentUpdateWithoutAssignmentSubmissionsInput, AssignmentUncheckedUpdateWithoutAssignmentSubmissionsInput>
    create: XOR<AssignmentCreateWithoutAssignmentSubmissionsInput, AssignmentUncheckedCreateWithoutAssignmentSubmissionsInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutAssignmentSubmissionsInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutAssignmentSubmissionsInput, AssignmentUncheckedUpdateWithoutAssignmentSubmissionsInput>
  }

  export type AssignmentUpdateWithoutAssignmentSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentStudents?: AssignmentStudentUpdateManyWithoutAssignmentNestedInput
    streamItem?: StreamItemUpdateOneRequiredWithoutAssignmentNestedInput
    grades?: GradeUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutAssignmentSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutAssignmentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type UserUpsertWithoutAssignmentSubmissionsInput = {
    update: XOR<UserUpdateWithoutAssignmentSubmissionsInput, UserUncheckedUpdateWithoutAssignmentSubmissionsInput>
    create: XOR<UserCreateWithoutAssignmentSubmissionsInput, UserUncheckedCreateWithoutAssignmentSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignmentSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignmentSubmissionsInput, UserUncheckedUpdateWithoutAssignmentSubmissionsInput>
  }

  export type UserUpdateWithoutAssignmentSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignmentSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type GradeCreateWithoutQuizInput = {
    id?: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment?: AssignmentCreateNestedOneWithoutGradesInput
    class: ClassCreateNestedOneWithoutGradesInput
    gradedBy?: UserCreateNestedOneWithoutGradesAsGraderInput
    student: UserCreateNestedOneWithoutGradesAsStudentInput
  }

  export type GradeUncheckedCreateWithoutQuizInput = {
    id?: string
    classId: string
    assignmentId?: string | null
    studentId: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutQuizInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutQuizInput, GradeUncheckedCreateWithoutQuizInput>
  }

  export type GradeCreateManyQuizInputEnvelope = {
    data: GradeCreateManyQuizInput | GradeCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionCreateWithoutQuizInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    required?: boolean
    points?: number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUncheckedCreateWithoutQuizInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    required?: boolean
    points?: number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionCreateOrConnectWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionCreateManyQuizInputEnvelope = {
    data: QuizQuestionCreateManyQuizInput | QuizQuestionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizStudentCreateWithoutQuizInput = {
    id?: string
    student: UserCreateNestedOneWithoutQuizStudentsInput
  }

  export type QuizStudentUncheckedCreateWithoutQuizInput = {
    id?: string
    studentId: string
  }

  export type QuizStudentCreateOrConnectWithoutQuizInput = {
    where: QuizStudentWhereUniqueInput
    create: XOR<QuizStudentCreateWithoutQuizInput, QuizStudentUncheckedCreateWithoutQuizInput>
  }

  export type QuizStudentCreateManyQuizInputEnvelope = {
    data: QuizStudentCreateManyQuizInput | QuizStudentCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizSubmissionCreateWithoutQuizInput = {
    id?: string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: UserCreateNestedOneWithoutQuizSubmissionsInput
  }

  export type QuizSubmissionUncheckedCreateWithoutQuizInput = {
    id?: string
    studentId: string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizSubmissionCreateOrConnectWithoutQuizInput = {
    where: QuizSubmissionWhereUniqueInput
    create: XOR<QuizSubmissionCreateWithoutQuizInput, QuizSubmissionUncheckedCreateWithoutQuizInput>
  }

  export type QuizSubmissionCreateManyQuizInputEnvelope = {
    data: QuizSubmissionCreateManyQuizInput | QuizSubmissionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type StreamItemCreateWithoutQuizInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentCreateNestedManyWithoutStreamItemInput
    material?: MaterialCreateNestedOneWithoutStreamItemInput
    author: UserCreateNestedOneWithoutStreamItemsInput
    class?: ClassCreateNestedOneWithoutStreamItemsInput
    topic?: TopicCreateNestedOneWithoutStreamItemsInput
  }

  export type StreamItemUncheckedCreateWithoutQuizInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    authorId: string
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStreamItemInput
    material?: MaterialUncheckedCreateNestedOneWithoutStreamItemInput
  }

  export type StreamItemCreateOrConnectWithoutQuizInput = {
    where: StreamItemWhereUniqueInput
    create: XOR<StreamItemCreateWithoutQuizInput, StreamItemUncheckedCreateWithoutQuizInput>
  }

  export type GradeUpsertWithWhereUniqueWithoutQuizInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutQuizInput, GradeUncheckedUpdateWithoutQuizInput>
    create: XOR<GradeCreateWithoutQuizInput, GradeUncheckedCreateWithoutQuizInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutQuizInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutQuizInput, GradeUncheckedUpdateWithoutQuizInput>
  }

  export type GradeUpdateManyWithWhereWithoutQuizInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutQuizInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    OR?: QuizQuestionScalarWhereInput[]
    NOT?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    id?: StringFilter<"QuizQuestion"> | string
    quizId?: StringFilter<"QuizQuestion"> | string
    title?: StringFilter<"QuizQuestion"> | string
    description?: StringNullableFilter<"QuizQuestion"> | string | null
    type?: StringFilter<"QuizQuestion"> | string
    required?: BoolFilter<"QuizQuestion"> | boolean
    points?: IntFilter<"QuizQuestion"> | number
    correctAnswer?: JsonNullableFilter<"QuizQuestion">
    options?: JsonNullableFilter<"QuizQuestion">
    order?: IntFilter<"QuizQuestion"> | number
    createdAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"QuizQuestion"> | Date | string
  }

  export type QuizStudentUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizStudentWhereUniqueInput
    update: XOR<QuizStudentUpdateWithoutQuizInput, QuizStudentUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizStudentCreateWithoutQuizInput, QuizStudentUncheckedCreateWithoutQuizInput>
  }

  export type QuizStudentUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizStudentWhereUniqueInput
    data: XOR<QuizStudentUpdateWithoutQuizInput, QuizStudentUncheckedUpdateWithoutQuizInput>
  }

  export type QuizStudentUpdateManyWithWhereWithoutQuizInput = {
    where: QuizStudentScalarWhereInput
    data: XOR<QuizStudentUpdateManyMutationInput, QuizStudentUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizSubmissionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizSubmissionWhereUniqueInput
    update: XOR<QuizSubmissionUpdateWithoutQuizInput, QuizSubmissionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizSubmissionCreateWithoutQuizInput, QuizSubmissionUncheckedCreateWithoutQuizInput>
  }

  export type QuizSubmissionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizSubmissionWhereUniqueInput
    data: XOR<QuizSubmissionUpdateWithoutQuizInput, QuizSubmissionUncheckedUpdateWithoutQuizInput>
  }

  export type QuizSubmissionUpdateManyWithWhereWithoutQuizInput = {
    where: QuizSubmissionScalarWhereInput
    data: XOR<QuizSubmissionUpdateManyMutationInput, QuizSubmissionUncheckedUpdateManyWithoutQuizInput>
  }

  export type StreamItemUpsertWithoutQuizInput = {
    update: XOR<StreamItemUpdateWithoutQuizInput, StreamItemUncheckedUpdateWithoutQuizInput>
    create: XOR<StreamItemCreateWithoutQuizInput, StreamItemUncheckedCreateWithoutQuizInput>
    where?: StreamItemWhereInput
  }

  export type StreamItemUpdateToOneWithWhereWithoutQuizInput = {
    where?: StreamItemWhereInput
    data: XOR<StreamItemUpdateWithoutQuizInput, StreamItemUncheckedUpdateWithoutQuizInput>
  }

  export type StreamItemUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUpdateOneWithoutStreamItemNestedInput
    author?: UserUpdateOneRequiredWithoutStreamItemsNestedInput
    class?: ClassUpdateOneWithoutStreamItemsNestedInput
    topic?: TopicUpdateOneWithoutStreamItemsNestedInput
  }

  export type StreamItemUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUncheckedUpdateOneWithoutStreamItemNestedInput
  }

  export type QuizCreateWithoutQuestionsInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    grades?: GradeCreateNestedManyWithoutQuizInput
    quizStudents?: QuizStudentCreateNestedManyWithoutQuizInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutQuizInput
    streamItem: StreamItemCreateNestedOneWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuestionsInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    grades?: GradeUncheckedCreateNestedManyWithoutQuizInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutQuizInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutQuestionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizUpsertWithoutQuestionsInput = {
    update: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    grades?: GradeUpdateManyWithoutQuizNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutQuizNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutQuizNestedInput
    streamItem?: StreamItemUpdateOneRequiredWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    grades?: GradeUncheckedUpdateManyWithoutQuizNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutQuizNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateWithoutQuizStudentsInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    grades?: GradeCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutQuizInput
    streamItem: StreamItemCreateNestedOneWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuizStudentsInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    grades?: GradeUncheckedCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutQuizStudentsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuizStudentsInput, QuizUncheckedCreateWithoutQuizStudentsInput>
  }

  export type UserCreateWithoutQuizStudentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutQuizStudentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutQuizStudentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizStudentsInput, UserUncheckedCreateWithoutQuizStudentsInput>
  }

  export type QuizUpsertWithoutQuizStudentsInput = {
    update: XOR<QuizUpdateWithoutQuizStudentsInput, QuizUncheckedUpdateWithoutQuizStudentsInput>
    create: XOR<QuizCreateWithoutQuizStudentsInput, QuizUncheckedCreateWithoutQuizStudentsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuizStudentsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuizStudentsInput, QuizUncheckedUpdateWithoutQuizStudentsInput>
  }

  export type QuizUpdateWithoutQuizStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    grades?: GradeUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutQuizNestedInput
    streamItem?: StreamItemUpdateOneRequiredWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuizStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    grades?: GradeUncheckedUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type UserUpsertWithoutQuizStudentsInput = {
    update: XOR<UserUpdateWithoutQuizStudentsInput, UserUncheckedUpdateWithoutQuizStudentsInput>
    create: XOR<UserCreateWithoutQuizStudentsInput, UserUncheckedCreateWithoutQuizStudentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizStudentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizStudentsInput, UserUncheckedUpdateWithoutQuizStudentsInput>
  }

  export type UserUpdateWithoutQuizStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type QuizCreateWithoutQuizSubmissionsInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    grades?: GradeCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    quizStudents?: QuizStudentCreateNestedManyWithoutQuizInput
    streamItem: StreamItemCreateNestedOneWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuizSubmissionsInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    grades?: GradeUncheckedCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutQuizSubmissionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuizSubmissionsInput, QuizUncheckedCreateWithoutQuizSubmissionsInput>
  }

  export type UserCreateWithoutQuizSubmissionsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutQuizSubmissionsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutQuizSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizSubmissionsInput, UserUncheckedCreateWithoutQuizSubmissionsInput>
  }

  export type QuizUpsertWithoutQuizSubmissionsInput = {
    update: XOR<QuizUpdateWithoutQuizSubmissionsInput, QuizUncheckedUpdateWithoutQuizSubmissionsInput>
    create: XOR<QuizCreateWithoutQuizSubmissionsInput, QuizUncheckedCreateWithoutQuizSubmissionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuizSubmissionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuizSubmissionsInput, QuizUncheckedUpdateWithoutQuizSubmissionsInput>
  }

  export type QuizUpdateWithoutQuizSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    grades?: GradeUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutQuizNestedInput
    streamItem?: StreamItemUpdateOneRequiredWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuizSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    grades?: GradeUncheckedUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type UserUpsertWithoutQuizSubmissionsInput = {
    update: XOR<UserUpdateWithoutQuizSubmissionsInput, UserUncheckedUpdateWithoutQuizSubmissionsInput>
    create: XOR<UserCreateWithoutQuizSubmissionsInput, UserUncheckedCreateWithoutQuizSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizSubmissionsInput, UserUncheckedUpdateWithoutQuizSubmissionsInput>
  }

  export type UserUpdateWithoutQuizSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type MaterialStudentCreateWithoutMaterialInput = {
    id?: string
    student: UserCreateNestedOneWithoutMaterialStudentsInput
  }

  export type MaterialStudentUncheckedCreateWithoutMaterialInput = {
    id?: string
    studentId: string
  }

  export type MaterialStudentCreateOrConnectWithoutMaterialInput = {
    where: MaterialStudentWhereUniqueInput
    create: XOR<MaterialStudentCreateWithoutMaterialInput, MaterialStudentUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialStudentCreateManyMaterialInputEnvelope = {
    data: MaterialStudentCreateManyMaterialInput | MaterialStudentCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type StreamItemCreateWithoutMaterialInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentCreateNestedManyWithoutStreamItemInput
    quiz?: QuizCreateNestedOneWithoutStreamItemInput
    author: UserCreateNestedOneWithoutStreamItemsInput
    class?: ClassCreateNestedOneWithoutStreamItemsInput
    topic?: TopicCreateNestedOneWithoutStreamItemsInput
  }

  export type StreamItemUncheckedCreateWithoutMaterialInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    authorId: string
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStreamItemInput
    quiz?: QuizUncheckedCreateNestedOneWithoutStreamItemInput
  }

  export type StreamItemCreateOrConnectWithoutMaterialInput = {
    where: StreamItemWhereUniqueInput
    create: XOR<StreamItemCreateWithoutMaterialInput, StreamItemUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialStudentUpsertWithWhereUniqueWithoutMaterialInput = {
    where: MaterialStudentWhereUniqueInput
    update: XOR<MaterialStudentUpdateWithoutMaterialInput, MaterialStudentUncheckedUpdateWithoutMaterialInput>
    create: XOR<MaterialStudentCreateWithoutMaterialInput, MaterialStudentUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialStudentUpdateWithWhereUniqueWithoutMaterialInput = {
    where: MaterialStudentWhereUniqueInput
    data: XOR<MaterialStudentUpdateWithoutMaterialInput, MaterialStudentUncheckedUpdateWithoutMaterialInput>
  }

  export type MaterialStudentUpdateManyWithWhereWithoutMaterialInput = {
    where: MaterialStudentScalarWhereInput
    data: XOR<MaterialStudentUpdateManyMutationInput, MaterialStudentUncheckedUpdateManyWithoutMaterialInput>
  }

  export type StreamItemUpsertWithoutMaterialInput = {
    update: XOR<StreamItemUpdateWithoutMaterialInput, StreamItemUncheckedUpdateWithoutMaterialInput>
    create: XOR<StreamItemCreateWithoutMaterialInput, StreamItemUncheckedCreateWithoutMaterialInput>
    where?: StreamItemWhereInput
  }

  export type StreamItemUpdateToOneWithWhereWithoutMaterialInput = {
    where?: StreamItemWhereInput
    data: XOR<StreamItemUpdateWithoutMaterialInput, StreamItemUncheckedUpdateWithoutMaterialInput>
  }

  export type StreamItemUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUpdateManyWithoutStreamItemNestedInput
    quiz?: QuizUpdateOneWithoutStreamItemNestedInput
    author?: UserUpdateOneRequiredWithoutStreamItemsNestedInput
    class?: ClassUpdateOneWithoutStreamItemsNestedInput
    topic?: TopicUpdateOneWithoutStreamItemsNestedInput
  }

  export type StreamItemUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStreamItemNestedInput
    quiz?: QuizUncheckedUpdateOneWithoutStreamItemNestedInput
  }

  export type MaterialCreateWithoutMaterialStudentsInput = {
    id?: string
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: MaterialCreateassignedGroupsInput | string[]
    streamItem: StreamItemCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutMaterialStudentsInput = {
    id?: string
    streamItemId: string
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: MaterialCreateassignedGroupsInput | string[]
  }

  export type MaterialCreateOrConnectWithoutMaterialStudentsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutMaterialStudentsInput, MaterialUncheckedCreateWithoutMaterialStudentsInput>
  }

  export type UserCreateWithoutMaterialStudentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutMaterialStudentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutMaterialStudentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMaterialStudentsInput, UserUncheckedCreateWithoutMaterialStudentsInput>
  }

  export type MaterialUpsertWithoutMaterialStudentsInput = {
    update: XOR<MaterialUpdateWithoutMaterialStudentsInput, MaterialUncheckedUpdateWithoutMaterialStudentsInput>
    create: XOR<MaterialCreateWithoutMaterialStudentsInput, MaterialUncheckedCreateWithoutMaterialStudentsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutMaterialStudentsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutMaterialStudentsInput, MaterialUncheckedUpdateWithoutMaterialStudentsInput>
  }

  export type MaterialUpdateWithoutMaterialStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: MaterialUpdateassignedGroupsInput | string[]
    streamItem?: StreamItemUpdateOneRequiredWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutMaterialStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: MaterialUpdateassignedGroupsInput | string[]
  }

  export type UserUpsertWithoutMaterialStudentsInput = {
    update: XOR<UserUpdateWithoutMaterialStudentsInput, UserUncheckedUpdateWithoutMaterialStudentsInput>
    create: XOR<UserCreateWithoutMaterialStudentsInput, UserUncheckedCreateWithoutMaterialStudentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMaterialStudentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMaterialStudentsInput, UserUncheckedUpdateWithoutMaterialStudentsInput>
  }

  export type UserUpdateWithoutMaterialStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutMaterialStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type StreamItemCreateWithoutAttachmentsInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentCreateNestedOneWithoutStreamItemInput
    material?: MaterialCreateNestedOneWithoutStreamItemInput
    quiz?: QuizCreateNestedOneWithoutStreamItemInput
    author: UserCreateNestedOneWithoutStreamItemsInput
    class?: ClassCreateNestedOneWithoutStreamItemsInput
    topic?: TopicCreateNestedOneWithoutStreamItemsInput
  }

  export type StreamItemUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    authorId: string
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStreamItemInput
    assignment?: AssignmentUncheckedCreateNestedOneWithoutStreamItemInput
    material?: MaterialUncheckedCreateNestedOneWithoutStreamItemInput
    quiz?: QuizUncheckedCreateNestedOneWithoutStreamItemInput
  }

  export type StreamItemCreateOrConnectWithoutAttachmentsInput = {
    where: StreamItemWhereUniqueInput
    create: XOR<StreamItemCreateWithoutAttachmentsInput, StreamItemUncheckedCreateWithoutAttachmentsInput>
  }

  export type StreamItemUpsertWithoutAttachmentsInput = {
    update: XOR<StreamItemUpdateWithoutAttachmentsInput, StreamItemUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<StreamItemCreateWithoutAttachmentsInput, StreamItemUncheckedCreateWithoutAttachmentsInput>
    where?: StreamItemWhereInput
  }

  export type StreamItemUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: StreamItemWhereInput
    data: XOR<StreamItemUpdateWithoutAttachmentsInput, StreamItemUncheckedUpdateWithoutAttachmentsInput>
  }

  export type StreamItemUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUpdateOneWithoutStreamItemNestedInput
    material?: MaterialUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUpdateOneWithoutStreamItemNestedInput
    author?: UserUpdateOneRequiredWithoutStreamItemsNestedInput
    class?: ClassUpdateOneWithoutStreamItemsNestedInput
    topic?: TopicUpdateOneWithoutStreamItemsNestedInput
  }

  export type StreamItemUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutStreamItemNestedInput
    material?: MaterialUncheckedUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUncheckedUpdateOneWithoutStreamItemNestedInput
  }

  export type AssignmentCreateWithoutGradesInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutAssignmentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
    streamItem: StreamItemCreateNestedOneWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutGradesInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    instructions?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: AssignmentCreateassignedGroupsInput | string[]
    deletedAt?: Date | string | null
    isDeleted?: boolean
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutAssignmentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutGradesInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutGradesInput, AssignmentUncheckedCreateWithoutGradesInput>
  }

  export type ClassCreateWithoutGradesInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberCreateNestedManyWithoutClassInput
    module?: ModuleCreateNestedOneWithoutClassesInput
    teacher: UserCreateNestedOneWithoutClassesAsTeacherInput
    streamItems?: StreamItemCreateNestedManyWithoutClassInput
    topics?: TopicCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutGradesInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    teacherId: string
    moduleId?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberUncheckedCreateNestedManyWithoutClassInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutClassInput
    topics?: TopicUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutGradesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutGradesInput, ClassUncheckedCreateWithoutGradesInput>
  }

  export type UserCreateWithoutGradesAsGraderInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutGradesAsGraderInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutGradesAsGraderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGradesAsGraderInput, UserUncheckedCreateWithoutGradesAsGraderInput>
  }

  export type QuizCreateWithoutGradesInput = {
    id?: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    quizStudents?: QuizStudentCreateNestedManyWithoutQuizInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutQuizInput
    streamItem: StreamItemCreateNestedOneWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutGradesInput = {
    id?: string
    streamItemId: string
    points?: number | null
    dueDate?: Date | string | null
    dueTime?: Date | string | null
    description?: string | null
    assignToAll?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedGroups?: QuizCreateassignedGroupsInput | string[]
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutQuizInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutGradesInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutGradesInput, QuizUncheckedCreateWithoutGradesInput>
  }

  export type UserCreateWithoutGradesAsStudentInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutGradesAsStudentInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutGradesAsStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGradesAsStudentInput, UserUncheckedCreateWithoutGradesAsStudentInput>
  }

  export type AssignmentUpsertWithoutGradesInput = {
    update: XOR<AssignmentUpdateWithoutGradesInput, AssignmentUncheckedUpdateWithoutGradesInput>
    create: XOR<AssignmentCreateWithoutGradesInput, AssignmentUncheckedCreateWithoutGradesInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutGradesInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutGradesInput, AssignmentUncheckedUpdateWithoutGradesInput>
  }

  export type AssignmentUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentStudents?: AssignmentStudentUpdateManyWithoutAssignmentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
    streamItem?: StreamItemUpdateOneRequiredWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: AssignmentUpdateassignedGroupsInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutAssignmentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type ClassUpsertWithoutGradesInput = {
    update: XOR<ClassUpdateWithoutGradesInput, ClassUncheckedUpdateWithoutGradesInput>
    create: XOR<ClassCreateWithoutGradesInput, ClassUncheckedCreateWithoutGradesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutGradesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutGradesInput, ClassUncheckedUpdateWithoutGradesInput>
  }

  export type ClassUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUpdateManyWithoutClassNestedInput
    module?: ModuleUpdateOneWithoutClassesNestedInput
    teacher?: UserUpdateOneRequiredWithoutClassesAsTeacherNestedInput
    streamItems?: StreamItemUpdateManyWithoutClassNestedInput
    topics?: TopicUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUncheckedUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutClassNestedInput
    topics?: TopicUncheckedUpdateManyWithoutClassNestedInput
  }

  export type UserUpsertWithoutGradesAsGraderInput = {
    update: XOR<UserUpdateWithoutGradesAsGraderInput, UserUncheckedUpdateWithoutGradesAsGraderInput>
    create: XOR<UserCreateWithoutGradesAsGraderInput, UserUncheckedCreateWithoutGradesAsGraderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGradesAsGraderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGradesAsGraderInput, UserUncheckedUpdateWithoutGradesAsGraderInput>
  }

  export type UserUpdateWithoutGradesAsGraderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutGradesAsGraderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type QuizUpsertWithoutGradesInput = {
    update: XOR<QuizUpdateWithoutGradesInput, QuizUncheckedUpdateWithoutGradesInput>
    create: XOR<QuizCreateWithoutGradesInput, QuizUncheckedCreateWithoutGradesInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutGradesInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutGradesInput, QuizUncheckedUpdateWithoutGradesInput>
  }

  export type QuizUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutQuizNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutQuizNestedInput
    streamItem?: StreamItemUpdateOneRequiredWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignToAll?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedGroups?: QuizUpdateassignedGroupsInput | string[]
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutQuizNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type UserUpsertWithoutGradesAsStudentInput = {
    update: XOR<UserUpdateWithoutGradesAsStudentInput, UserUncheckedUpdateWithoutGradesAsStudentInput>
    create: XOR<UserCreateWithoutGradesAsStudentInput, UserUncheckedCreateWithoutGradesAsStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGradesAsStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGradesAsStudentInput, UserUncheckedUpdateWithoutGradesAsStudentInput>
  }

  export type UserUpdateWithoutGradesAsStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutGradesAsStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ClassCreateWithoutModuleInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberCreateNestedManyWithoutClassInput
    teacher: UserCreateNestedOneWithoutClassesAsTeacherInput
    grades?: GradeCreateNestedManyWithoutClassInput
    streamItems?: StreamItemCreateNestedManyWithoutClassInput
    topics?: TopicCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutModuleInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    teacherId: string
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClassMemberUncheckedCreateNestedManyWithoutClassInput
    grades?: GradeUncheckedCreateNestedManyWithoutClassInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutClassInput
    topics?: TopicUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutModuleInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput>
  }

  export type ClassCreateManyModuleInputEnvelope = {
    data: ClassCreateManyModuleInput | ClassCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutModulesCreatedInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutModulesCreatedInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutModulesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModulesCreatedInput, UserUncheckedCreateWithoutModulesCreatedInput>
  }

  export type ClassUpsertWithWhereUniqueWithoutModuleInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutModuleInput, ClassUncheckedUpdateWithoutModuleInput>
    create: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutModuleInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutModuleInput, ClassUncheckedUpdateWithoutModuleInput>
  }

  export type ClassUpdateManyWithWhereWithoutModuleInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutModuleInput>
  }

  export type UserUpsertWithoutModulesCreatedInput = {
    update: XOR<UserUpdateWithoutModulesCreatedInput, UserUncheckedUpdateWithoutModulesCreatedInput>
    create: XOR<UserCreateWithoutModulesCreatedInput, UserUncheckedCreateWithoutModulesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModulesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModulesCreatedInput, UserUncheckedUpdateWithoutModulesCreatedInput>
  }

  export type UserUpdateWithoutModulesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutModulesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutParentRelationsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutParentRelationsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutParentRelationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParentRelationsInput, UserUncheckedCreateWithoutParentRelationsInput>
  }

  export type UserCreateWithoutStudentParentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutStudentParentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutStudentParentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentParentsInput, UserUncheckedCreateWithoutStudentParentsInput>
  }

  export type UserUpsertWithoutParentRelationsInput = {
    update: XOR<UserUpdateWithoutParentRelationsInput, UserUncheckedUpdateWithoutParentRelationsInput>
    create: XOR<UserCreateWithoutParentRelationsInput, UserUncheckedCreateWithoutParentRelationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParentRelationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParentRelationsInput, UserUncheckedUpdateWithoutParentRelationsInput>
  }

  export type UserUpdateWithoutParentRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutParentRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUpsertWithoutStudentParentsInput = {
    update: XOR<UserUpdateWithoutStudentParentsInput, UserUncheckedUpdateWithoutStudentParentsInput>
    create: XOR<UserCreateWithoutStudentParentsInput, UserUncheckedCreateWithoutStudentParentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentParentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentParentsInput, UserUncheckedUpdateWithoutStudentParentsInput>
  }

  export type UserUpdateWithoutStudentParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type StreamItemCreateWithoutAnnouncementStudentsInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    assignment?: AssignmentCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentCreateNestedManyWithoutStreamItemInput
    material?: MaterialCreateNestedOneWithoutStreamItemInput
    quiz?: QuizCreateNestedOneWithoutStreamItemInput
    author: UserCreateNestedOneWithoutStreamItemsInput
    class?: ClassCreateNestedOneWithoutStreamItemsInput
    topic?: TopicCreateNestedOneWithoutStreamItemsInput
  }

  export type StreamItemUncheckedCreateWithoutAnnouncementStudentsInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    authorId: string
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
    assignment?: AssignmentUncheckedCreateNestedOneWithoutStreamItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStreamItemInput
    material?: MaterialUncheckedCreateNestedOneWithoutStreamItemInput
    quiz?: QuizUncheckedCreateNestedOneWithoutStreamItemInput
  }

  export type StreamItemCreateOrConnectWithoutAnnouncementStudentsInput = {
    where: StreamItemWhereUniqueInput
    create: XOR<StreamItemCreateWithoutAnnouncementStudentsInput, StreamItemUncheckedCreateWithoutAnnouncementStudentsInput>
  }

  export type UserCreateWithoutAnnouncementStudentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAnnouncementStudentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    ordersCreated?: OrdenUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAnnouncementStudentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementStudentsInput, UserUncheckedCreateWithoutAnnouncementStudentsInput>
  }

  export type StreamItemUpsertWithoutAnnouncementStudentsInput = {
    update: XOR<StreamItemUpdateWithoutAnnouncementStudentsInput, StreamItemUncheckedUpdateWithoutAnnouncementStudentsInput>
    create: XOR<StreamItemCreateWithoutAnnouncementStudentsInput, StreamItemUncheckedCreateWithoutAnnouncementStudentsInput>
    where?: StreamItemWhereInput
  }

  export type StreamItemUpdateToOneWithWhereWithoutAnnouncementStudentsInput = {
    where?: StreamItemWhereInput
    data: XOR<StreamItemUpdateWithoutAnnouncementStudentsInput, StreamItemUncheckedUpdateWithoutAnnouncementStudentsInput>
  }

  export type StreamItemUpdateWithoutAnnouncementStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    assignment?: AssignmentUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUpdateOneWithoutStreamItemNestedInput
    author?: UserUpdateOneRequiredWithoutStreamItemsNestedInput
    class?: ClassUpdateOneWithoutStreamItemsNestedInput
    topic?: TopicUpdateOneWithoutStreamItemsNestedInput
  }

  export type StreamItemUncheckedUpdateWithoutAnnouncementStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    assignment?: AssignmentUncheckedUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUncheckedUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUncheckedUpdateOneWithoutStreamItemNestedInput
  }

  export type UserUpsertWithoutAnnouncementStudentsInput = {
    update: XOR<UserUpdateWithoutAnnouncementStudentsInput, UserUncheckedUpdateWithoutAnnouncementStudentsInput>
    create: XOR<UserCreateWithoutAnnouncementStudentsInput, UserUncheckedCreateWithoutAnnouncementStudentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnouncementStudentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnouncementStudentsInput, UserUncheckedUpdateWithoutAnnouncementStudentsInput>
  }

  export type UserUpdateWithoutAnnouncementStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersCreated?: OrdenUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type EventoCreateWithoutClientInput = {
    id?: string
    name: string
    date: Date | string
    time?: Date | string | null
    location?: string | null
    type: string
    status?: string
    attendees?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    date: Date | string
    time?: Date | string | null
    location?: string | null
    type: string
    status?: string
    attendees?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoCreateOrConnectWithoutClientInput = {
    where: EventoWhereUniqueInput
    create: XOR<EventoCreateWithoutClientInput, EventoUncheckedCreateWithoutClientInput>
  }

  export type EventoCreateManyClientInputEnvelope = {
    data: EventoCreateManyClientInput | EventoCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type OrdenCreateWithoutClientInput = {
    id?: string
    orderNumber: string
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordenItems?: OrdenItemCreateNestedManyWithoutOrdenInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
  }

  export type OrdenUncheckedCreateWithoutClientInput = {
    id?: string
    orderNumber: string
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ordenItems?: OrdenItemUncheckedCreateNestedManyWithoutOrdenInput
  }

  export type OrdenCreateOrConnectWithoutClientInput = {
    where: OrdenWhereUniqueInput
    create: XOR<OrdenCreateWithoutClientInput, OrdenUncheckedCreateWithoutClientInput>
  }

  export type OrdenCreateManyClientInputEnvelope = {
    data: OrdenCreateManyClientInput | OrdenCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type EventoUpsertWithWhereUniqueWithoutClientInput = {
    where: EventoWhereUniqueInput
    update: XOR<EventoUpdateWithoutClientInput, EventoUncheckedUpdateWithoutClientInput>
    create: XOR<EventoCreateWithoutClientInput, EventoUncheckedCreateWithoutClientInput>
  }

  export type EventoUpdateWithWhereUniqueWithoutClientInput = {
    where: EventoWhereUniqueInput
    data: XOR<EventoUpdateWithoutClientInput, EventoUncheckedUpdateWithoutClientInput>
  }

  export type EventoUpdateManyWithWhereWithoutClientInput = {
    where: EventoScalarWhereInput
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyWithoutClientInput>
  }

  export type EventoScalarWhereInput = {
    AND?: EventoScalarWhereInput | EventoScalarWhereInput[]
    OR?: EventoScalarWhereInput[]
    NOT?: EventoScalarWhereInput | EventoScalarWhereInput[]
    id?: StringFilter<"Evento"> | string
    name?: StringFilter<"Evento"> | string
    date?: DateTimeFilter<"Evento"> | Date | string
    time?: DateTimeNullableFilter<"Evento"> | Date | string | null
    location?: StringNullableFilter<"Evento"> | string | null
    type?: StringFilter<"Evento"> | string
    status?: StringFilter<"Evento"> | string
    attendees?: IntFilter<"Evento"> | number
    description?: StringNullableFilter<"Evento"> | string | null
    clientId?: StringNullableFilter<"Evento"> | string | null
    createdAt?: DateTimeFilter<"Evento"> | Date | string
    updatedAt?: DateTimeFilter<"Evento"> | Date | string
  }

  export type OrdenUpsertWithWhereUniqueWithoutClientInput = {
    where: OrdenWhereUniqueInput
    update: XOR<OrdenUpdateWithoutClientInput, OrdenUncheckedUpdateWithoutClientInput>
    create: XOR<OrdenCreateWithoutClientInput, OrdenUncheckedCreateWithoutClientInput>
  }

  export type OrdenUpdateWithWhereUniqueWithoutClientInput = {
    where: OrdenWhereUniqueInput
    data: XOR<OrdenUpdateWithoutClientInput, OrdenUncheckedUpdateWithoutClientInput>
  }

  export type OrdenUpdateManyWithWhereWithoutClientInput = {
    where: OrdenScalarWhereInput
    data: XOR<OrdenUpdateManyMutationInput, OrdenUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientCreateWithoutEventosInput = {
    id?: string
    companyName: string
    contactName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    status?: string
    source?: string | null
    totalProjects?: number
    totalRevenue?: Decimal | DecimalJsLike | number | string
    lastContact?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordenes?: OrdenCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutEventosInput = {
    id?: string
    companyName: string
    contactName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    status?: string
    source?: string | null
    totalProjects?: number
    totalRevenue?: Decimal | DecimalJsLike | number | string
    lastContact?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordenes?: OrdenUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutEventosInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutEventosInput, ClientUncheckedCreateWithoutEventosInput>
  }

  export type ClientUpsertWithoutEventosInput = {
    update: XOR<ClientUpdateWithoutEventosInput, ClientUncheckedUpdateWithoutEventosInput>
    create: XOR<ClientCreateWithoutEventosInput, ClientUncheckedCreateWithoutEventosInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutEventosInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutEventosInput, ClientUncheckedUpdateWithoutEventosInput>
  }

  export type ClientUpdateWithoutEventosInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    totalProjects?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordenes?: OrdenUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutEventosInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    totalProjects?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordenes?: OrdenUncheckedUpdateManyWithoutClientNestedInput
  }

  export type OrdenItemCreateWithoutOrdenInput = {
    id?: string
    code?: string | null
    title: string
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    total: Decimal | DecimalJsLike | number | string
    order?: number
    createdAt?: Date | string
  }

  export type OrdenItemUncheckedCreateWithoutOrdenInput = {
    id?: string
    code?: string | null
    title: string
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    total: Decimal | DecimalJsLike | number | string
    order?: number
    createdAt?: Date | string
  }

  export type OrdenItemCreateOrConnectWithoutOrdenInput = {
    where: OrdenItemWhereUniqueInput
    create: XOR<OrdenItemCreateWithoutOrdenInput, OrdenItemUncheckedCreateWithoutOrdenInput>
  }

  export type OrdenItemCreateManyOrdenInputEnvelope = {
    data: OrdenItemCreateManyOrdenInput | OrdenItemCreateManyOrdenInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutOrdenesInput = {
    id?: string
    companyName: string
    contactName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    status?: string
    source?: string | null
    totalProjects?: number
    totalRevenue?: Decimal | DecimalJsLike | number | string
    lastContact?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventos?: EventoCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutOrdenesInput = {
    id?: string
    companyName: string
    contactName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    status?: string
    source?: string | null
    totalProjects?: number
    totalRevenue?: Decimal | DecimalJsLike | number | string
    lastContact?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventos?: EventoUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutOrdenesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutOrdenesInput, ClientUncheckedCreateWithoutOrdenesInput>
  }

  export type UserCreateWithoutOrdersCreatedInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentCreateNestedManyWithoutParentInput
    studentParents?: StudentParentCreateNestedManyWithoutStudentInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    resident?: ResidentCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutOrdersCreatedInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role?: string
    avatar?: string | null
    passwordHash?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grupoAsignado?: string | null
    announcementStudents?: AnnouncementStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentStudents?: AssignmentStudentUncheckedCreateNestedManyWithoutStudentInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    classMemberships?: ClassMemberUncheckedCreateNestedManyWithoutUserInput
    classesAsTeacher?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    gradesAsGrader?: GradeUncheckedCreateNestedManyWithoutGradedByInput
    gradesAsStudent?: GradeUncheckedCreateNestedManyWithoutStudentInput
    materialStudents?: MaterialStudentUncheckedCreateNestedManyWithoutStudentInput
    modulesCreated?: ModuleUncheckedCreateNestedManyWithoutCreatedByInput
    quizStudents?: QuizStudentUncheckedCreateNestedManyWithoutStudentInput
    quizSubmissions?: QuizSubmissionUncheckedCreateNestedManyWithoutStudentInput
    streamItems?: StreamItemUncheckedCreateNestedManyWithoutAuthorInput
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    studentParents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    resident?: ResidentUncheckedCreateNestedOneWithoutUserInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutAdministratorInput
    recordedVitals?: VitalSignUncheckedCreateNestedManyWithoutRecorderInput
    authoredNotes?: NursingNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutOrdersCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
  }

  export type OrdenItemUpsertWithWhereUniqueWithoutOrdenInput = {
    where: OrdenItemWhereUniqueInput
    update: XOR<OrdenItemUpdateWithoutOrdenInput, OrdenItemUncheckedUpdateWithoutOrdenInput>
    create: XOR<OrdenItemCreateWithoutOrdenInput, OrdenItemUncheckedCreateWithoutOrdenInput>
  }

  export type OrdenItemUpdateWithWhereUniqueWithoutOrdenInput = {
    where: OrdenItemWhereUniqueInput
    data: XOR<OrdenItemUpdateWithoutOrdenInput, OrdenItemUncheckedUpdateWithoutOrdenInput>
  }

  export type OrdenItemUpdateManyWithWhereWithoutOrdenInput = {
    where: OrdenItemScalarWhereInput
    data: XOR<OrdenItemUpdateManyMutationInput, OrdenItemUncheckedUpdateManyWithoutOrdenInput>
  }

  export type OrdenItemScalarWhereInput = {
    AND?: OrdenItemScalarWhereInput | OrdenItemScalarWhereInput[]
    OR?: OrdenItemScalarWhereInput[]
    NOT?: OrdenItemScalarWhereInput | OrdenItemScalarWhereInput[]
    id?: StringFilter<"OrdenItem"> | string
    ordenId?: StringFilter<"OrdenItem"> | string
    code?: StringNullableFilter<"OrdenItem"> | string | null
    title?: StringFilter<"OrdenItem"> | string
    price?: DecimalFilter<"OrdenItem"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"OrdenItem"> | number
    total?: DecimalFilter<"OrdenItem"> | Decimal | DecimalJsLike | number | string
    order?: IntFilter<"OrdenItem"> | number
    createdAt?: DateTimeFilter<"OrdenItem"> | Date | string
  }

  export type ClientUpsertWithoutOrdenesInput = {
    update: XOR<ClientUpdateWithoutOrdenesInput, ClientUncheckedUpdateWithoutOrdenesInput>
    create: XOR<ClientCreateWithoutOrdenesInput, ClientUncheckedCreateWithoutOrdenesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutOrdenesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutOrdenesInput, ClientUncheckedUpdateWithoutOrdenesInput>
  }

  export type ClientUpdateWithoutOrdenesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    totalProjects?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventos?: EventoUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutOrdenesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    totalProjects?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventos?: EventoUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutOrdersCreatedInput = {
    update: XOR<UserUpdateWithoutOrdersCreatedInput, UserUncheckedUpdateWithoutOrdersCreatedInput>
    create: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersCreatedInput, UserUncheckedUpdateWithoutOrdersCreatedInput>
  }

  export type UserUpdateWithoutOrdersCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    resident?: ResidentUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grupoAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentStudents?: AssignmentStudentUncheckedUpdateManyWithoutStudentNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    classMemberships?: ClassMemberUncheckedUpdateManyWithoutUserNestedInput
    classesAsTeacher?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    gradesAsGrader?: GradeUncheckedUpdateManyWithoutGradedByNestedInput
    gradesAsStudent?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    materialStudents?: MaterialStudentUncheckedUpdateManyWithoutStudentNestedInput
    modulesCreated?: ModuleUncheckedUpdateManyWithoutCreatedByNestedInput
    quizStudents?: QuizStudentUncheckedUpdateManyWithoutStudentNestedInput
    quizSubmissions?: QuizSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutAuthorNestedInput
    parentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    studentParents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    resident?: ResidentUncheckedUpdateOneWithoutUserNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutAdministratorNestedInput
    recordedVitals?: VitalSignUncheckedUpdateManyWithoutRecorderNestedInput
    authoredNotes?: NursingNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type OrdenCreateWithoutOrdenItemsInput = {
    id?: string
    orderNumber: string
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutOrdenesInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
  }

  export type OrdenUncheckedCreateWithoutOrdenItemsInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrdenCreateOrConnectWithoutOrdenItemsInput = {
    where: OrdenWhereUniqueInput
    create: XOR<OrdenCreateWithoutOrdenItemsInput, OrdenUncheckedCreateWithoutOrdenItemsInput>
  }

  export type OrdenUpsertWithoutOrdenItemsInput = {
    update: XOR<OrdenUpdateWithoutOrdenItemsInput, OrdenUncheckedUpdateWithoutOrdenItemsInput>
    create: XOR<OrdenCreateWithoutOrdenItemsInput, OrdenUncheckedCreateWithoutOrdenItemsInput>
    where?: OrdenWhereInput
  }

  export type OrdenUpdateToOneWithWhereWithoutOrdenItemsInput = {
    where?: OrdenWhereInput
    data: XOR<OrdenUpdateWithoutOrdenItemsInput, OrdenUncheckedUpdateWithoutOrdenItemsInput>
  }

  export type OrdenUpdateWithoutOrdenItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutOrdenesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
  }

  export type OrdenUncheckedUpdateWithoutOrdenItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementStudentCreateManyStudentInput = {
    id?: string
    streamItemId: string
  }

  export type AssignmentStudentCreateManyStudentInput = {
    id?: string
    assignmentId: string
  }

  export type AssignmentSubmissionCreateManyStudentInput = {
    id?: string
    assignmentId: string
    content?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    submittedAt?: Date | string | null
    returnedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    reviewedAt?: Date | string | null
  }

  export type ClassMemberCreateManyUserInput = {
    id?: string
    classId: string
    role?: string
    joinedAt?: Date | string
    status?: string
  }

  export type ClassCreateManyTeacherInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    moduleId?: string | null
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateManyGradedByInput = {
    id?: string
    classId: string
    assignmentId?: string | null
    quizId?: string | null
    studentId: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateManyStudentInput = {
    id?: string
    classId: string
    assignmentId?: string | null
    quizId?: string | null
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialStudentCreateManyStudentInput = {
    id?: string
    materialId: string
  }

  export type ModuleCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    category?: string | null
    difficulty?: string | null
    duration?: number | null
    thumbnail?: string | null
    instructor?: string | null
    isActive?: boolean
    isPublished?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrdenCreateManyCreatedByInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizStudentCreateManyStudentInput = {
    id?: string
    quizId: string
  }

  export type QuizSubmissionCreateManyStudentInput = {
    id?: string
    quizId: string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StreamItemCreateManyAuthorInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
  }

  export type StudentParentCreateManyParentInput = {
    id?: string
    studentId: string
    relationship?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentCreateManyStudentInput = {
    id?: string
    parentId: string
    relationship?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BugReportCreateManyUserInput = {
    id?: string
    description: string
    status?: string
    type?: string
    errorHash?: string | null
    createdAt?: Date | string
  }

  export type MedicationLogCreateManyAdministratorInput = {
    id?: string
    orderId: string
    administeredAt?: Date | string
    status: string
    notes?: string | null
    shift?: string | null
  }

  export type VitalSignCreateManyRecorderInput = {
    id?: string
    residentId: string
    recordedAt?: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    temperature?: number | null
    oxygenSaturation?: number | null
    glucose?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NursingNoteCreateManyAuthorInput = {
    id?: string
    residentId: string
    createdAt?: Date | string
    shift: string
    category: string
    content: string
    severity?: string
    updatedAt?: Date | string
  }

  export type AnnouncementStudentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItem?: StreamItemUpdateOneRequiredWithoutAnnouncementStudentsNestedInput
  }

  export type AnnouncementStudentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
  }

  export type AnnouncementStudentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamItemId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentStudentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignment?: AssignmentUpdateOneRequiredWithoutAssignmentStudentsNestedInput
  }

  export type AssignmentStudentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentStudentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentSubmissionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment?: AssignmentUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ClassMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClassMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClassUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUpdateManyWithoutClassNestedInput
    module?: ModuleUpdateOneWithoutClassesNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUpdateManyWithoutClassNestedInput
    topics?: TopicUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUncheckedUpdateManyWithoutClassNestedInput
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutClassNestedInput
    topics?: TopicUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUpdateWithoutGradedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneWithoutGradesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradesNestedInput
    quiz?: QuizUpdateOneWithoutGradesNestedInput
    student?: UserUpdateOneRequiredWithoutGradesAsStudentNestedInput
  }

  export type GradeUncheckedUpdateWithoutGradedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutGradedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneWithoutGradesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradesNestedInput
    gradedBy?: UserUpdateOneWithoutGradesAsGraderNestedInput
    quiz?: QuizUpdateOneWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialStudentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    material?: MaterialUpdateOneRequiredWithoutMaterialStudentsNestedInput
  }

  export type MaterialStudentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialStudentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdenUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordenItems?: OrdenItemUpdateManyWithoutOrdenNestedInput
    client?: ClientUpdateOneWithoutOrdenesNestedInput
  }

  export type OrdenUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordenItems?: OrdenItemUncheckedUpdateManyWithoutOrdenNestedInput
  }

  export type OrdenUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizStudentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz?: QuizUpdateOneRequiredWithoutQuizStudentsNestedInput
  }

  export type QuizStudentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
  }

  export type QuizStudentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
  }

  export type QuizSubmissionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutQuizSubmissionsNestedInput
  }

  export type QuizSubmissionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSubmissionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamItemUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUpdateOneWithoutStreamItemNestedInput
    class?: ClassUpdateOneWithoutStreamItemsNestedInput
    topic?: TopicUpdateOneWithoutStreamItemsNestedInput
  }

  export type StreamItemUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUncheckedUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUncheckedUpdateOneWithoutStreamItemNestedInput
  }

  export type StreamItemUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutStudentParentsNestedInput
  }

  export type StudentParentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: UserUpdateOneRequiredWithoutParentRelationsNestedInput
  }

  export type StudentParentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BugReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    errorHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BugReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    errorHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BugReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    errorHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationLogUpdateWithoutAdministratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    order?: MedicationOrderUpdateOneRequiredWithoutLogsNestedInput
  }

  export type MedicationLogUncheckedUpdateWithoutAdministratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationLogUncheckedUpdateManyWithoutAdministratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VitalSignUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    glucose?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentUpdateOneRequiredWithoutVitalSignsNestedInput
  }

  export type VitalSignUncheckedUpdateWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    glucose?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUncheckedUpdateManyWithoutRecorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    glucose?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NursingNoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentUpdateOneRequiredWithoutNursingNotesNestedInput
  }

  export type NursingNoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NursingNoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    residentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationOrderCreateManyResidentInput = {
    id?: string
    medicationName: string
    dosage: string
    frequency: string
    route: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignCreateManyResidentInput = {
    id?: string
    recordedBy: string
    recordedAt?: Date | string
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    temperature?: number | null
    oxygenSaturation?: number | null
    glucose?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NursingNoteCreateManyResidentInput = {
    id?: string
    authorId: string
    createdAt?: Date | string
    shift: string
    category: string
    content: string
    severity?: string
    updatedAt?: Date | string
  }

  export type MedicationOrderUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: MedicationLogUpdateManyWithoutOrderNestedInput
  }

  export type MedicationOrderUncheckedUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: MedicationLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type MedicationOrderUncheckedUpdateManyWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    glucose?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recorder?: UserUpdateOneRequiredWithoutRecordedVitalsNestedInput
  }

  export type VitalSignUncheckedUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    glucose?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUncheckedUpdateManyWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    glucose?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NursingNoteUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAuthoredNotesNestedInput
  }

  export type NursingNoteUncheckedUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NursingNoteUncheckedUpdateManyWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationLogCreateManyOrderInput = {
    id?: string
    administeredBy: string
    administeredAt?: Date | string
    status: string
    notes?: string | null
    shift?: string | null
  }

  export type MedicationLogUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    administrator?: UserUpdateOneRequiredWithoutMedicationLogsNestedInput
  }

  export type MedicationLogUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    administeredBy?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationLogUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    administeredBy?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassMemberCreateManyClassInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
    status?: string
  }

  export type GradeCreateManyClassInput = {
    id?: string
    assignmentId?: string | null
    quizId?: string | null
    studentId: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StreamItemCreateManyClassInput = {
    id?: string
    type: string
    title: string
    content?: string | null
    authorId: string
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
  }

  export type TopicCreateManyClassInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassMemberUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutClassMembershipsNestedInput
  }

  export type ClassMemberUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClassMemberUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type GradeUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneWithoutGradesNestedInput
    gradedBy?: UserUpdateOneWithoutGradesAsGraderNestedInput
    quiz?: QuizUpdateOneWithoutGradesNestedInput
    student?: UserUpdateOneRequiredWithoutGradesAsStudentNestedInput
  }

  export type GradeUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamItemUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUpdateOneWithoutStreamItemNestedInput
    author?: UserUpdateOneRequiredWithoutStreamItemsNestedInput
    topic?: TopicUpdateOneWithoutStreamItemsNestedInput
  }

  export type StreamItemUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUncheckedUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUncheckedUpdateOneWithoutStreamItemNestedInput
  }

  export type StreamItemUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TopicUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streamItems?: StreamItemUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streamItems?: StreamItemUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamItemCreateManyTopicInput = {
    id?: string
    classId?: string | null
    type: string
    title: string
    content?: string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isArchived?: boolean
  }

  export type StreamItemUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUpdateOneWithoutStreamItemNestedInput
    author?: UserUpdateOneRequiredWithoutStreamItemsNestedInput
    class?: ClassUpdateOneWithoutStreamItemsNestedInput
  }

  export type StreamItemUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    announcementStudents?: AnnouncementStudentUncheckedUpdateManyWithoutStreamItemNestedInput
    assignment?: AssignmentUncheckedUpdateOneWithoutStreamItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStreamItemNestedInput
    material?: MaterialUncheckedUpdateOneWithoutStreamItemNestedInput
    quiz?: QuizUncheckedUpdateOneWithoutStreamItemNestedInput
  }

  export type StreamItemUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnouncementStudentCreateManyStreamItemInput = {
    id?: string
    studentId: string
  }

  export type AttachmentCreateManyStreamItemInput = {
    id?: string
    type: string
    name: string
    url?: string | null
    filePath?: string | null
    fileSize?: bigint | number | null
    mimeType?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type AnnouncementStudentUpdateWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    student?: UserUpdateOneRequiredWithoutAnnouncementStudentsNestedInput
  }

  export type AnnouncementStudentUncheckedUpdateWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type AnnouncementStudentUncheckedUpdateManyWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUpdateWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutStreamItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentStudentCreateManyAssignmentInput = {
    id?: string
    studentId: string
  }

  export type AssignmentSubmissionCreateManyAssignmentInput = {
    id?: string
    studentId: string
    content?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    submittedAt?: Date | string | null
    returnedAt?: Date | string | null
    gradedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    reviewedAt?: Date | string | null
  }

  export type GradeCreateManyAssignmentInput = {
    id?: string
    classId: string
    quizId?: string | null
    studentId: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentStudentUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    student?: UserUpdateOneRequiredWithoutAssignmentStudentsNestedInput
  }

  export type AssignmentStudentUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentStudentUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentSubmissionUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: UserUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GradeUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutGradesNestedInput
    gradedBy?: UserUpdateOneWithoutGradesAsGraderNestedInput
    quiz?: QuizUpdateOneWithoutGradesNestedInput
    student?: UserUpdateOneRequiredWithoutGradesAsStudentNestedInput
  }

  export type GradeUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateManyQuizInput = {
    id?: string
    classId: string
    assignmentId?: string | null
    studentId: string
    pointsEarned?: Decimal | DecimalJsLike | number | string | null
    maxPoints?: Decimal | DecimalJsLike | number | string | null
    percentage?: Decimal | DecimalJsLike | number | string | null
    status?: string
    feedback?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    gradedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionCreateManyQuizInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    required?: boolean
    points?: number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizStudentCreateManyQuizInput = {
    id?: string
    studentId: string
  }

  export type QuizSubmissionCreateManyQuizInput = {
    id?: string
    studentId: string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    grade?: Decimal | DecimalJsLike | number | string | null
    studentComments?: string | null
    teacherComments?: string | null
    submittedAt?: Date | string | null
    gradedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneWithoutGradesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradesNestedInput
    gradedBy?: UserUpdateOneWithoutGradesAsGraderNestedInput
    student?: UserUpdateOneRequiredWithoutGradesAsStudentNestedInput
  }

  export type GradeUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPoints?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    correctAnswer?: NullableJsonNullValueInput | InputJsonValue
    options?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizStudentUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    student?: UserUpdateOneRequiredWithoutQuizStudentsNestedInput
  }

  export type QuizStudentUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type QuizStudentUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type QuizSubmissionUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutQuizSubmissionsNestedInput
  }

  export type QuizSubmissionUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSubmissionUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    answers?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    grade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    studentComments?: NullableStringFieldUpdateOperationsInput | string | null
    teacherComments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialStudentCreateManyMaterialInput = {
    id?: string
    studentId: string
  }

  export type MaterialStudentUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    student?: UserUpdateOneRequiredWithoutMaterialStudentsNestedInput
  }

  export type MaterialStudentUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialStudentUncheckedUpdateManyWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCreateManyModuleInput = {
    id?: string
    title: string
    description?: string | null
    classCode: string
    section?: string | null
    subject?: string | null
    room?: string | null
    teacherId: string
    backgroundImage?: string | null
    isArchived?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUpdateManyWithoutClassNestedInput
    teacher?: UserUpdateOneRequiredWithoutClassesAsTeacherNestedInput
    grades?: GradeUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUpdateManyWithoutClassNestedInput
    topics?: TopicUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClassMemberUncheckedUpdateManyWithoutClassNestedInput
    grades?: GradeUncheckedUpdateManyWithoutClassNestedInput
    streamItems?: StreamItemUncheckedUpdateManyWithoutClassNestedInput
    topics?: TopicUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    backgroundImage?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoCreateManyClientInput = {
    id?: string
    name: string
    date: Date | string
    time?: Date | string | null
    location?: string | null
    type: string
    status?: string
    attendees?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrdenCreateManyClientInput = {
    id?: string
    orderNumber: string
    clientName: string
    clientEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: string
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attendees?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attendees?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attendees?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdenUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordenItems?: OrdenItemUpdateManyWithoutOrdenNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
  }

  export type OrdenUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordenItems?: OrdenItemUncheckedUpdateManyWithoutOrdenNestedInput
  }

  export type OrdenUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdenItemCreateManyOrdenInput = {
    id?: string
    code?: string | null
    title: string
    price: Decimal | DecimalJsLike | number | string
    quantity?: number
    total: Decimal | DecimalJsLike | number | string
    order?: number
    createdAt?: Date | string
  }

  export type OrdenItemUpdateWithoutOrdenInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdenItemUncheckedUpdateWithoutOrdenInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdenItemUncheckedUpdateManyWithoutOrdenInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}