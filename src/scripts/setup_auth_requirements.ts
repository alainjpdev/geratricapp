import 'dotenv/config';
import { createClient } from '@supabase/supabase-js';
import path from 'path';
import * as dotenv from 'dotenv';

dotenv.config({ path: path.resolve(process.cwd(), '.env') });

const supabaseUrl = process.env.VITE_SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseKey) {
    console.error('Missing Supabase URL or Service Role Key in .env');
    process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

async function setupAuth() {
    console.log('üîÑ Setting up authentication requirements...');

    // 1. Enable pgcrypto extension
    console.log('Checking/Enabling pgcrypto extension...');
    const { error: extError } = await supabase.rpc('create_extension', { name: 'pgcrypto' })
        .catch(async () => {
            // If rpc create_extension doesn't exist (it usually doesn't by default for security), 
            // we try to run raw SQL if we had direct access, but via client we might be limited.
            // Ideally this should be run in Supabase SQL Editor.
            // Let's try to see if verify_password exists first.
            return { error: null };
        });

    // Since we cannot run raw SQL easily without a specific driver or RPC,
    // we will try to create the function using a "hack" if possible or just log instructions.
    // However, usually we can't create functions via JS client unless we have a specific RPC for it.

    // BUT! Debugging `authService.ts`: it calls `verify_password`. 
    // This function MUST exist in the DB.

    // Let's create a script that attempts to use the "plv8" or similar if enabled, but better yet:
    // If the user is running this locally or on a connected Supabase, they need to run SQL.

    // Wait, `authService.ts` calls `rpc('verify_password', ...)`.
    // Let's assume the user MIGHT NOT have this function.

    console.log('‚ö†Ô∏è  IMPORTANT: The application expects a PostgreSQL function named "verify_password".');
    console.log('Run the following SQL in your Supabase SQL Editor to fix the login error:\n');

    console.log(`
    -- Enable pgcrypto if not already enabled
    create extension if not exists pgcrypto;

    -- Create or replace the password verification function
    create or replace function verify_password(user_password_hash text, input_password text)
    returns boolean
    language plpgsql
    security definer
    as $$
    begin
        -- Note: this assumes the hash was generated via bcrypt and pgcrypto can verify it.
        -- HOWEVER, standard pgcrypto 'crypt' usually generates the hash too.
        -- If the hash was generated by Node.js bcrypt (which it was), pgcrypto's crypt() 
        -- IS compatible if the salt format matches. 
        
        return (user_password_hash = crypt(input_password, user_password_hash));
    end;
    $$;
    `);

    // Let's TRY to see if we can authenticate anyway.
    // Since I cannot run SQL directly from here easily without postgres connection string (I only have Supabase URL/Key),
    // I will try to update the user's password to a PLAIN TEXT one if the RPC fails? 
    // No, `authService.ts` REQUIRES the RPC.

    // ALTERNATIVE: Rewrite `authService.ts` to verify password locally in JS (Client-side verification is insecure but serverside JS is fine).
    // `loginWithUsersTable` runs on the CLIENT SIDE (It's imported in Login.tsx). 
    // WAIT! `authService.ts` is running in the BROWSER.
    // It calls `supabase.rpc('verify_password')`.
    // If the database function calls `crypt()`, it verifies securely on server.

    // The error "Contrase√±a incorrecta" comes from line 69, meaning `passwordValid` was FALSE.
    // This implies the RPC exists but returned false.

    // Issue: Node `bcrypt` vs Postgres `pgcrypto`.
    // Node bcrypt uses `$2b$`. Postgres pgcrypto usually expects `$2a$` or `$2b$`.
    // Let's verify compatibility.

    // Plan B: Update `authService.ts` to compare the hash locally? 
    // NO, we cannot compare hashes safely on the client without exposing the hash (which we are mistakenly doing in line 35 of authService.ts: `.select('..., password_hash')`).
    // Actually, `authService.ts` DOES select `password_hash` to the client!
    // Line 35: `.select('..., password_hash, ...')`
    // Line 57: Calls RPC with the hash FROM THE CLIENT.

    // This is insecure design (hash exposure), but since it IS EXPOSED,
    // we can use `bcryptjs` on the client to compare!

    // The `authService.ts` seems attempted to be "secure" by calling an RPC, 
    // but it sends the hash to the client first.
}

setupAuth();
